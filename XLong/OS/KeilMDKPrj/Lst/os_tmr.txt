; generated by Component: ARM Compiler 5.05 (build 41) Tool: ArmCC [4d0eb9]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\os_tmr.o --asm_dir=.\Lst\ --list_dir=.\Lst\ --depend=.\obj\os_tmr.d --cpu=Cortex-M4.fp --apcs=interwork -O0 -I..\..\..\CMSIS\4.5.0\CMSIS\Include -I..\APP -I..\APP\ST -I..\APP\uCOS -I..\..\BSP\KeilMDK -I..\..\BSP\Board\inc -I..\..\BSP\STM32F4xx\inc -I..\..\BSP\Xlong\inc -I..\..\..\uCOS\uC-CPU -I..\..\..\uCOS\uC-CPU\Ports\ARM-Cortex-M4 -I..\..\..\uCOS\uC-LIB -I..\..\..\uCOS\uC-LIB\Ports\ARM-Cortex-M4 -I..\..\..\uCOS\uCOS-III\Source -I..\..\..\uCOS\uCOS-III\Ports\ARM-Cortex-M4 -IC:\Users\V200\Desktop\XLong\XLong\OS\KeilMDKPrj\RTE -Id:\Keil_v5\ARM\PACK\Keil\STM32F4xx_DFP\1.0.8\Device\Include -Id:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -DSTM32F427_437xx -DSTM32F427_437xx -DUSE_STDPERIPH_DRIVER --omf_browse=.\obj\os_tmr.crf ..\..\..\uCOS\uCOS-III\Source\os_tmr.c]
                          THUMB

                          AREA ||i.OSTmrCreate||, CODE, READONLY, ALIGN=2

                  OSTmrCreate PROC
;;;114    
;;;115    void  OSTmrCreate (OS_TMR               *p_tmr,
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;116                       CPU_CHAR             *p_name,
;;;117                       OS_TICK               dly,
;;;118                       OS_TICK               period,
;;;119                       OS_OPT                opt,
;;;120                       OS_TMR_CALLBACK_PTR   p_callback,
;;;121                       void                 *p_callback_arg,
;;;122                       OS_ERR               *p_err)
;;;123    {
000004  4604              MOV      r4,r0
000006  4688              MOV      r8,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
00000c  e9ddab0b          LDRD     r10,r11,[sp,#0x2c]
000010  f8dd9028          LDR      r9,[sp,#0x28]
000014  9d0d              LDR      r5,[sp,#0x34]
;;;124    #ifdef OS_SAFETY_CRITICAL
;;;125        if (p_err == (OS_ERR *)0) {
;;;126            OS_SAFETY_CRITICAL_EXCEPTION();
;;;127            return;
;;;128        }
;;;129    #endif
;;;130    
;;;131    #ifdef OS_SAFETY_CRITICAL_IEC61508
;;;132        if (OSSafetyCriticalStartFlag == DEF_TRUE) {
;;;133           *p_err = OS_ERR_ILLEGAL_CREATE_RUN_TIME;
;;;134            return;
;;;135        }
;;;136    #endif
;;;137    
;;;138    #if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
;;;139        if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* See if trying to call from an ISR                      */
;;;140           *p_err = OS_ERR_TMR_ISR;
;;;141            return;
;;;142        }
;;;143    #endif
;;;144    
;;;145    #if OS_CFG_ARG_CHK_EN > 0u
;;;146        if (p_tmr == (OS_TMR *)0) {                             /* Validate 'p_tmr'                                       */
000016  b924              CBNZ     r4,|L1.34|
;;;147           *p_err = OS_ERR_OBJ_PTR_NULL;
000018  f64550c3          MOV      r0,#0x5dc3
00001c  8028              STRH     r0,[r5,#0]
                  |L1.30|
;;;148            return;
;;;149        }
;;;150    
;;;151        switch (opt) {
;;;152            case OS_OPT_TMR_PERIODIC:
;;;153                 if (period == (OS_TICK)0) {
;;;154                    *p_err = OS_ERR_TMR_INVALID_PERIOD;
;;;155                     return;
;;;156                 }
;;;157                 break;
;;;158    
;;;159            case OS_OPT_TMR_ONE_SHOT:
;;;160                 if (dly == (OS_TICK)0) {
;;;161                    *p_err = OS_ERR_TMR_INVALID_DLY;
;;;162                     return;
;;;163                 }
;;;164                 break;
;;;165    
;;;166            default:
;;;167                *p_err = OS_ERR_OPT_INVALID;
;;;168                 return;
;;;169        }
;;;170    #endif
;;;171    
;;;172        OS_TmrLock();
;;;173    
;;;174        p_tmr->State          = (OS_STATE           )OS_TMR_STATE_STOPPED;     /* Initialize the timer fields             */
;;;175    #if OS_OBJ_TYPE_REQ > 0u
;;;176        p_tmr->Type           = (OS_OBJ_TYPE        )OS_OBJ_TYPE_TMR;
;;;177    #endif
;;;178    #if OS_CFG_DBG_EN > 0u
;;;179        p_tmr->NamePtr        = (CPU_CHAR          *)p_name;
;;;180    #else
;;;181        (void)&p_name;
;;;182    #endif
;;;183        p_tmr->Dly            = (OS_TICK            )dly;
;;;184        p_tmr->Remain         = (OS_TICK            )0;
;;;185        p_tmr->Period         = (OS_TICK            )period;
;;;186        p_tmr->Opt            = (OS_OPT             )opt;
;;;187        p_tmr->CallbackPtr    = (OS_TMR_CALLBACK_PTR)p_callback;
;;;188        p_tmr->CallbackPtrArg = (void              *)p_callback_arg;
;;;189        p_tmr->NextPtr        = (OS_TMR            *)0;
;;;190        p_tmr->PrevPtr        = (OS_TMR            *)0;
;;;191    
;;;192    #if OS_CFG_DBG_EN > 0u
;;;193        OS_TmrDbgListAdd(p_tmr);
;;;194    #endif
;;;195        OSTmrQty++;                                             /* Keep track of the number of timers created             */
;;;196    
;;;197        OS_TmrUnlock();
;;;198       *p_err = OS_ERR_NONE;
;;;199    }
00001e  e8bd9ff0          POP      {r4-r12,pc}
                  |L1.34|
000022  f1b90f01          CMP      r9,#1                 ;151
000026  d008              BEQ      |L1.58|
000028  f1b90f02          CMP      r9,#2                 ;151
00002c  d10b              BNE      |L1.70|
00002e  b91f              CBNZ     r7,|L1.56|
000030  f2473040          MOV      r0,#0x7340            ;154
000034  8028              STRH     r0,[r5,#0]            ;154
000036  e7f2              B        |L1.30|
                  |L1.56|
000038  e009              B        |L1.78|
                  |L1.58|
00003a  b91e              CBNZ     r6,|L1.68|
00003c  f247303f          MOV      r0,#0x733f            ;161
000040  8028              STRH     r0,[r5,#0]            ;161
000042  e7ec              B        |L1.30|
                  |L1.68|
000044  e003              B        |L1.78|
                  |L1.70|
000046  f6456025          MOV      r0,#0x5e25            ;167
00004a  8028              STRH     r0,[r5,#0]            ;167
00004c  e7e7              B        |L1.30|
                  |L1.78|
00004e  bf00              NOP                            ;157
000050  f7fffffe          BL       OS_TmrLock
000054  2001              MOVS     r0,#1                 ;174
000056  f8840026          STRB     r0,[r4,#0x26]         ;174
00005a  480f              LDR      r0,|L1.152|
00005c  6020              STR      r0,[r4,#0]            ;176
00005e  f8c48004          STR      r8,[r4,#4]            ;179
000062  61e6              STR      r6,[r4,#0x1c]         ;183
000064  2000              MOVS     r0,#0                 ;184
000066  61a0              STR      r0,[r4,#0x18]         ;184
000068  6227              STR      r7,[r4,#0x20]         ;185
00006a  f8a49024          STRH     r9,[r4,#0x24]         ;186
00006e  f8c4a008          STR      r10,[r4,#8]           ;187
000072  f8c4b00c          STR      r11,[r4,#0xc]         ;188
000076  6120              STR      r0,[r4,#0x10]         ;189
000078  6160              STR      r0,[r4,#0x14]         ;190
00007a  4620              MOV      r0,r4                 ;193
00007c  f7fffffe          BL       OS_TmrDbgListAdd
000080  4806              LDR      r0,|L1.156|
000082  8800              LDRH     r0,[r0,#0]            ;195  ; OSTmrQty
000084  1c40              ADDS     r0,r0,#1              ;195
000086  4905              LDR      r1,|L1.156|
000088  8008              STRH     r0,[r1,#0]            ;195
00008a  f7fffffe          BL       OS_TmrUnlock
00008e  2000              MOVS     r0,#0                 ;198
000090  8028              STRH     r0,[r5,#0]            ;198
000092  bf00              NOP      
000094  e7c3              B        |L1.30|
;;;200    
                          ENDP

000096  0000              DCW      0x0000
                  |L1.152|
                          DCD      0x20524d54
                  |L1.156|
                          DCD      OSTmrQty

                          AREA ||i.OSTmrDel||, CODE, READONLY, ALIGN=2

                  OSTmrDel PROC
;;;224    #if OS_CFG_TMR_DEL_EN > 0u
;;;225    CPU_BOOLEAN  OSTmrDel (OS_TMR  *p_tmr,
000000  b570              PUSH     {r4-r6,lr}
;;;226                           OS_ERR  *p_err)
;;;227    {
000002  4606              MOV      r6,r0
000004  460c              MOV      r4,r1
;;;228        CPU_BOOLEAN  success;
;;;229    
;;;230    
;;;231    
;;;232    #ifdef OS_SAFETY_CRITICAL
;;;233        if (p_err == (OS_ERR *)0) {
;;;234            OS_SAFETY_CRITICAL_EXCEPTION();
;;;235            return (DEF_FALSE);
;;;236        }
;;;237    #endif
;;;238    
;;;239    #if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
;;;240        if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* See if trying to call from an ISR                      */
;;;241           *p_err  = OS_ERR_TMR_ISR;
;;;242            return (DEF_FALSE);
;;;243        }
;;;244    #endif
;;;245    
;;;246    #if OS_CFG_ARG_CHK_EN > 0u
;;;247        if (p_tmr == (OS_TMR *)0) {
000006  b926              CBNZ     r6,|L2.18|
;;;248           *p_err = OS_ERR_TMR_INVALID;
000008  f2473042          MOV      r0,#0x7342
00000c  8020              STRH     r0,[r4,#0]
;;;249            return (DEF_FALSE);
00000e  2000              MOVS     r0,#0
                  |L2.16|
;;;250        }
;;;251    #endif
;;;252    
;;;253    #if OS_CFG_OBJ_TYPE_CHK_EN > 0u
;;;254        if (p_tmr->Type != OS_OBJ_TYPE_TMR) {                   /* Make sure timer was created                            */
;;;255           *p_err = OS_ERR_OBJ_TYPE;
;;;256            return (DEF_FALSE);
;;;257        }
;;;258    #endif
;;;259    
;;;260        OS_TmrLock();
;;;261    
;;;262    #if OS_CFG_DBG_EN > 0u
;;;263        OS_TmrDbgListRemove(p_tmr);
;;;264    #endif
;;;265    
;;;266        switch (p_tmr->State) {
;;;267            case OS_TMR_STATE_RUNNING:
;;;268                 OS_TmrUnlink(p_tmr);                           /* Remove from the list                                   */
;;;269                 OS_TmrClr(p_tmr);
;;;270                 OS_TmrUnlock();
;;;271                 OSTmrQty--;                                    /* One less timer                                         */
;;;272                *p_err   = OS_ERR_NONE;
;;;273                 success = DEF_TRUE;
;;;274                 break;
;;;275    
;;;276            case OS_TMR_STATE_STOPPED:                          /* Timer has not started or ...                           */
;;;277            case OS_TMR_STATE_COMPLETED:                        /* ... timer has completed the ONE-SHOT time              */
;;;278                 OS_TmrClr(p_tmr);                              /* Clear timer fields                                     */
;;;279                 OS_TmrUnlock();
;;;280                 OSTmrQty--;                                    /* One less timer                                         */
;;;281                *p_err   = OS_ERR_NONE;
;;;282                 success = DEF_TRUE;
;;;283                 break;
;;;284                 
;;;285            case OS_TMR_STATE_UNUSED:                           /* Already deleted                                        */
;;;286                 OS_TmrUnlock();
;;;287                *p_err   = OS_ERR_TMR_INACTIVE;
;;;288                 success = DEF_FALSE;
;;;289                 break;
;;;290    
;;;291            default:
;;;292                 OS_TmrUnlock();
;;;293                *p_err   = OS_ERR_TMR_INVALID_STATE;
;;;294                 success = DEF_FALSE;
;;;295                 break;
;;;296        }
;;;297        return (success);
;;;298    }
000010  bd70              POP      {r4-r6,pc}
                  |L2.18|
000012  4924              LDR      r1,|L2.164|
000014  6830              LDR      r0,[r6,#0]            ;254
000016  4288              CMP      r0,r1                 ;254
000018  d004              BEQ      |L2.36|
00001a  f64550c4          MOV      r0,#0x5dc4            ;255
00001e  8020              STRH     r0,[r4,#0]            ;255
000020  2000              MOVS     r0,#0                 ;256
000022  e7f5              B        |L2.16|
                  |L2.36|
000024  f7fffffe          BL       OS_TmrLock
000028  4630              MOV      r0,r6                 ;263
00002a  f7fffffe          BL       OS_TmrDbgListRemove
00002e  f8960026          LDRB     r0,[r6,#0x26]         ;266
000032  b330              CBZ      r0,|L2.130|
000034  2801              CMP      r0,#1                 ;266
000036  d015              BEQ      |L2.100|
000038  2802              CMP      r0,#2                 ;266
00003a  d002              BEQ      |L2.66|
00003c  2803              CMP      r0,#3                 ;266
00003e  d127              BNE      |L2.144|
000040  e011              B        |L2.102|
                  |L2.66|
000042  4630              MOV      r0,r6                 ;268
000044  f7fffffe          BL       OS_TmrUnlink
000048  4630              MOV      r0,r6                 ;269
00004a  f7fffffe          BL       OS_TmrClr
00004e  f7fffffe          BL       OS_TmrUnlock
000052  4815              LDR      r0,|L2.168|
000054  8800              LDRH     r0,[r0,#0]            ;271  ; OSTmrQty
000056  1e40              SUBS     r0,r0,#1              ;271
000058  4913              LDR      r1,|L2.168|
00005a  8008              STRH     r0,[r1,#0]            ;271
00005c  2000              MOVS     r0,#0                 ;272
00005e  8020              STRH     r0,[r4,#0]            ;272
000060  2501              MOVS     r5,#1                 ;273
000062  e01c              B        |L2.158|
                  |L2.100|
000064  bf00              NOP                            ;277
                  |L2.102|
000066  4630              MOV      r0,r6                 ;278
000068  f7fffffe          BL       OS_TmrClr
00006c  f7fffffe          BL       OS_TmrUnlock
000070  480d              LDR      r0,|L2.168|
000072  8800              LDRH     r0,[r0,#0]            ;280  ; OSTmrQty
000074  1e40              SUBS     r0,r0,#1              ;280
000076  490c              LDR      r1,|L2.168|
000078  8008              STRH     r0,[r1,#0]            ;280
00007a  2000              MOVS     r0,#0                 ;281
00007c  8020              STRH     r0,[r4,#0]            ;281
00007e  2501              MOVS     r5,#1                 ;282
000080  e00d              B        |L2.158|
                  |L2.130|
000082  f7fffffe          BL       OS_TmrUnlock
000086  f247303d          MOV      r0,#0x733d            ;287
00008a  8020              STRH     r0,[r4,#0]            ;287
00008c  2500              MOVS     r5,#0                 ;288
00008e  e006              B        |L2.158|
                  |L2.144|
000090  f7fffffe          BL       OS_TmrUnlock
000094  f2473041          MOV      r0,#0x7341            ;293
000098  8020              STRH     r0,[r4,#0]            ;293
00009a  2500              MOVS     r5,#0                 ;294
00009c  bf00              NOP                            ;295
                  |L2.158|
00009e  bf00              NOP                            ;274
0000a0  4628              MOV      r0,r5                 ;297
0000a2  e7b5              B        |L2.16|
;;;299    #endif
                          ENDP

                  |L2.164|
                          DCD      0x20524d54
                  |L2.168|
                          DCD      OSTmrQty

                          AREA ||i.OSTmrRemainGet||, CODE, READONLY, ALIGN=2

                  OSTmrRemainGet PROC
;;;324    
;;;325    OS_TICK  OSTmrRemainGet (OS_TMR  *p_tmr,
000000  b5f8              PUSH     {r3-r7,lr}
;;;326                             OS_ERR  *p_err)
;;;327    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;328        OS_TICK  remain;
;;;329        OS_ERR   err;
;;;330    
;;;331    
;;;332    
;;;333    #ifdef OS_SAFETY_CRITICAL
;;;334        if (p_err == (OS_ERR *)0) {
;;;335            OS_SAFETY_CRITICAL_EXCEPTION();
;;;336            return ((OS_TICK)0);
;;;337        }
;;;338    #endif
;;;339    
;;;340    #if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
;;;341        if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* See if trying to call from an ISR                      */
;;;342           *p_err = OS_ERR_TMR_ISR;
;;;343            return ((OS_TICK)0);
;;;344        }
;;;345    #endif
;;;346    
;;;347    #if OS_CFG_ARG_CHK_EN > 0u
;;;348        if (p_tmr == (OS_TMR *)0) {
000006  b924              CBNZ     r4,|L3.18|
;;;349           *p_err = OS_ERR_TMR_INVALID;
000008  f2473042          MOV      r0,#0x7342
00000c  8028              STRH     r0,[r5,#0]
;;;350            return ((OS_TICK)0);
00000e  2000              MOVS     r0,#0
                  |L3.16|
;;;351        }
;;;352    #endif
;;;353    
;;;354    #if OS_CFG_OBJ_TYPE_CHK_EN > 0u
;;;355        if (p_tmr->Type != OS_OBJ_TYPE_TMR) {                   /* Make sure timer was created                            */
;;;356           *p_err = OS_ERR_OBJ_TYPE;
;;;357            return ((OS_TICK)0);
;;;358        }
;;;359    #endif
;;;360    
;;;361        OSSchedLock(&err);
;;;362        (void)&err;
;;;363    
;;;364        switch (p_tmr->State) {
;;;365            case OS_TMR_STATE_RUNNING:
;;;366                 remain = p_tmr->Remain;
;;;367                *p_err  = OS_ERR_NONE;
;;;368                 break;
;;;369    
;;;370            case OS_TMR_STATE_STOPPED:                          /* It's assumed that the timer has not started yet        */
;;;371                 if (p_tmr->Opt == OS_OPT_TMR_PERIODIC) {
;;;372                     if (p_tmr->Dly == 0u) {
;;;373                         remain = p_tmr->Period;
;;;374                     } else {
;;;375                         remain = p_tmr->Dly;
;;;376                     }
;;;377                 } else {
;;;378                     remain = p_tmr->Dly;
;;;379                 }
;;;380                *p_err = OS_ERR_NONE;
;;;381                 break;
;;;382    
;;;383            case OS_TMR_STATE_COMPLETED:                        /* Only ONE-SHOT that timed out can be in this state      */
;;;384                *p_err  = OS_ERR_NONE;
;;;385                 remain = (OS_TICK)0;
;;;386                 break;
;;;387    
;;;388            case OS_TMR_STATE_UNUSED:
;;;389                *p_err  = OS_ERR_TMR_INACTIVE;
;;;390                 remain = (OS_TICK)0;
;;;391                 break;
;;;392    
;;;393            default:
;;;394                *p_err = OS_ERR_TMR_INVALID_STATE;
;;;395                 remain = (OS_TICK)0;
;;;396                 break;
;;;397        }
;;;398    
;;;399        OSSchedUnlock(&err);
;;;400        (void)&err;
;;;401    
;;;402        return (remain);
;;;403    }
000010  bdf8              POP      {r3-r7,pc}
                  |L3.18|
000012  491d              LDR      r1,|L3.136|
000014  6820              LDR      r0,[r4,#0]            ;355
000016  4288              CMP      r0,r1                 ;355
000018  d004              BEQ      |L3.36|
00001a  f64550c4          MOV      r0,#0x5dc4            ;356
00001e  8028              STRH     r0,[r5,#0]            ;356
000020  2000              MOVS     r0,#0                 ;357
000022  e7f5              B        |L3.16|
                  |L3.36|
000024  4668              MOV      r0,sp                 ;361
000026  f7fffffe          BL       OSSchedLock
00002a  f8940026          LDRB     r0,[r4,#0x26]         ;364
00002e  b1d8              CBZ      r0,|L3.104|
000030  2801              CMP      r0,#1                 ;364
000032  d008              BEQ      |L3.70|
000034  2802              CMP      r0,#2                 ;364
000036  d002              BEQ      |L3.62|
000038  2803              CMP      r0,#3                 ;364
00003a  d11a              BNE      |L3.114|
00003c  e010              B        |L3.96|
                  |L3.62|
00003e  69a6              LDR      r6,[r4,#0x18]         ;366
000040  2000              MOVS     r0,#0                 ;367
000042  8028              STRH     r0,[r5,#0]            ;367
000044  e01a              B        |L3.124|
                  |L3.70|
000046  8ca0              LDRH     r0,[r4,#0x24]         ;371
000048  2802              CMP      r0,#2                 ;371
00004a  d105              BNE      |L3.88|
00004c  69e0              LDR      r0,[r4,#0x1c]         ;372
00004e  b908              CBNZ     r0,|L3.84|
000050  6a26              LDR      r6,[r4,#0x20]         ;373
000052  e002              B        |L3.90|
                  |L3.84|
000054  69e6              LDR      r6,[r4,#0x1c]         ;375
000056  e000              B        |L3.90|
                  |L3.88|
000058  69e6              LDR      r6,[r4,#0x1c]         ;378
                  |L3.90|
00005a  2000              MOVS     r0,#0                 ;380
00005c  8028              STRH     r0,[r5,#0]            ;380
00005e  e00d              B        |L3.124|
                  |L3.96|
000060  2000              MOVS     r0,#0                 ;384
000062  8028              STRH     r0,[r5,#0]            ;384
000064  2600              MOVS     r6,#0                 ;385
000066  e009              B        |L3.124|
                  |L3.104|
000068  f247303d          MOV      r0,#0x733d            ;389
00006c  8028              STRH     r0,[r5,#0]            ;389
00006e  2600              MOVS     r6,#0                 ;390
000070  e004              B        |L3.124|
                  |L3.114|
000072  f2473041          MOV      r0,#0x7341            ;394
000076  8028              STRH     r0,[r5,#0]            ;394
000078  2600              MOVS     r6,#0                 ;395
00007a  bf00              NOP                            ;396
                  |L3.124|
00007c  bf00              NOP                            ;368
00007e  4668              MOV      r0,sp                 ;399
000080  f7fffffe          BL       OSSchedUnlock
000084  4630              MOV      r0,r6                 ;402
000086  e7c3              B        |L3.16|
;;;404    
                          ENDP

                  |L3.136|
                          DCD      0x20524d54

                          AREA ||i.OSTmrStart||, CODE, READONLY, ALIGN=2

                  OSTmrStart PROC
;;;432    
;;;433    CPU_BOOLEAN  OSTmrStart (OS_TMR  *p_tmr,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;434                             OS_ERR  *p_err)
;;;435    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;436        OS_TMR      *p_next;
;;;437        CPU_BOOLEAN  success;
;;;438        CPU_SR_ALLOC();
000008  f04f0800          MOV      r8,#0
;;;439    
;;;440    
;;;441    
;;;442    #ifdef OS_SAFETY_CRITICAL
;;;443        if (p_err == (OS_ERR *)0) {
;;;444            OS_SAFETY_CRITICAL_EXCEPTION();
;;;445            return (DEF_FALSE);
;;;446        }
;;;447    #endif
;;;448    
;;;449    #if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
;;;450        if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* See if trying to call from an ISR                      */
;;;451           *p_err = OS_ERR_TMR_ISR;
;;;452            return (DEF_FALSE);
;;;453        }
;;;454    #endif
;;;455    
;;;456    #if OS_CFG_ARG_CHK_EN > 0u
;;;457        if (p_tmr == (OS_TMR *)0) {
00000c  b92c              CBNZ     r4,|L4.26|
;;;458           *p_err = OS_ERR_TMR_INVALID;
00000e  f2473042          MOV      r0,#0x7342
000012  8028              STRH     r0,[r5,#0]
;;;459            return (DEF_FALSE);
000014  2000              MOVS     r0,#0
                  |L4.22|
;;;460        }
;;;461    #endif
;;;462    
;;;463    #if OS_CFG_OBJ_TYPE_CHK_EN > 0u
;;;464        if (p_tmr->Type != OS_OBJ_TYPE_TMR) {                   /* Make sure timer was created                            */
;;;465           *p_err = OS_ERR_OBJ_TYPE;
;;;466            return (DEF_FALSE);
;;;467        }
;;;468    #endif
;;;469    
;;;470        switch (p_tmr->State) {
;;;471            case OS_TMR_STATE_RUNNING:                          /* Restart the timer                                      */
;;;472                 CPU_CRITICAL_ENTER();
;;;473                 p_tmr->Remain = p_tmr->Dly;
;;;474                 CPU_CRITICAL_EXIT();
;;;475                *p_err         = OS_ERR_NONE;
;;;476                 success       = DEF_TRUE;
;;;477                 break;
;;;478    
;;;479            case OS_TMR_STATE_STOPPED:                          /* Start the timer                                        */
;;;480            case OS_TMR_STATE_COMPLETED:
;;;481                 OS_TmrLock();
;;;482                 p_tmr->State  = OS_TMR_STATE_RUNNING;
;;;483    			 if (p_tmr->Dly == (OS_TICK)0) {
;;;484                     p_tmr->Remain = p_tmr->Period;
;;;485    			 } else {
;;;486                     p_tmr->Remain = p_tmr->Dly;
;;;487                 }
;;;488                 if (OSTmrListPtr ==  (OS_TMR *)0) {            /* Link into timer list                                   */
;;;489                     p_tmr->NextPtr   = (OS_TMR *)0;            /* This is the first timer in the list                    */
;;;490                     p_tmr->PrevPtr   = (OS_TMR *)0;
;;;491                     OSTmrListPtr     = p_tmr;
;;;492                     OSTmrListEntries = 1u;
;;;493                 } else {
;;;494                     p_next           = OSTmrListPtr;           /* Insert at the beginning of the list                    */
;;;495                     p_tmr->NextPtr   = OSTmrListPtr;
;;;496                     p_tmr->PrevPtr   = (OS_TMR *)0;
;;;497                     p_next->PrevPtr  = p_tmr;
;;;498                     OSTmrListPtr     = p_tmr;
;;;499                     OSTmrListEntries++;
;;;500                 }
;;;501                 OS_TmrUnlock();
;;;502                *p_err   = OS_ERR_NONE;
;;;503                 success = DEF_TRUE;
;;;504                 break;
;;;505    
;;;506            case OS_TMR_STATE_UNUSED:                           /* Timer not created                                      */
;;;507                *p_err   = OS_ERR_TMR_INACTIVE;
;;;508                 success = DEF_FALSE;
;;;509                 break;
;;;510    
;;;511            default:
;;;512                *p_err = OS_ERR_TMR_INVALID_STATE;
;;;513                 success = DEF_FALSE;
;;;514                 break;
;;;515        }
;;;516        return (success);
;;;517    }
000016  e8bd81f0          POP      {r4-r8,pc}
                  |L4.26|
00001a  4931              LDR      r1,|L4.224|
00001c  6820              LDR      r0,[r4,#0]            ;464
00001e  4288              CMP      r0,r1                 ;464
000020  d004              BEQ      |L4.44|
000022  f64550c4          MOV      r0,#0x5dc4            ;465
000026  8028              STRH     r0,[r5,#0]            ;465
000028  2000              MOVS     r0,#0                 ;466
00002a  e7f4              B        |L4.22|
                  |L4.44|
00002c  f8940026          LDRB     r0,[r4,#0x26]         ;470
000030  2800              CMP      r0,#0                 ;470
000032  d047              BEQ      |L4.196|
000034  2801              CMP      r0,#1                 ;470
000036  d018              BEQ      |L4.106|
000038  2802              CMP      r0,#2                 ;470
00003a  d002              BEQ      |L4.66|
00003c  2803              CMP      r0,#3                 ;470
00003e  d146              BNE      |L4.206|
000040  e014              B        |L4.108|
                  |L4.66|
000042  bf00              NOP                            ;472
000044  bf00              NOP                            ;472
000046  f7fffffe          BL       CPU_SR_Save
00004a  4680              MOV      r8,r0                 ;472
00004c  bf00              NOP                            ;472
00004e  bf00              NOP                            ;472
000050  69e0              LDR      r0,[r4,#0x1c]         ;473
000052  61a0              STR      r0,[r4,#0x18]         ;473
000054  bf00              NOP                            ;474
000056  bf00              NOP                            ;474
000058  4640              MOV      r0,r8                 ;474
00005a  f7fffffe          BL       CPU_SR_Restore
00005e  bf00              NOP                            ;474
000060  bf00              NOP                            ;474
000062  2000              MOVS     r0,#0                 ;475
000064  8028              STRH     r0,[r5,#0]            ;475
000066  2601              MOVS     r6,#1                 ;476
000068  e036              B        |L4.216|
                  |L4.106|
00006a  bf00              NOP                            ;480
                  |L4.108|
00006c  f7fffffe          BL       OS_TmrLock
000070  2002              MOVS     r0,#2                 ;482
000072  f8840026          STRB     r0,[r4,#0x26]         ;482
000076  69e0              LDR      r0,[r4,#0x1c]         ;483
000078  b910              CBNZ     r0,|L4.128|
00007a  6a20              LDR      r0,[r4,#0x20]         ;484
00007c  61a0              STR      r0,[r4,#0x18]         ;484
00007e  e001              B        |L4.132|
                  |L4.128|
000080  69e0              LDR      r0,[r4,#0x1c]         ;486
000082  61a0              STR      r0,[r4,#0x18]         ;486
                  |L4.132|
000084  4817              LDR      r0,|L4.228|
000086  6800              LDR      r0,[r0,#0]            ;488  ; OSTmrListPtr
000088  b940              CBNZ     r0,|L4.156|
00008a  2000              MOVS     r0,#0                 ;489
00008c  6120              STR      r0,[r4,#0x10]         ;489
00008e  6160              STR      r0,[r4,#0x14]         ;490
000090  4814              LDR      r0,|L4.228|
000092  6004              STR      r4,[r0,#0]            ;491  ; OSTmrListPtr
000094  2001              MOVS     r0,#1                 ;492
000096  4914              LDR      r1,|L4.232|
000098  8008              STRH     r0,[r1,#0]            ;492
00009a  e00d              B        |L4.184|
                  |L4.156|
00009c  4811              LDR      r0,|L4.228|
00009e  6807              LDR      r7,[r0,#0]            ;494  ; OSTmrListPtr
0000a0  6800              LDR      r0,[r0,#0]            ;495  ; OSTmrListPtr
0000a2  6120              STR      r0,[r4,#0x10]         ;495
0000a4  2000              MOVS     r0,#0                 ;496
0000a6  6160              STR      r0,[r4,#0x14]         ;496
0000a8  617c              STR      r4,[r7,#0x14]         ;497
0000aa  480e              LDR      r0,|L4.228|
0000ac  6004              STR      r4,[r0,#0]            ;498  ; OSTmrListPtr
0000ae  480e              LDR      r0,|L4.232|
0000b0  8800              LDRH     r0,[r0,#0]            ;499  ; OSTmrListEntries
0000b2  1c40              ADDS     r0,r0,#1              ;499
0000b4  490c              LDR      r1,|L4.232|
0000b6  8008              STRH     r0,[r1,#0]            ;499
                  |L4.184|
0000b8  f7fffffe          BL       OS_TmrUnlock
0000bc  2000              MOVS     r0,#0                 ;502
0000be  8028              STRH     r0,[r5,#0]            ;502
0000c0  2601              MOVS     r6,#1                 ;503
0000c2  e009              B        |L4.216|
                  |L4.196|
0000c4  f247303d          MOV      r0,#0x733d            ;507
0000c8  8028              STRH     r0,[r5,#0]            ;507
0000ca  2600              MOVS     r6,#0                 ;508
0000cc  e004              B        |L4.216|
                  |L4.206|
0000ce  f2473041          MOV      r0,#0x7341            ;512
0000d2  8028              STRH     r0,[r5,#0]            ;512
0000d4  2600              MOVS     r6,#0                 ;513
0000d6  bf00              NOP                            ;514
                  |L4.216|
0000d8  bf00              NOP                            ;477
0000da  4630              MOV      r0,r6                 ;516
0000dc  e79b              B        |L4.22|
;;;518    
                          ENDP

0000de  0000              DCW      0x0000
                  |L4.224|
                          DCD      0x20524d54
                  |L4.228|
                          DCD      OSTmrListPtr
                  |L4.232|
                          DCD      OSTmrListEntries

                          AREA ||i.OSTmrStateGet||, CODE, READONLY, ALIGN=2

                  OSTmrStateGet PROC
;;;544    
;;;545    OS_STATE  OSTmrStateGet (OS_TMR  *p_tmr,
000000  b510              PUSH     {r4,lr}
;;;546                             OS_ERR  *p_err)
;;;547    {
000002  4602              MOV      r2,r0
;;;548        OS_STATE  state;
;;;549    
;;;550    
;;;551    
;;;552    #ifdef OS_SAFETY_CRITICAL
;;;553        if (p_err == (OS_ERR *)0) {
;;;554            OS_SAFETY_CRITICAL_EXCEPTION();
;;;555            return (OS_TMR_STATE_UNUSED);
;;;556        }
;;;557    #endif
;;;558    
;;;559    #if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
;;;560        if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* See if trying to call from an ISR                      */
;;;561           *p_err = OS_ERR_TMR_ISR;
;;;562            return (OS_TMR_STATE_UNUSED);
;;;563        }
;;;564    #endif
;;;565    
;;;566    #if OS_CFG_ARG_CHK_EN > 0u
;;;567        if (p_tmr == (OS_TMR *)0) {
000004  b922              CBNZ     r2,|L5.16|
;;;568           *p_err = OS_ERR_TMR_INVALID;
000006  f2473042          MOV      r0,#0x7342
00000a  8008              STRH     r0,[r1,#0]
;;;569            return (OS_TMR_STATE_UNUSED);
00000c  2000              MOVS     r0,#0
                  |L5.14|
;;;570        }
;;;571    #endif
;;;572    
;;;573    #if OS_CFG_OBJ_TYPE_CHK_EN > 0u
;;;574        if (p_tmr->Type != OS_OBJ_TYPE_TMR) {                   /* Make sure timer was created                            */
;;;575           *p_err = OS_ERR_OBJ_TYPE;
;;;576            return (OS_TMR_STATE_UNUSED);
;;;577        }
;;;578    #endif
;;;579    
;;;580        state = p_tmr->State;
;;;581        switch (state) {
;;;582            case OS_TMR_STATE_UNUSED:
;;;583            case OS_TMR_STATE_STOPPED:
;;;584            case OS_TMR_STATE_COMPLETED:
;;;585            case OS_TMR_STATE_RUNNING:
;;;586                *p_err = OS_ERR_NONE;
;;;587                 break;
;;;588    
;;;589            default:
;;;590                *p_err = OS_ERR_TMR_INVALID_STATE;
;;;591                 break;
;;;592        }
;;;593        return (state);
;;;594    }
00000e  bd10              POP      {r4,pc}
                  |L5.16|
000010  4c0f              LDR      r4,|L5.80|
000012  6810              LDR      r0,[r2,#0]            ;574
000014  42a0              CMP      r0,r4                 ;574
000016  d004              BEQ      |L5.34|
000018  f64550c4          MOV      r0,#0x5dc4            ;575
00001c  8008              STRH     r0,[r1,#0]            ;575
00001e  2000              MOVS     r0,#0                 ;576
000020  e7f5              B        |L5.14|
                  |L5.34|
000022  f8923026          LDRB     r3,[r2,#0x26]         ;580
000026  b133              CBZ      r3,|L5.54|
000028  2b01              CMP      r3,#1                 ;581
00002a  d005              BEQ      |L5.56|
00002c  2b02              CMP      r3,#2                 ;581
00002e  d005              BEQ      |L5.60|
000030  2b03              CMP      r3,#3                 ;581
000032  d106              BNE      |L5.66|
000034  e001              B        |L5.58|
                  |L5.54|
000036  bf00              NOP                            ;583
                  |L5.56|
000038  bf00              NOP                            ;584
                  |L5.58|
00003a  bf00              NOP                            ;585
                  |L5.60|
00003c  2000              MOVS     r0,#0                 ;586
00003e  8008              STRH     r0,[r1,#0]            ;586
000040  e003              B        |L5.74|
                  |L5.66|
000042  f2473041          MOV      r0,#0x7341            ;590
000046  8008              STRH     r0,[r1,#0]            ;590
000048  bf00              NOP                            ;591
                  |L5.74|
00004a  bf00              NOP                            ;587
00004c  4618              MOV      r0,r3                 ;593
00004e  e7de              B        |L5.14|
;;;595    
                          ENDP

                  |L5.80|
                          DCD      0x20524d54

                          AREA ||i.OSTmrStop||, CODE, READONLY, ALIGN=2

                  OSTmrStop PROC
;;;632    
;;;633    CPU_BOOLEAN  OSTmrStop (OS_TMR  *p_tmr,
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;634                            OS_OPT   opt,
;;;635                            void    *p_callback_arg,
;;;636                            OS_ERR  *p_err)
;;;637    {
000004  4605              MOV      r5,r0
000006  4688              MOV      r8,r1
000008  4691              MOV      r9,r2
00000a  461c              MOV      r4,r3
;;;638        OS_TMR_CALLBACK_PTR  p_fnct;
;;;639        CPU_BOOLEAN          success;
;;;640    
;;;641    
;;;642    
;;;643    #ifdef OS_SAFETY_CRITICAL
;;;644        if (p_err == (OS_ERR *)0) {
;;;645            OS_SAFETY_CRITICAL_EXCEPTION();
;;;646            return (DEF_FALSE);
;;;647        }
;;;648    #endif
;;;649    
;;;650    #if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
;;;651        if (OSIntNestingCtr > (OS_NESTING_CTR)0) {                        /* See if trying to call from an ISR            */
;;;652           *p_err = OS_ERR_TMR_ISR;
;;;653            return (DEF_FALSE);
;;;654        }
;;;655    #endif
;;;656    
;;;657    #if OS_CFG_ARG_CHK_EN > 0u
;;;658        if (p_tmr == (OS_TMR *)0) {
00000c  b92d              CBNZ     r5,|L6.26|
;;;659           *p_err = OS_ERR_TMR_INVALID;
00000e  f2473042          MOV      r0,#0x7342
000012  8020              STRH     r0,[r4,#0]
;;;660            return (DEF_FALSE);
000014  2000              MOVS     r0,#0
                  |L6.22|
;;;661        }
;;;662    #endif
;;;663    
;;;664    #if OS_CFG_OBJ_TYPE_CHK_EN > 0u
;;;665        if (p_tmr->Type != OS_OBJ_TYPE_TMR) {                             /* Make sure timer was created                  */
;;;666           *p_err = OS_ERR_OBJ_TYPE;
;;;667            return (DEF_FALSE);
;;;668        }
;;;669    #endif
;;;670    
;;;671        switch (p_tmr->State) {
;;;672            case OS_TMR_STATE_RUNNING:
;;;673                 OS_TmrLock();
;;;674                 OS_TmrUnlink(p_tmr);                                     /* Remove from timer list                       */
;;;675                *p_err = OS_ERR_NONE;
;;;676                 switch (opt) {
;;;677                     case OS_OPT_TMR_CALLBACK:
;;;678                          p_fnct = p_tmr->CallbackPtr;                         /* Execute callback function ...           */
;;;679                          if (p_fnct != (OS_TMR_CALLBACK_PTR)0) {              /* ... if available                        */
;;;680                            (*p_fnct)((void *)p_tmr, p_tmr->CallbackPtrArg);   /* Use callback arg when timer was created */
;;;681                          } else {
;;;682                             *p_err = OS_ERR_TMR_NO_CALLBACK;
;;;683                          }
;;;684                          break;
;;;685    
;;;686                     case OS_OPT_TMR_CALLBACK_ARG:
;;;687                          p_fnct = p_tmr->CallbackPtr;                    /* Execute callback function if available ...   */
;;;688                          if (p_fnct != (OS_TMR_CALLBACK_PTR)0) {
;;;689                            (*p_fnct)((void *)p_tmr, p_callback_arg);     /* .. using the 'callback_arg' provided in call */
;;;690                          } else {
;;;691                             *p_err = OS_ERR_TMR_NO_CALLBACK;
;;;692                          }
;;;693                          break;
;;;694    
;;;695                     case OS_OPT_TMR_NONE:
;;;696                          break;
;;;697    
;;;698                     default:
;;;699                         OS_TmrUnlock();
;;;700                        *p_err = OS_ERR_OPT_INVALID;
;;;701                         return (DEF_FALSE);
;;;702                 }
;;;703                 OS_TmrUnlock();
;;;704                 success = DEF_TRUE;
;;;705                 break;
;;;706    
;;;707            case OS_TMR_STATE_COMPLETED:                                  /* Timer has already completed the ONE-SHOT or  */
;;;708            case OS_TMR_STATE_STOPPED:                                    /* ... timer has not started yet.               */
;;;709                *p_err   = OS_ERR_TMR_STOPPED;
;;;710                 success = DEF_TRUE;
;;;711                 break;
;;;712    
;;;713            case OS_TMR_STATE_UNUSED:                                     /* Timer was not created                        */
;;;714                *p_err   = OS_ERR_TMR_INACTIVE;
;;;715                 success = DEF_FALSE;
;;;716                 break;
;;;717    
;;;718            default:
;;;719                *p_err   = OS_ERR_TMR_INVALID_STATE;
;;;720                 success = DEF_FALSE;
;;;721                 break;
;;;722        }
;;;723        return (success);
;;;724    }
000016  e8bd87f0          POP      {r4-r10,pc}
                  |L6.26|
00001a  492c              LDR      r1,|L6.204|
00001c  6828              LDR      r0,[r5,#0]            ;665
00001e  4288              CMP      r0,r1                 ;665
000020  d004              BEQ      |L6.44|
000022  f64550c4          MOV      r0,#0x5dc4            ;666
000026  8020              STRH     r0,[r4,#0]            ;666
000028  2000              MOVS     r0,#0                 ;667
00002a  e7f4              B        |L6.22|
                  |L6.44|
00002c  f8950026          LDRB     r0,[r5,#0x26]         ;671
000030  2800              CMP      r0,#0                 ;671
000032  d03e              BEQ      |L6.178|
000034  2801              CMP      r0,#1                 ;671
000036  d037              BEQ      |L6.168|
000038  2802              CMP      r0,#2                 ;671
00003a  d002              BEQ      |L6.66|
00003c  2803              CMP      r0,#3                 ;671
00003e  d13d              BNE      |L6.188|
000040  e031              B        |L6.166|
                  |L6.66|
000042  f7fffffe          BL       OS_TmrLock
000046  4628              MOV      r0,r5                 ;674
000048  f7fffffe          BL       OS_TmrUnlink
00004c  2000              MOVS     r0,#0                 ;675
00004e  8020              STRH     r0,[r4,#0]            ;675
000050  f1b80f00          CMP      r8,#0                 ;676
000054  d01a              BEQ      |L6.140|
000056  f1b80f03          CMP      r8,#3                 ;676
00005a  d003              BEQ      |L6.100|
00005c  f1b80f04          CMP      r8,#4                 ;676
000060  d115              BNE      |L6.142|
000062  e009              B        |L6.120|
                  |L6.100|
000064  68ae              LDR      r6,[r5,#8]            ;678
000066  b11e              CBZ      r6,|L6.112|
000068  4628              MOV      r0,r5                 ;680
00006a  68e9              LDR      r1,[r5,#0xc]          ;680
00006c  47b0              BLX      r6                    ;680
00006e  e002              B        |L6.118|
                  |L6.112|
000070  f2473044          MOV      r0,#0x7344            ;682
000074  8020              STRH     r0,[r4,#0]            ;682
                  |L6.118|
000076  e011              B        |L6.156|
                  |L6.120|
000078  68ae              LDR      r6,[r5,#8]            ;687
00007a  b11e              CBZ      r6,|L6.132|
00007c  4649              MOV      r1,r9                 ;689
00007e  4628              MOV      r0,r5                 ;689
000080  47b0              BLX      r6                    ;689
000082  e002              B        |L6.138|
                  |L6.132|
000084  f2473044          MOV      r0,#0x7344            ;691
000088  8020              STRH     r0,[r4,#0]            ;691
                  |L6.138|
00008a  e007              B        |L6.156|
                  |L6.140|
00008c  e006              B        |L6.156|
                  |L6.142|
00008e  f7fffffe          BL       OS_TmrUnlock
000092  f6456025          MOV      r0,#0x5e25            ;700
000096  8020              STRH     r0,[r4,#0]            ;700
000098  2000              MOVS     r0,#0                 ;701
00009a  e7bc              B        |L6.22|
                  |L6.156|
00009c  bf00              NOP                            ;684
00009e  f7fffffe          BL       OS_TmrUnlock
0000a2  2701              MOVS     r7,#1                 ;704
0000a4  e00f              B        |L6.198|
                  |L6.166|
0000a6  bf00              NOP                            ;708
                  |L6.168|
0000a8  f2473049          MOV      r0,#0x7349            ;709
0000ac  8020              STRH     r0,[r4,#0]            ;709
0000ae  2701              MOVS     r7,#1                 ;710
0000b0  e009              B        |L6.198|
                  |L6.178|
0000b2  f247303d          MOV      r0,#0x733d            ;714
0000b6  8020              STRH     r0,[r4,#0]            ;714
0000b8  2700              MOVS     r7,#0                 ;715
0000ba  e004              B        |L6.198|
                  |L6.188|
0000bc  f2473041          MOV      r0,#0x7341            ;719
0000c0  8020              STRH     r0,[r4,#0]            ;719
0000c2  2700              MOVS     r7,#0                 ;720
0000c4  bf00              NOP                            ;721
                  |L6.198|
0000c6  bf00              NOP                            ;705
0000c8  4638              MOV      r0,r7                 ;723
0000ca  e7a4              B        |L6.22|
;;;725    
                          ENDP

                  |L6.204|
                          DCD      0x20524d54

                          AREA ||i.OS_TmrClr||, CODE, READONLY, ALIGN=2

                  OS_TmrClr PROC
;;;741    
;;;742    void  OS_TmrClr (OS_TMR  *p_tmr)
000000  2100              MOVS     r1,#0
;;;743    {
;;;744        p_tmr->State          = OS_TMR_STATE_UNUSED;            /* Clear timer fields                                     */
000002  f8801026          STRB     r1,[r0,#0x26]
;;;745    #if OS_OBJ_TYPE_REQ > 0u
;;;746        p_tmr->Type           = OS_OBJ_TYPE_NONE;
000006  4907              LDR      r1,|L7.36|
000008  6001              STR      r1,[r0,#0]
;;;747    #endif
;;;748    #if OS_CFG_DBG_EN > 0u
;;;749        p_tmr->NamePtr        = (CPU_CHAR          *)((void *)"?TMR");
00000a  a107              ADR      r1,|L7.40|
00000c  6041              STR      r1,[r0,#4]
;;;750    #endif
;;;751        p_tmr->Dly            = (OS_TICK            )0;
00000e  2100              MOVS     r1,#0
000010  61c1              STR      r1,[r0,#0x1c]
;;;752        p_tmr->Remain         = (OS_TICK            )0;
000012  6181              STR      r1,[r0,#0x18]
;;;753        p_tmr->Period         = (OS_TICK            )0;
000014  6201              STR      r1,[r0,#0x20]
;;;754        p_tmr->Opt            = (OS_OPT             )0;
000016  8481              STRH     r1,[r0,#0x24]
;;;755        p_tmr->CallbackPtr    = (OS_TMR_CALLBACK_PTR)0;
000018  6081              STR      r1,[r0,#8]
;;;756        p_tmr->CallbackPtrArg = (void              *)0;
00001a  60c1              STR      r1,[r0,#0xc]
;;;757        p_tmr->NextPtr        = (OS_TMR            *)0;
00001c  6101              STR      r1,[r0,#0x10]
;;;758        p_tmr->PrevPtr        = (OS_TMR            *)0;
00001e  6141              STR      r1,[r0,#0x14]
;;;759    }
000020  4770              BX       lr
;;;760    
                          ENDP

000022  0000              DCW      0x0000
                  |L7.36|
                          DCD      0x454e4f4e
                  |L7.40|
000028  3f544d52          DCB      "?TMR",0
00002c  00      
00002d  00                DCB      0
00002e  00                DCB      0
00002f  00                DCB      0

                          AREA ||i.OS_TmrDbgListAdd||, CODE, READONLY, ALIGN=2

                  OS_TmrDbgListAdd PROC
;;;777    #if OS_CFG_DBG_EN > 0u
;;;778    void  OS_TmrDbgListAdd (OS_TMR  *p_tmr)
000000  2100              MOVS     r1,#0
;;;779    {
;;;780        p_tmr->DbgPrevPtr               = (OS_TMR *)0;
000002  6281              STR      r1,[r0,#0x28]
;;;781        if (OSTmrDbgListPtr == (OS_TMR *)0) {
000004  4907              LDR      r1,|L8.36|
000006  6809              LDR      r1,[r1,#0]  ; OSTmrDbgListPtr
000008  b911              CBNZ     r1,|L8.16|
;;;782            p_tmr->DbgNextPtr           = (OS_TMR *)0;
00000a  2100              MOVS     r1,#0
00000c  62c1              STR      r1,[r0,#0x2c]
00000e  e005              B        |L8.28|
                  |L8.16|
;;;783        } else {
;;;784            p_tmr->DbgNextPtr           =  OSTmrDbgListPtr;
000010  4904              LDR      r1,|L8.36|
000012  6809              LDR      r1,[r1,#0]  ; OSTmrDbgListPtr
000014  62c1              STR      r1,[r0,#0x2c]
;;;785            OSTmrDbgListPtr->DbgPrevPtr =  p_tmr;
000016  4903              LDR      r1,|L8.36|
000018  6809              LDR      r1,[r1,#0]  ; OSTmrDbgListPtr
00001a  6288              STR      r0,[r1,#0x28]
                  |L8.28|
;;;786        }
;;;787        OSTmrDbgListPtr                 =  p_tmr;
00001c  4901              LDR      r1,|L8.36|
00001e  6008              STR      r0,[r1,#0]  ; OSTmrDbgListPtr
;;;788    }
000020  4770              BX       lr
;;;789    
                          ENDP

000022  0000              DCW      0x0000
                  |L8.36|
                          DCD      OSTmrDbgListPtr

                          AREA ||i.OS_TmrDbgListRemove||, CODE, READONLY, ALIGN=2

                  OS_TmrDbgListRemove PROC
;;;791    
;;;792    void  OS_TmrDbgListRemove (OS_TMR  *p_tmr)
000000  6a82              LDR      r2,[r0,#0x28]
;;;793    {
;;;794        OS_TMR  *p_tmr_next;
;;;795        OS_TMR  *p_tmr_prev;
;;;796    
;;;797    
;;;798        p_tmr_prev = p_tmr->DbgPrevPtr;
;;;799        p_tmr_next = p_tmr->DbgNextPtr;
000002  6ac1              LDR      r1,[r0,#0x2c]
;;;800    
;;;801        if (p_tmr_prev == (OS_TMR *)0) {
000004  b93a              CBNZ     r2,|L9.22|
;;;802            OSTmrDbgListPtr = p_tmr_next;
000006  4b09              LDR      r3,|L9.44|
000008  6019              STR      r1,[r3,#0]  ; OSTmrDbgListPtr
;;;803            if (p_tmr_next != (OS_TMR *)0) {
00000a  b109              CBZ      r1,|L9.16|
;;;804                p_tmr_next->DbgPrevPtr = (OS_TMR *)0;
00000c  2300              MOVS     r3,#0
00000e  628b              STR      r3,[r1,#0x28]
                  |L9.16|
;;;805            }
;;;806            p_tmr->DbgNextPtr = (OS_TMR *)0;
000010  2300              MOVS     r3,#0
000012  62c3              STR      r3,[r0,#0x2c]
000014  e009              B        |L9.42|
                  |L9.22|
;;;807    
;;;808        } else if (p_tmr_next == (OS_TMR *)0) {
000016  b919              CBNZ     r1,|L9.32|
;;;809            p_tmr_prev->DbgNextPtr = (OS_TMR *)0;
000018  2300              MOVS     r3,#0
00001a  62d3              STR      r3,[r2,#0x2c]
;;;810            p_tmr->DbgPrevPtr      = (OS_TMR *)0;
00001c  6283              STR      r3,[r0,#0x28]
00001e  e004              B        |L9.42|
                  |L9.32|
;;;811    
;;;812        } else {
;;;813            p_tmr_prev->DbgNextPtr =  p_tmr_next;
000020  62d1              STR      r1,[r2,#0x2c]
;;;814            p_tmr_next->DbgPrevPtr =  p_tmr_prev;
000022  628a              STR      r2,[r1,#0x28]
;;;815            p_tmr->DbgNextPtr      = (OS_TMR *)0;
000024  2300              MOVS     r3,#0
000026  62c3              STR      r3,[r0,#0x2c]
;;;816            p_tmr->DbgPrevPtr      = (OS_TMR *)0;
000028  6283              STR      r3,[r0,#0x28]
                  |L9.42|
;;;817        }
;;;818    }
00002a  4770              BX       lr
;;;819    #endif
                          ENDP

                  |L9.44|
                          DCD      OSTmrDbgListPtr

                          AREA ||i.OS_TmrInit||, CODE, READONLY, ALIGN=2

                  OS_TmrInit PROC
;;;841    
;;;842    void  OS_TmrInit (OS_ERR  *p_err)
000000  b510              PUSH     {r4,lr}
;;;843    {
000002  b08a              SUB      sp,sp,#0x28
000004  4604              MOV      r4,r0
;;;844    #ifdef OS_SAFETY_CRITICAL
;;;845        if (p_err == (OS_ERR *)0) {
;;;846            OS_SAFETY_CRITICAL_EXCEPTION();
;;;847            return;
;;;848        }
;;;849    #endif
;;;850    
;;;851    #if OS_CFG_DBG_EN > 0u
;;;852        OSTmrDbgListPtr = (OS_TMR *)0;
000006  2000              MOVS     r0,#0
000008  492f              LDR      r1,|L10.200|
00000a  6008              STR      r0,[r1,#0]  ; OSTmrDbgListPtr
;;;853    #endif
;;;854    
;;;855        OSTmrListPtr        = (OS_TMR *)0;                      /* Create an empty timer list                             */
00000c  492f              LDR      r1,|L10.204|
00000e  6008              STR      r0,[r1,#0]  ; OSTmrListPtr
;;;856        OSTmrListEntries    = 0u;
000010  492f              LDR      r1,|L10.208|
000012  8008              STRH     r0,[r1,#0]
;;;857    
;;;858        if (OSCfg_TmrTaskRate_Hz > (OS_RATE_HZ)0) {
000014  482f              LDR      r0,|L10.212|
000016  6800              LDR      r0,[r0,#0]  ; OSCfg_TmrTaskRate_Hz
000018  b140              CBZ      r0,|L10.44|
;;;859            OSTmrUpdateCnt  = OSCfg_TickRate_Hz / OSCfg_TmrTaskRate_Hz;
00001a  482f              LDR      r0,|L10.216|
00001c  6800              LDR      r0,[r0,#0]  ; OSCfg_TickRate_Hz
00001e  492d              LDR      r1,|L10.212|
000020  6809              LDR      r1,[r1,#0]  ; OSCfg_TmrTaskRate_Hz
000022  fbb0f0f1          UDIV     r0,r0,r1
000026  492d              LDR      r1,|L10.220|
000028  6008              STR      r0,[r1,#0]  ; OSTmrUpdateCnt
00002a  e006              B        |L10.58|
                  |L10.44|
;;;860        } else {
;;;861            OSTmrUpdateCnt  = OSCfg_TickRate_Hz / (OS_RATE_HZ)10;
00002c  482a              LDR      r0,|L10.216|
00002e  6800              LDR      r0,[r0,#0]  ; OSCfg_TickRate_Hz
000030  210a              MOVS     r1,#0xa
000032  fbb0f0f1          UDIV     r0,r0,r1
000036  4929              LDR      r1,|L10.220|
000038  6008              STR      r0,[r1,#0]  ; OSTmrUpdateCnt
                  |L10.58|
;;;862        }
;;;863        OSTmrUpdateCtr      = OSTmrUpdateCnt;
00003a  4828              LDR      r0,|L10.220|
00003c  6800              LDR      r0,[r0,#0]  ; OSTmrUpdateCnt
00003e  4928              LDR      r1,|L10.224|
000040  6008              STR      r0,[r1,#0]  ; OSTmrUpdateCtr
;;;864    
;;;865        OSTmrTickCtr        = (OS_TICK)0;
000042  2000              MOVS     r0,#0
000044  4927              LDR      r1,|L10.228|
000046  6008              STR      r0,[r1,#0]  ; OSTmrTickCtr
;;;866    
;;;867        OSTmrTaskTimeMax    = (CPU_TS)0;
000048  4927              LDR      r1,|L10.232|
00004a  6008              STR      r0,[r1,#0]  ; OSTmrTaskTimeMax
;;;868    
;;;869    #if   OS_CFG_MUTEX_EN > 0u
;;;870        OSMutexCreate(&OSTmrMutex,                              /* Use a mutex to protect the timers                      */
00004c  4622              MOV      r2,r4
00004e  a127              ADR      r1,|L10.236|
000050  482a              LDR      r0,|L10.252|
000052  f7fffffe          BL       OSMutexCreate
;;;871                      "OS Tmr Mutex", 
;;;872                      p_err);
;;;873        if (*p_err != OS_ERR_NONE) {
000056  8820              LDRH     r0,[r4,#0]
000058  b108              CBZ      r0,|L10.94|
                  |L10.90|
;;;874            return;
;;;875        }
;;;876    #endif
;;;877    
;;;878                                                                /* ---------------- CREATE THE TIMER TASK --------------- */
;;;879        if (OSCfg_TmrTaskStkBasePtr == (CPU_STK*)0) {
;;;880           *p_err = OS_ERR_TMR_STK_INVALID;
;;;881            return;
;;;882        }
;;;883    
;;;884        if (OSCfg_TmrTaskStkSize < OSCfg_StkSizeMin) {
;;;885           *p_err = OS_ERR_TMR_STK_SIZE_INVALID;
;;;886            return;
;;;887        }
;;;888    
;;;889        if (OSCfg_TmrTaskPrio >= (OS_CFG_PRIO_MAX - 1u)) {
;;;890           *p_err = OS_ERR_TMR_PRIO_INVALID;
;;;891            return;
;;;892        }
;;;893    
;;;894        OSTaskCreate((OS_TCB     *)&OSTmrTaskTCB,
;;;895                     (CPU_CHAR   *)((void *)"uC/OS-III Timer Task"),
;;;896                     (OS_TASK_PTR )OS_TmrTask,
;;;897                     (void       *)0,
;;;898                     (OS_PRIO     )OSCfg_TmrTaskPrio,
;;;899                     (CPU_STK    *)OSCfg_TmrTaskStkBasePtr,
;;;900                     (CPU_STK_SIZE)OSCfg_TmrTaskStkLimit,
;;;901                     (CPU_STK_SIZE)OSCfg_TmrTaskStkSize,
;;;902                     (OS_MSG_QTY  )0,
;;;903                     (OS_TICK     )0,
;;;904                     (void       *)0,
;;;905                     (OS_OPT      )(OS_OPT_TASK_STK_CHK | OS_OPT_TASK_STK_CLR | OS_OPT_TASK_NO_TLS),
;;;906                     (OS_ERR     *)p_err);
;;;907    }
00005a  b00a              ADD      sp,sp,#0x28
00005c  bd10              POP      {r4,pc}
                  |L10.94|
00005e  4828              LDR      r0,|L10.256|
000060  6800              LDR      r0,[r0,#0]            ;879  ; OSCfg_TmrTaskStkBasePtr
000062  b918              CBNZ     r0,|L10.108|
000064  f2473047          MOV      r0,#0x7347            ;880
000068  8020              STRH     r0,[r4,#0]            ;880
00006a  e7f6              B        |L10.90|
                  |L10.108|
00006c  4825              LDR      r0,|L10.260|
00006e  6800              LDR      r0,[r0,#0]            ;884  ; OSCfg_TmrTaskStkSize
000070  4925              LDR      r1,|L10.264|
000072  6809              LDR      r1,[r1,#0]            ;884  ; OSCfg_StkSizeMin
000074  4288              CMP      r0,r1                 ;884
000076  d203              BCS      |L10.128|
000078  f2473048          MOV      r0,#0x7348            ;885
00007c  8020              STRH     r0,[r4,#0]            ;885
00007e  e7ec              B        |L10.90|
                  |L10.128|
000080  4822              LDR      r0,|L10.268|
000082  7800              LDRB     r0,[r0,#0]            ;889  ; OSCfg_TmrTaskPrio
000084  283f              CMP      r0,#0x3f              ;889
000086  d303              BCC      |L10.144|
000088  f2473046          MOV      r0,#0x7346            ;890
00008c  8020              STRH     r0,[r4,#0]            ;890
00008e  e7e4              B        |L10.90|
                  |L10.144|
000090  200b              MOVS     r0,#0xb               ;894
000092  2100              MOVS     r1,#0                 ;894
000094  9105              STR      r1,[sp,#0x14]         ;894
000096  460a              MOV      r2,r1                 ;894
000098  e9cd0407          STRD     r0,r4,[sp,#0x1c]      ;894
00009c  9106              STR      r1,[sp,#0x18]         ;894
00009e  4819              LDR      r0,|L10.260|
0000a0  6800              LDR      r0,[r0,#0]            ;894  ; OSCfg_TmrTaskStkSize
0000a2  491b              LDR      r1,|L10.272|
0000a4  6809              LDR      r1,[r1,#0]            ;894  ; OSCfg_TmrTaskStkLimit
0000a6  4b16              LDR      r3,|L10.256|
0000a8  681b              LDR      r3,[r3,#0]            ;894  ; OSCfg_TmrTaskStkBasePtr
0000aa  e9cd3101          STRD     r3,r1,[sp,#4]         ;894
0000ae  e9cd0203          STRD     r0,r2,[sp,#0xc]       ;894
0000b2  4816              LDR      r0,|L10.268|
0000b4  7800              LDRB     r0,[r0,#0]            ;894  ; OSCfg_TmrTaskPrio
0000b6  2300              MOVS     r3,#0                 ;894
0000b8  4a16              LDR      r2,|L10.276|
0000ba  a117              ADR      r1,|L10.280|
0000bc  9000              STR      r0,[sp,#0]            ;894
0000be  481c              LDR      r0,|L10.304|
0000c0  f7fffffe          BL       OSTaskCreate
0000c4  bf00              NOP      
0000c6  e7c8              B        |L10.90|
;;;908    
                          ENDP

                  |L10.200|
                          DCD      OSTmrDbgListPtr
                  |L10.204|
                          DCD      OSTmrListPtr
                  |L10.208|
                          DCD      OSTmrListEntries
                  |L10.212|
                          DCD      OSCfg_TmrTaskRate_Hz
                  |L10.216|
                          DCD      OSCfg_TickRate_Hz
                  |L10.220|
                          DCD      OSTmrUpdateCnt
                  |L10.224|
                          DCD      OSTmrUpdateCtr
                  |L10.228|
                          DCD      OSTmrTickCtr
                  |L10.232|
                          DCD      OSTmrTaskTimeMax
                  |L10.236|
0000ec  4f532054          DCB      "OS Tmr Mutex",0
0000f0  6d72204d
0000f4  75746578
0000f8  00      
0000f9  00                DCB      0
0000fa  00                DCB      0
0000fb  00                DCB      0
                  |L10.252|
                          DCD      OSTmrMutex
                  |L10.256|
                          DCD      OSCfg_TmrTaskStkBasePtr
                  |L10.260|
                          DCD      OSCfg_TmrTaskStkSize
                  |L10.264|
                          DCD      OSCfg_StkSizeMin
                  |L10.268|
                          DCD      OSCfg_TmrTaskPrio
                  |L10.272|
                          DCD      OSCfg_TmrTaskStkLimit
                  |L10.276|
                          DCD      OS_TmrTask
                  |L10.280|
000118  75432f4f          DCB      "uC/OS-III Timer Task",0
00011c  532d4949
000120  49205469
000124  6d657220
000128  5461736b
00012c  00      
00012d  00                DCB      0
00012e  00                DCB      0
00012f  00                DCB      0
                  |L10.304|
                          DCD      OSTmrTaskTCB

                          AREA ||i.OS_TmrLock||, CODE, READONLY, ALIGN=2

                  OS_TmrLock PROC
;;;1058   
;;;1059   static  void  OS_TmrLock (void)
000000  b50e              PUSH     {r1-r3,lr}
;;;1060   {
;;;1061       OS_ERR  err;
;;;1062   #if OS_CFG_MUTEX_EN > 0u
;;;1063       CPU_TS  ts;
;;;1064   
;;;1065   
;;;1066       OSMutexPend(&OSTmrMutex,                                /* Use a mutex to protect the timers                      */
000002  a802              ADD      r0,sp,#8
000004  ab01              ADD      r3,sp,#4
000006  2200              MOVS     r2,#0
000008  4611              MOV      r1,r2
00000a  9000              STR      r0,[sp,#0]
00000c  4801              LDR      r0,|L11.20|
00000e  f7fffffe          BL       OSMutexPend
;;;1067                   0u,
;;;1068                   OS_OPT_PEND_BLOCKING,
;;;1069                   &ts,
;;;1070                   &err);
;;;1071   #else
;;;1072       OSSchedLock(&err);                                      /* Lock the scheduler to protect the timers               */
;;;1073   #endif
;;;1074       (void)&err;
;;;1075   }
000012  bd0e              POP      {r1-r3,pc}
;;;1076   
                          ENDP

                  |L11.20|
                          DCD      OSTmrMutex

                          AREA ||i.OS_TmrResetPeak||, CODE, READONLY, ALIGN=1

                  OS_TmrResetPeak PROC
;;;923    
;;;924    void  OS_TmrResetPeak (void)
000000  4770              BX       lr
;;;925    {
;;;926    }
;;;927    
                          ENDP


                          AREA ||i.OS_TmrTask||, CODE, READONLY, ALIGN=2

                  OS_TmrTask PROC
;;;985    
;;;986    void  OS_TmrTask (void  *p_arg)
000000  b51c              PUSH     {r2-r4,lr}
;;;987    {
;;;988        OS_ERR               err;
;;;989        OS_TMR_CALLBACK_PTR  p_fnct;
;;;990        OS_TMR              *p_tmr;
;;;991        OS_TMR              *p_tmr_next;
;;;992        CPU_TS               ts;
;;;993        CPU_TS               ts_start;
;;;994        CPU_TS               ts_delta;
;;;995    
;;;996    
;;;997    
;;;998        (void)&p_arg;                                                /* Not using 'p_arg', prevent compiler warning       */
;;;999        while (DEF_ON) {
000002  e03f              B        |L13.132|
                  |L13.4|
;;;1000           (void)OSTaskSemPend((OS_TICK )0,                         /* Wait for signal indicating time to update tmrs    */
000004  ab01              ADD      r3,sp,#4
000006  466a              MOV      r2,sp
000008  2100              MOVS     r1,#0
00000a  4608              MOV      r0,r1
00000c  f7fffffe          BL       OSTaskSemPend
;;;1001                               (OS_OPT  )OS_OPT_PEND_BLOCKING,
;;;1002                               (CPU_TS *)&ts,
;;;1003                               (OS_ERR *)&err);
;;;1004   
;;;1005   
;;;1006           OS_TmrLock();
000010  f7fffffe          BL       OS_TmrLock
;;;1007           ts_start = OS_TS_GET();
000014  f7fffffe          BL       CPU_TS_TmrRd
000018  4606              MOV      r6,r0
;;;1008           OSTmrTickCtr++;                                          /* Increment the current time                        */
00001a  481b              LDR      r0,|L13.136|
00001c  6800              LDR      r0,[r0,#0]  ; OSTmrTickCtr
00001e  1c40              ADDS     r0,r0,#1
000020  4919              LDR      r1,|L13.136|
000022  6008              STR      r0,[r1,#0]  ; OSTmrTickCtr
;;;1009           p_tmr    = OSTmrListPtr;
000024  4819              LDR      r0,|L13.140|
000026  6804              LDR      r4,[r0,#0]  ; OSTmrListPtr
;;;1010           while (p_tmr != (OS_TMR *)0) {                           /* Update all the timers in the list                 */
000028  e01f              B        |L13.106|
                  |L13.42|
;;;1011               OSSchedLock(&err);
00002a  a801              ADD      r0,sp,#4
00002c  f7fffffe          BL       OSSchedLock
;;;1012               (void)&err;
;;;1013               p_tmr_next = p_tmr->NextPtr;
000030  f8d48010          LDR      r8,[r4,#0x10]
;;;1014               p_tmr->Remain--;
000034  69a0              LDR      r0,[r4,#0x18]
000036  1e40              SUBS     r0,r0,#1
000038  61a0              STR      r0,[r4,#0x18]
;;;1015               if (p_tmr->Remain == 0) {
00003a  69a0              LDR      r0,[r4,#0x18]
00003c  b980              CBNZ     r0,|L13.96|
;;;1016                   if (p_tmr->Opt == OS_OPT_TMR_PERIODIC) {
00003e  8ca0              LDRH     r0,[r4,#0x24]
000040  2802              CMP      r0,#2
000042  d102              BNE      |L13.74|
;;;1017                       p_tmr->Remain = p_tmr->Period;               /* Reload the time remaining                         */
000044  6a20              LDR      r0,[r4,#0x20]
000046  61a0              STR      r0,[r4,#0x18]
000048  e005              B        |L13.86|
                  |L13.74|
;;;1018                   } else {
;;;1019                       OS_TmrUnlink(p_tmr);                         /* Remove from list                                  */
00004a  4620              MOV      r0,r4
00004c  f7fffffe          BL       OS_TmrUnlink
;;;1020                       p_tmr->State = OS_TMR_STATE_COMPLETED;       /* Indicate that the timer has completed             */
000050  2003              MOVS     r0,#3
000052  f8840026          STRB     r0,[r4,#0x26]
                  |L13.86|
;;;1021                   }
;;;1022                   p_fnct = p_tmr->CallbackPtr;                     /* Execute callback function if available            */
000056  68a5              LDR      r5,[r4,#8]
;;;1023                   if (p_fnct != (OS_TMR_CALLBACK_PTR)0) {
000058  b115              CBZ      r5,|L13.96|
;;;1024                       (*p_fnct)((void *)p_tmr,
00005a  4620              MOV      r0,r4
00005c  68e1              LDR      r1,[r4,#0xc]
00005e  47a8              BLX      r5
                  |L13.96|
;;;1025                                 p_tmr->CallbackPtrArg);
;;;1026                   }
;;;1027               }
;;;1028               p_tmr = p_tmr_next;
000060  4644              MOV      r4,r8
;;;1029               OSSchedUnlock(&err);
000062  a801              ADD      r0,sp,#4
000064  f7fffffe          BL       OSSchedUnlock
;;;1030               (void)&err;
000068  bf00              NOP      
                  |L13.106|
00006a  2c00              CMP      r4,#0                 ;1010
00006c  d1dd              BNE      |L13.42|
;;;1031           }
;;;1032   
;;;1033           ts_delta = OS_TS_GET() - ts_start;                      /* Measure execution time of timer task              */
00006e  f7fffffe          BL       CPU_TS_TmrRd
000072  1b87              SUBS     r7,r0,r6
;;;1034           OS_TmrUnlock();
000074  f7fffffe          BL       OS_TmrUnlock
;;;1035   
;;;1036           if (OSTmrTaskTimeMax < ts_delta) {
000078  4805              LDR      r0,|L13.144|
00007a  6800              LDR      r0,[r0,#0]  ; OSTmrTaskTimeMax
00007c  42b8              CMP      r0,r7
00007e  d201              BCS      |L13.132|
;;;1037               OSTmrTaskTimeMax = ts_delta;
000080  4803              LDR      r0,|L13.144|
000082  6007              STR      r7,[r0,#0]  ; OSTmrTaskTimeMax
                  |L13.132|
000084  e7be              B        |L13.4|
;;;1038           }
;;;1039       }
;;;1040   }
;;;1041   
                          ENDP

000086  0000              DCW      0x0000
                  |L13.136|
                          DCD      OSTmrTickCtr
                  |L13.140|
                          DCD      OSTmrListPtr
                  |L13.144|
                          DCD      OSTmrTaskTimeMax

                          AREA ||i.OS_TmrUnlink||, CODE, READONLY, ALIGN=2

                  OS_TmrUnlink PROC
;;;943    
;;;944    void  OS_TmrUnlink (OS_TMR  *p_tmr)
000000  b510              PUSH     {r4,lr}
;;;945    {
;;;946        OS_TMR  *p_tmr1;
;;;947        OS_TMR  *p_tmr2;
;;;948    
;;;949    
;;;950    
;;;951        if (OSTmrListPtr == p_tmr) {                            /* See if timer to remove is at the beginning of list     */
000002  4b0e              LDR      r3,|L14.60|
000004  681b              LDR      r3,[r3,#0]  ; OSTmrListPtr
000006  4283              CMP      r3,r0
000008  d106              BNE      |L14.24|
;;;952            p_tmr1       = (OS_TMR *)p_tmr->NextPtr;
00000a  6901              LDR      r1,[r0,#0x10]
;;;953            OSTmrListPtr = (OS_TMR *)p_tmr1;
00000c  4b0b              LDR      r3,|L14.60|
00000e  6019              STR      r1,[r3,#0]  ; OSTmrListPtr
;;;954            if (p_tmr1 != (OS_TMR *)0) {
000010  b139              CBZ      r1,|L14.34|
;;;955                p_tmr1->PrevPtr = (OS_TMR *)0;
000012  2300              MOVS     r3,#0
000014  614b              STR      r3,[r1,#0x14]
000016  e004              B        |L14.34|
                  |L14.24|
;;;956            }
;;;957        } else {
;;;958            p_tmr1          = (OS_TMR *)p_tmr->PrevPtr;         /* Remove timer from somewhere in the list                */
000018  6941              LDR      r1,[r0,#0x14]
;;;959            p_tmr2          = (OS_TMR *)p_tmr->NextPtr;
00001a  6902              LDR      r2,[r0,#0x10]
;;;960            p_tmr1->NextPtr = p_tmr2;
00001c  610a              STR      r2,[r1,#0x10]
;;;961            if (p_tmr2 != (OS_TMR *)0) {
00001e  b102              CBZ      r2,|L14.34|
;;;962                p_tmr2->PrevPtr = (OS_TMR *)p_tmr1;
000020  6151              STR      r1,[r2,#0x14]
                  |L14.34|
;;;963            }
;;;964        }
;;;965        p_tmr->State   = OS_TMR_STATE_STOPPED;
000022  2301              MOVS     r3,#1
000024  f8803026          STRB     r3,[r0,#0x26]
;;;966        p_tmr->NextPtr = (OS_TMR *)0;
000028  2300              MOVS     r3,#0
00002a  6103              STR      r3,[r0,#0x10]
;;;967        p_tmr->PrevPtr = (OS_TMR *)0;
00002c  6143              STR      r3,[r0,#0x14]
;;;968        OSTmrListEntries--;
00002e  4b04              LDR      r3,|L14.64|
000030  881b              LDRH     r3,[r3,#0]  ; OSTmrListEntries
000032  1e5b              SUBS     r3,r3,#1
000034  4c02              LDR      r4,|L14.64|
000036  8023              STRH     r3,[r4,#0]
;;;969    }
000038  bd10              POP      {r4,pc}
;;;970    
                          ENDP

00003a  0000              DCW      0x0000
                  |L14.60|
                          DCD      OSTmrListPtr
                  |L14.64|
                          DCD      OSTmrListEntries

                          AREA ||i.OS_TmrUnlock||, CODE, READONLY, ALIGN=2

                  OS_TmrUnlock PROC
;;;1079   
;;;1080   static  void  OS_TmrUnlock (void)
000000  b508              PUSH     {r3,lr}
;;;1081   {
;;;1082       OS_ERR  err;
;;;1083   
;;;1084   
;;;1085   #if OS_CFG_MUTEX_EN > 0u
;;;1086       OSMutexPost(&OSTmrMutex,                                /* Use a mutex to protect the timers                      */
000002  466a              MOV      r2,sp
000004  2100              MOVS     r1,#0
000006  4802              LDR      r0,|L15.16|
000008  f7fffffe          BL       OSMutexPost
;;;1087                   OS_OPT_POST_NONE,
;;;1088                   &err);
;;;1089   #else
;;;1090       OSSchedUnlock(&err);                                    /* Lock the scheduler to protect the timers               */
;;;1091   #endif
;;;1092       (void)&err;
;;;1093   }
00000c  bd08              POP      {r3,pc}
;;;1094   
                          ENDP

00000e  0000              DCW      0x0000
                  |L15.16|
                          DCD      OSTmrMutex
