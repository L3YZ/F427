; generated by Component: ARM Compiler 5.05 (build 41) Tool: ArmCC [4d0eb9]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\os_task.o --asm_dir=.\Lst\ --list_dir=.\Lst\ --depend=.\obj\os_task.d --cpu=Cortex-M4.fp --apcs=interwork -O0 -I..\..\..\CMSIS\4.5.0\CMSIS\Include -I..\APP -I..\APP\ST -I..\APP\uCOS -I..\..\BSP\KeilMDK -I..\..\BSP\Board\inc -I..\..\BSP\STM32F4xx\inc -I..\..\BSP\Xlong\inc -I..\..\..\uCOS\uC-CPU -I..\..\..\uCOS\uC-CPU\Ports\ARM-Cortex-M4 -I..\..\..\uCOS\uC-LIB -I..\..\..\uCOS\uC-LIB\Ports\ARM-Cortex-M4 -I..\..\..\uCOS\uCOS-III\Source -I..\..\..\uCOS\uCOS-III\Ports\ARM-Cortex-M4 -IC:\Users\V200\Desktop\XLong\XLong\OS\KeilMDKPrj\RTE -Id:\Keil_v5\ARM\PACK\Keil\STM32F4xx_DFP\1.0.8\Device\Include -Id:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -DSTM32F427_437xx -DSTM32F427_437xx -DUSE_STDPERIPH_DRIVER --omf_browse=.\obj\os_task.crf ..\..\..\uCOS\uCOS-III\Source\os_task.c]
                          THUMB

                          AREA ||i.OSTaskChangePrio||, CODE, READONLY, ALIGN=2

                  OSTaskChangePrio PROC
;;;65     #if OS_CFG_TASK_CHANGE_PRIO_EN > 0u
;;;66     void  OSTaskChangePrio (OS_TCB   *p_tcb,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;67                             OS_PRIO   prio_new,
;;;68                             OS_ERR   *p_err)
;;;69     {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
;;;70     #if OS_CFG_MUTEX_EN > 0u
;;;71         OS_PRIO  prio_high;
;;;72     #endif
;;;73         CPU_SR_ALLOC();
00000a  f04f0800          MOV      r8,#0
;;;74     
;;;75     
;;;76     #ifdef OS_SAFETY_CRITICAL
;;;77         if (p_err == (OS_ERR *)0) {
;;;78             OS_SAFETY_CRITICAL_EXCEPTION();
;;;79             return;
;;;80         }
;;;81     #endif
;;;82     
;;;83     #if OS_CFG_ARG_CHK_EN > 0u
;;;84         if ((p_tcb != (OS_TCB *)0u) && (p_tcb->TaskState == OS_TASK_STATE_DEL)) {
00000e  b134              CBZ      r4,|L1.30|
000010  f8940036          LDRB     r0,[r4,#0x36]
000014  28ff              CMP      r0,#0xff
000016  d102              BNE      |L1.30|
;;;85            *p_err = OS_ERR_STATE_INVALID;
000018  f646602d          MOV      r0,#0x6e2d
00001c  8030              STRH     r0,[r6,#0]
                  |L1.30|
;;;86         }
;;;87     #endif
;;;88     
;;;89     #if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
;;;90         if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* Not allowed to call from an ISR                        */
;;;91            *p_err = OS_ERR_TASK_CHANGE_PRIO_ISR;
;;;92             return;
;;;93         }
;;;94     #endif
;;;95     
;;;96     #if OS_CFG_ISR_POST_DEFERRED_EN > 0u
;;;97         if (prio_new == 0) {                                    /* Cannot set to IntQueue Task priority                   */
;;;98            *p_err = OS_ERR_PRIO_INVALID;
;;;99             return;
;;;100        }
;;;101    #endif
;;;102    
;;;103        if (prio_new >= (OS_CFG_PRIO_MAX - 1u)) {               /* Cannot set to Idle Task priority                       */
00001e  2d3f              CMP      r5,#0x3f
000020  d304              BCC      |L1.44|
;;;104           *p_err = OS_ERR_PRIO_INVALID;
000022  f2462073          MOV      r0,#0x6273
000026  8030              STRH     r0,[r6,#0]
                  |L1.40|
;;;105            return;
;;;106        }
;;;107    
;;;108        if (p_tcb == (OS_TCB *)0) {                             /* Are we changing the priority of 'self'?                */
;;;109            CPU_CRITICAL_ENTER();
;;;110            p_tcb = OSTCBCurPtr;
;;;111            CPU_CRITICAL_EXIT();
;;;112        }
;;;113    
;;;114        OS_CRITICAL_ENTER();
;;;115    
;;;116    #if OS_CFG_MUTEX_EN > 0u
;;;117        p_tcb->BasePrio = prio_new;                             /* Update base priority                                   */
;;;118    
;;;119        if (p_tcb->MutexGrpHeadPtr != (OS_MUTEX *)0) {              /* Owning a mutex?                                      */
;;;120            if (prio_new > p_tcb->Prio) {
;;;121                prio_high = OS_MutexGrpPrioFindHighest(p_tcb);
;;;122                if (prio_new > prio_high) {
;;;123                    prio_new = prio_high;
;;;124                }
;;;125            }
;;;126        }
;;;127    #endif
;;;128    
;;;129        OS_TaskChangePrio(p_tcb, prio_new);
;;;130    
;;;131        OS_CRITICAL_EXIT_NO_SCHED();
;;;132    
;;;133        OSSched();                                              /* Run highest priority task ready                        */
;;;134    
;;;135       *p_err = OS_ERR_NONE;
;;;136    }
000028  e8bd81f0          POP      {r4-r8,pc}
                  |L1.44|
00002c  b97c              CBNZ     r4,|L1.78|
00002e  bf00              NOP                            ;109
000030  bf00              NOP                            ;109
000032  f7fffffe          BL       CPU_SR_Save
000036  4680              MOV      r8,r0                 ;109
000038  bf00              NOP                            ;109
00003a  bf00              NOP                            ;109
00003c  4817              LDR      r0,|L1.156|
00003e  6804              LDR      r4,[r0,#0]            ;110  ; OSTCBCurPtr
000040  bf00              NOP                            ;111
000042  bf00              NOP                            ;111
000044  4640              MOV      r0,r8                 ;111
000046  f7fffffe          BL       CPU_SR_Restore
00004a  bf00              NOP                            ;111
00004c  bf00              NOP                            ;111
                  |L1.78|
00004e  bf00              NOP                            ;114
000050  bf00              NOP                            ;114
000052  f7fffffe          BL       CPU_SR_Save
000056  4680              MOV      r8,r0                 ;114
000058  bf00              NOP                            ;114
00005a  bf00              NOP                            ;114
00005c  f8845038          STRB     r5,[r4,#0x38]         ;117
000060  6be0              LDR      r0,[r4,#0x3c]         ;119
000062  b150              CBZ      r0,|L1.122|
000064  f8940037          LDRB     r0,[r4,#0x37]         ;120
000068  42a8              CMP      r0,r5                 ;120
00006a  da06              BGE      |L1.122|
00006c  4620              MOV      r0,r4                 ;121
00006e  f7fffffe          BL       OS_MutexGrpPrioFindHighest
000072  4607              MOV      r7,r0                 ;121
000074  42bd              CMP      r5,r7                 ;122
000076  dd00              BLE      |L1.122|
000078  463d              MOV      r5,r7                 ;123
                  |L1.122|
00007a  4629              MOV      r1,r5                 ;129
00007c  4620              MOV      r0,r4                 ;129
00007e  f7fffffe          BL       OS_TaskChangePrio
000082  bf00              NOP                            ;131
000084  bf00              NOP                            ;131
000086  4640              MOV      r0,r8                 ;131
000088  f7fffffe          BL       CPU_SR_Restore
00008c  bf00              NOP                            ;131
00008e  bf00              NOP                            ;131
000090  f7fffffe          BL       OSSched
000094  2000              MOVS     r0,#0                 ;135
000096  8030              STRH     r0,[r6,#0]            ;135
000098  bf00              NOP      
00009a  e7c5              B        |L1.40|
;;;137    #endif
                          ENDP

                  |L1.156|
                          DCD      OSTCBCurPtr

                          AREA ||i.OSTaskCreate||, CODE, READONLY, ALIGN=2

                  OSTaskCreate PROC
;;;224    
;;;225    void  OSTaskCreate (OS_TCB        *p_tcb,
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;226                        CPU_CHAR      *p_name,
;;;227                        OS_TASK_PTR    p_task,
;;;228                        void          *p_arg,
;;;229                        OS_PRIO        prio,
;;;230                        CPU_STK       *p_stk_base,
;;;231                        CPU_STK_SIZE   stk_limit,
;;;232                        CPU_STK_SIZE   stk_size,
;;;233                        OS_MSG_QTY     q_size,
;;;234                        OS_TICK        time_quanta,
;;;235                        void          *p_ext,
;;;236                        OS_OPT         opt,
;;;237                        OS_ERR        *p_err)
;;;238    {
000004  b087              SUB      sp,sp,#0x1c
000006  4604              MOV      r4,r0
000008  4690              MOV      r8,r2
00000a  e9dda51b          LDRD     r10,r5,[sp,#0x6c]
00000e  e9dd9614          LDRD     r9,r6,[sp,#0x50]
000012  9f17              LDR      r7,[sp,#0x5c]
;;;239        CPU_STK_SIZE   i;
;;;240    #if OS_CFG_TASK_REG_TBL_SIZE > 0u
;;;241        OS_REG_ID      reg_nbr;
;;;242    #endif
;;;243    #if defined(OS_CFG_TLS_TBL_SIZE) && (OS_CFG_TLS_TBL_SIZE > 0u)
;;;244        OS_TLS_ID      id;
;;;245    #endif
;;;246    
;;;247        CPU_STK       *p_sp;
;;;248        CPU_STK       *p_stk_limit;
;;;249        CPU_SR_ALLOC();
000014  2000              MOVS     r0,#0
000016  9003              STR      r0,[sp,#0xc]
;;;250    
;;;251    
;;;252    
;;;253    #ifdef OS_SAFETY_CRITICAL
;;;254        if (p_err == (OS_ERR *)0) {
;;;255    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN > 0u))
;;;256            TRACE_OS_TASK_CREATE_FAILED(p_tcb);                 /* Record the event.                                      */
;;;257    #endif
;;;258            OS_SAFETY_CRITICAL_EXCEPTION();
;;;259            return;
;;;260        }
;;;261    #endif
;;;262    
;;;263    #ifdef OS_SAFETY_CRITICAL_IEC61508
;;;264        if (OSSafetyCriticalStartFlag == DEF_TRUE) {
;;;265    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN > 0u))
;;;266            TRACE_OS_TASK_CREATE_FAILED(p_tcb);                 /* Record the event.                                      */
;;;267    #endif
;;;268           *p_err = OS_ERR_ILLEGAL_CREATE_RUN_TIME;
;;;269            return;
;;;270        }
;;;271    #endif
;;;272    
;;;273    #if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
;;;274        if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* ---------- CANNOT CREATE A TASK FROM AN ISR ---------- */
;;;275    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN > 0u))
;;;276            TRACE_OS_TASK_CREATE_FAILED(p_tcb);                 /* Record the event.                                      */
;;;277    #endif
;;;278           *p_err = OS_ERR_TASK_CREATE_ISR;
;;;279            return;
;;;280        }
;;;281    #endif
;;;282    
;;;283    #if OS_CFG_ARG_CHK_EN > 0u                                  /* ---------------- VALIDATE ARGUMENTS ------------------ */
;;;284        if (p_tcb == (OS_TCB *)0) {                             /* User must supply a valid OS_TCB                        */
000018  b92c              CBNZ     r4,|L2.38|
;;;285    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN > 0u))
;;;286            TRACE_OS_TASK_CREATE_FAILED(p_tcb);                 /* Record the event.                                      */
;;;287    #endif
;;;288           *p_err = OS_ERR_TCB_INVALID;
00001a  f24710ad          MOV      r0,#0x71ad
00001e  8028              STRH     r0,[r5,#0]
                  |L2.32|
;;;289            return;
;;;290        }
;;;291        if (p_task == (OS_TASK_PTR)0) {                         /* User must supply a valid task                          */
;;;292    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN > 0u))
;;;293            TRACE_OS_TASK_CREATE_FAILED(p_tcb);                 /* Record the event.                                      */
;;;294    #endif
;;;295           *p_err = OS_ERR_TASK_INVALID;
;;;296            return;
;;;297        }
;;;298        if (p_stk_base == (CPU_STK *)0) {                       /* User must supply a valid stack base address            */
;;;299    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN > 0u))
;;;300            TRACE_OS_TASK_CREATE_FAILED(p_tcb);                 /* Record the event.                                      */
;;;301    #endif
;;;302           *p_err = OS_ERR_STK_INVALID;
;;;303            return;
;;;304        }
;;;305        if (stk_size < OSCfg_StkSizeMin) {                      /* User must supply a valid minimum stack size            */
;;;306    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN > 0u))
;;;307            TRACE_OS_TASK_CREATE_FAILED(p_tcb);                 /* Record the event.                                      */
;;;308    #endif
;;;309           *p_err = OS_ERR_STK_SIZE_INVALID;
;;;310            return;
;;;311        }
;;;312        if (stk_limit >= stk_size) {                            /* User must supply a valid stack limit                   */
;;;313    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN > 0u))
;;;314            TRACE_OS_TASK_CREATE_FAILED(p_tcb);                 /* Record the event.                                      */
;;;315    #endif
;;;316           *p_err = OS_ERR_STK_LIMIT_INVALID;
;;;317            return;
;;;318        }
;;;319        if (prio >= OS_CFG_PRIO_MAX) {                          /* Priority must be within 0 and OS_CFG_PRIO_MAX-1        */
;;;320    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN > 0u))
;;;321            TRACE_OS_TASK_CREATE_FAILED(p_tcb);                 /* Record the event.                                      */
;;;322    #endif
;;;323           *p_err = OS_ERR_PRIO_INVALID;
;;;324            return;
;;;325        }
;;;326    #endif
;;;327    
;;;328    #if OS_CFG_ISR_POST_DEFERRED_EN > 0u
;;;329        if (prio == (OS_PRIO)0) {
;;;330            if (p_tcb != &OSIntQTaskTCB) {
;;;331    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN > 0u))
;;;332                TRACE_OS_TASK_CREATE_FAILED(p_tcb);             /* Record the event.                                      */
;;;333    #endif
;;;334               *p_err = OS_ERR_PRIO_INVALID;                    /* Not allowed to use priority 0                          */
;;;335                return;
;;;336            }
;;;337        }
;;;338    #endif
;;;339    
;;;340        if (prio == (OS_CFG_PRIO_MAX - 1u)) {
;;;341            if (p_tcb != &OSIdleTaskTCB) {
;;;342    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN > 0u))
;;;343                TRACE_OS_TASK_CREATE_FAILED(p_tcb);             /* Record the event.                                      */
;;;344    #endif
;;;345               *p_err = OS_ERR_PRIO_INVALID;                    /* Not allowed to use same priority as idle task          */
;;;346                return;
;;;347            }
;;;348        }
;;;349    
;;;350        OS_TaskInitTCB(p_tcb);                                  /* Initialize the TCB to default values                   */
;;;351    
;;;352       *p_err = OS_ERR_NONE;
;;;353                                                                /* --------------- CLEAR THE TASK'S STACK --------------- */
;;;354        if ((opt & OS_OPT_TASK_STK_CHK) != (OS_OPT)0) {         /* See if stack checking has been enabled                 */
;;;355            if ((opt & OS_OPT_TASK_STK_CLR) != (OS_OPT)0) {     /* See if stack needs to be cleared                       */
;;;356                p_sp = p_stk_base;
;;;357                for (i = 0u; i < stk_size; i++) {               /* Stack grows from HIGH to LOW memory                    */
;;;358                   *p_sp = (CPU_STK)0;                          /* Clear from bottom of stack and up!                     */
;;;359                    p_sp++;
;;;360                }
;;;361            }
;;;362        }
;;;363                                                                /* ------- INITIALIZE THE STACK FRAME OF THE TASK ------- */
;;;364    #if (CPU_CFG_STK_GROWTH == CPU_STK_GROWTH_HI_TO_LO)
;;;365        p_stk_limit = p_stk_base + stk_limit;
;;;366    #else
;;;367        p_stk_limit = p_stk_base + (stk_size - 1u) - stk_limit;
;;;368    #endif
;;;369    
;;;370        p_sp = OSTaskStkInit(p_task,
;;;371                             p_arg,
;;;372                             p_stk_base,
;;;373                             p_stk_limit,
;;;374                             stk_size,
;;;375                             opt);
;;;376    
;;;377                                                                /* -------------- INITIALIZE THE TCB FIELDS ------------- */
;;;378    #if OS_CFG_DBG_EN > 0u
;;;379        p_tcb->TaskEntryAddr = p_task;                          /* Save task entry point address                          */
;;;380        p_tcb->TaskEntryArg  = p_arg;                           /* Save task entry argument                               */
;;;381    #endif
;;;382    
;;;383    #if OS_CFG_DBG_EN > 0u
;;;384        p_tcb->NamePtr       = p_name;                          /* Save task name                                         */
;;;385    #else
;;;386        (void)&p_name;
;;;387    #endif
;;;388    
;;;389        p_tcb->Prio          = prio;                            /* Save the task's priority                               */
;;;390    
;;;391    #if OS_CFG_MUTEX_EN > 0u
;;;392        p_tcb->BasePrio      = prio;                            /* Set the base priority                                  */
;;;393    #endif
;;;394    
;;;395        p_tcb->StkPtr        = p_sp;                            /* Save the new top-of-stack pointer                      */
;;;396    #if ((OS_CFG_DBG_EN > 0u) || (OS_CFG_STAT_TASK_STK_CHK_EN > 0u))
;;;397        p_tcb->StkLimitPtr   = p_stk_limit;                     /* Save the stack limit pointer                           */
;;;398    #endif
;;;399    
;;;400    #if OS_CFG_SCHED_ROUND_ROBIN_EN > 0u
;;;401        p_tcb->TimeQuanta    = time_quanta;                     /* Save the #ticks for time slice (0 means not sliced)    */
;;;402        if (time_quanta == (OS_TICK)0) {
;;;403            p_tcb->TimeQuantaCtr = OSSchedRoundRobinDfltTimeQuanta;
;;;404        } else {
;;;405            p_tcb->TimeQuantaCtr = time_quanta;
;;;406        }
;;;407    #else
;;;408        (void)&time_quanta;
;;;409    #endif
;;;410    
;;;411        p_tcb->ExtPtr        = p_ext;                           /* Save pointer to TCB extension                          */
;;;412    #if ((OS_CFG_DBG_EN > 0u) || (OS_CFG_STAT_TASK_STK_CHK_EN > 0u))
;;;413        p_tcb->StkBasePtr    = p_stk_base;                      /* Save pointer to the base address of the stack          */
;;;414        p_tcb->StkSize       = stk_size;                        /* Save the stack size (in number of CPU_STK elements)    */
;;;415    #endif
;;;416        p_tcb->Opt           = opt;                             /* Save task options                                      */
;;;417    
;;;418    #if OS_CFG_TASK_REG_TBL_SIZE > 0u
;;;419        for (reg_nbr = 0u; reg_nbr < OS_CFG_TASK_REG_TBL_SIZE; reg_nbr++) {
;;;420            p_tcb->RegTbl[reg_nbr] = (OS_REG)0;
;;;421        }
;;;422    #endif
;;;423    
;;;424    #if OS_CFG_TASK_Q_EN > 0u
;;;425        OS_MsgQInit(&p_tcb->MsgQ,                               /* Initialize the task's message queue                    */
;;;426                    q_size);
;;;427    #else
;;;428        (void)&q_size;
;;;429    #endif
;;;430    
;;;431        OSTaskCreateHook(p_tcb);                                /* Call user defined hook                                 */
;;;432    
;;;433    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN > 0u))
;;;434        TRACE_OS_TASK_CREATE(p_tcb);                            /* Record the event.                                      */
;;;435        TRACE_OS_TASK_SEM_CREATE(p_tcb, p_name);                /* Record the event.                                      */
;;;436    #if OS_CFG_TASK_Q_EN > 0u
;;;437        TRACE_OS_TASK_MSG_Q_CREATE(&p_tcb->MsgQ, p_name);       /* Record the event.                                      */
;;;438    #endif
;;;439    #endif
;;;440    
;;;441    #if defined(OS_CFG_TLS_TBL_SIZE) && (OS_CFG_TLS_TBL_SIZE > 0u)
;;;442        for (id = 0u; id < OS_CFG_TLS_TBL_SIZE; id++) {
;;;443            p_tcb->TLS_Tbl[id] = (OS_TLS)0;
;;;444        }
;;;445        OS_TLS_TaskCreate(p_tcb);                               /* Call TLS hook                                          */
;;;446    #endif
;;;447                                                                /* --------------- ADD TASK TO READY LIST --------------- */
;;;448        OS_CRITICAL_ENTER();
;;;449        OS_PrioInsert(p_tcb->Prio);
;;;450        OS_RdyListInsertTail(p_tcb);
;;;451    
;;;452    #if OS_CFG_DBG_EN > 0u
;;;453        OS_TaskDbgListAdd(p_tcb);
;;;454    #endif
;;;455    
;;;456        OSTaskQty++;                                            /* Increment the #tasks counter                           */
;;;457    
;;;458        if (OSRunning != OS_STATE_OS_RUNNING) {                 /* Return if multitasking has not started                 */
;;;459            OS_CRITICAL_EXIT();
;;;460            return;
;;;461        }
;;;462    
;;;463        OS_CRITICAL_EXIT_NO_SCHED();
;;;464    
;;;465        OSSched();
;;;466    }
000020  b00b              ADD      sp,sp,#0x2c
000022  e8bd8ff0          POP      {r4-r11,pc}
                  |L2.38|
000026  f1b80f00          CMP      r8,#0                 ;291
00002a  d103              BNE      |L2.52|
00002c  f247104f          MOV      r0,#0x714f            ;295
000030  8028              STRH     r0,[r5,#0]            ;295
000032  e7f5              B        |L2.32|
                  |L2.52|
000034  b91e              CBNZ     r6,|L2.62|
000036  f646602f          MOV      r0,#0x6e2f            ;302
00003a  8028              STRH     r0,[r5,#0]            ;302
00003c  e7f0              B        |L2.32|
                  |L2.62|
00003e  4850              LDR      r0,|L2.384|
000040  6800              LDR      r0,[r0,#0]            ;305  ; OSCfg_StkSizeMin
000042  4287              CMP      r7,r0                 ;305
000044  d203              BCS      |L2.78|
000046  f6466030          MOV      r0,#0x6e30            ;309
00004a  8028              STRH     r0,[r5,#0]            ;309
00004c  e7e8              B        |L2.32|
                  |L2.78|
00004e  9816              LDR      r0,[sp,#0x58]         ;312
000050  42b8              CMP      r0,r7                 ;312
000052  d303              BCC      |L2.92|
000054  f6466031          MOV      r0,#0x6e31            ;316
000058  8028              STRH     r0,[r5,#0]            ;316
00005a  e7e1              B        |L2.32|
                  |L2.92|
00005c  f1b90f40          CMP      r9,#0x40              ;319
000060  d303              BCC      |L2.106|
000062  f2462073          MOV      r0,#0x6273            ;323
000066  8028              STRH     r0,[r5,#0]            ;323
000068  e7da              B        |L2.32|
                  |L2.106|
00006a  f1b90f3f          CMP      r9,#0x3f              ;340
00006e  d106              BNE      |L2.126|
000070  4844              LDR      r0,|L2.388|
000072  4284              CMP      r4,r0                 ;341
000074  d003              BEQ      |L2.126|
000076  f2462073          MOV      r0,#0x6273            ;345
00007a  8028              STRH     r0,[r5,#0]            ;345
00007c  e7d0              B        |L2.32|
                  |L2.126|
00007e  4620              MOV      r0,r4                 ;350
000080  f7fffffe          BL       OS_TaskInitTCB
000084  2000              MOVS     r0,#0                 ;352
000086  8028              STRH     r0,[r5,#0]            ;352
000088  f00a0001          AND      r0,r10,#1             ;354
00008c  b190              CBZ      r0,|L2.180|
00008e  f00a0002          AND      r0,r10,#2             ;355
000092  b178              CBZ      r0,|L2.180|
000094  9605              STR      r6,[sp,#0x14]         ;356
000096  2000              MOVS     r0,#0                 ;357
000098  9006              STR      r0,[sp,#0x18]         ;357
00009a  e008              B        |L2.174|
                  |L2.156|
00009c  2100              MOVS     r1,#0                 ;358
00009e  9805              LDR      r0,[sp,#0x14]         ;358
0000a0  6001              STR      r1,[r0,#0]            ;358
0000a2  9805              LDR      r0,[sp,#0x14]         ;359
0000a4  1d00              ADDS     r0,r0,#4              ;359
0000a6  9005              STR      r0,[sp,#0x14]         ;359
0000a8  9806              LDR      r0,[sp,#0x18]         ;357
0000aa  1c40              ADDS     r0,r0,#1              ;357
0000ac  9006              STR      r0,[sp,#0x18]         ;357
                  |L2.174|
0000ae  9806              LDR      r0,[sp,#0x18]         ;357
0000b0  42b8              CMP      r0,r7                 ;357
0000b2  d3f3              BCC      |L2.156|
                  |L2.180|
0000b4  9816              LDR      r0,[sp,#0x58]         ;365
0000b6  eb060080          ADD      r0,r6,r0,LSL #2       ;365
0000ba  9004              STR      r0,[sp,#0x10]         ;365
0000bc  e9cd7a00          STRD     r7,r10,[sp,#0]        ;370
0000c0  4632              MOV      r2,r6                 ;370
0000c2  4640              MOV      r0,r8                 ;370
0000c4  9b04              LDR      r3,[sp,#0x10]         ;370
0000c6  990a              LDR      r1,[sp,#0x28]         ;370
0000c8  f7fffffe          BL       OSTaskStkInit
0000cc  9005              STR      r0,[sp,#0x14]         ;370
0000ce  f8c48028          STR      r8,[r4,#0x28]         ;379
0000d2  980a              LDR      r0,[sp,#0x28]         ;380
0000d4  62e0              STR      r0,[r4,#0x2c]         ;380
0000d6  9808              LDR      r0,[sp,#0x20]         ;384
0000d8  6220              STR      r0,[r4,#0x20]         ;384
0000da  f8849037          STRB     r9,[r4,#0x37]         ;389
0000de  f8849038          STRB     r9,[r4,#0x38]         ;392
0000e2  9805              LDR      r0,[sp,#0x14]         ;395
0000e4  6020              STR      r0,[r4,#0]            ;395
0000e6  9804              LDR      r0,[sp,#0x10]         ;397
0000e8  60a0              STR      r0,[r4,#8]            ;397
0000ea  981a              LDR      r0,[sp,#0x68]         ;411
0000ec  6060              STR      r0,[r4,#4]            ;411
0000ee  6266              STR      r6,[r4,#0x24]         ;413
0000f0  6427              STR      r7,[r4,#0x40]         ;414
0000f2  f8a4a044          STRH     r10,[r4,#0x44]        ;416
0000f6  f04f0b00          MOV      r11,#0                ;419
0000fa  e008              B        |L2.270|
                  |L2.252|
0000fc  2100              MOVS     r1,#0                 ;420
0000fe  f1040078          ADD      r0,r4,#0x78           ;420
000102  f840102b          STR      r1,[r0,r11,LSL #2]    ;420
000106  f10b0001          ADD      r0,r11,#1             ;419
00010a  f0000bff          AND      r11,r0,#0xff          ;419
                  |L2.270|
00010e  f1bb0f00          CMP      r11,#0                ;419
000112  d0f3              BEQ      |L2.252|
000114  f1040060          ADD      r0,r4,#0x60           ;425
000118  9918              LDR      r1,[sp,#0x60]         ;425
00011a  f7fffffe          BL       OS_MsgQInit
00011e  4620              MOV      r0,r4                 ;431
000120  f7fffffe          BL       OSTaskCreateHook
000124  bf00              NOP                            ;448
000126  bf00              NOP                            ;448
000128  f7fffffe          BL       CPU_SR_Save
00012c  9003              STR      r0,[sp,#0xc]          ;448
00012e  bf00              NOP                            ;448
000130  bf00              NOP                            ;448
000132  f8940037          LDRB     r0,[r4,#0x37]         ;449
000136  f7fffffe          BL       OS_PrioInsert
00013a  4620              MOV      r0,r4                 ;450
00013c  f7fffffe          BL       OS_RdyListInsertTail
000140  4620              MOV      r0,r4                 ;453
000142  f7fffffe          BL       OS_TaskDbgListAdd
000146  4810              LDR      r0,|L2.392|
000148  8800              LDRH     r0,[r0,#0]            ;456  ; OSTaskQty
00014a  1c40              ADDS     r0,r0,#1              ;456
00014c  490e              LDR      r1,|L2.392|
00014e  8008              STRH     r0,[r1,#0]            ;456
000150  480e              LDR      r0,|L2.396|
000152  7800              LDRB     r0,[r0,#0]            ;458  ; OSRunning
000154  2801              CMP      r0,#1                 ;458
000156  d007              BEQ      |L2.360|
000158  bf00              NOP                            ;459
00015a  bf00              NOP                            ;459
00015c  9803              LDR      r0,[sp,#0xc]          ;459
00015e  f7fffffe          BL       CPU_SR_Restore
000162  bf00              NOP                            ;459
000164  bf00              NOP                            ;459
000166  e75b              B        |L2.32|
                  |L2.360|
000168  bf00              NOP                            ;463
00016a  bf00              NOP                            ;463
00016c  9803              LDR      r0,[sp,#0xc]          ;463
00016e  f7fffffe          BL       CPU_SR_Restore
000172  bf00              NOP                            ;463
000174  bf00              NOP                            ;463
000176  f7fffffe          BL       OSSched
00017a  bf00              NOP      
00017c  e750              B        |L2.32|
;;;467    
                          ENDP

00017e  0000              DCW      0x0000
                  |L2.384|
                          DCD      OSCfg_StkSizeMin
                  |L2.388|
                          DCD      OSIdleTaskTCB
                  |L2.392|
                          DCD      OSTaskQty
                  |L2.396|
                          DCD      OSRunning

                          AREA ||i.OSTaskDel||, CODE, READONLY, ALIGN=2

                  OSTaskDel PROC
;;;495    #if OS_CFG_TASK_DEL_EN > 0u
;;;496    void  OSTaskDel (OS_TCB  *p_tcb,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;497                     OS_ERR  *p_err)
;;;498    {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
;;;499    #if OS_CFG_MUTEX_EN > 0u
;;;500        OS_TCB  *p_tcb_owner;
;;;501        OS_PRIO  prio_new;
;;;502    #endif
;;;503        CPU_SR_ALLOC();
000008  f04f0800          MOV      r8,#0
;;;504    
;;;505    
;;;506    
;;;507    #ifdef OS_SAFETY_CRITICAL
;;;508        if (p_err == (OS_ERR *)0) {
;;;509            OS_SAFETY_CRITICAL_EXCEPTION();
;;;510            return;
;;;511        }
;;;512    #endif
;;;513    
;;;514    #if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
;;;515        if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* See if trying to delete from ISR                       */
;;;516           *p_err = OS_ERR_TASK_DEL_ISR;
;;;517            return;
;;;518        }
;;;519    #endif
;;;520    
;;;521        if (p_tcb == &OSIdleTaskTCB) {                          /* Not allowed to delete the idle task                    */
00000c  485b              LDR      r0,|L3.380|
00000e  4284              CMP      r4,r0
000010  d104              BNE      |L3.28|
;;;522           *p_err = OS_ERR_TASK_DEL_IDLE;
000012  f247104c          MOV      r0,#0x714c
000016  8030              STRH     r0,[r6,#0]
                  |L3.24|
;;;523            return;
;;;524        }
;;;525    
;;;526    #if OS_CFG_ISR_POST_DEFERRED_EN > 0u
;;;527        if (p_tcb == &OSIntQTaskTCB) {                          /* Cannot delete the ISR handler task                     */
;;;528           *p_err = OS_ERR_TASK_DEL_INVALID;
;;;529            return;
;;;530        }
;;;531    #endif
;;;532    
;;;533        if (p_tcb == (OS_TCB *)0) {                             /* Delete 'Self'?                                         */
;;;534            CPU_CRITICAL_ENTER();
;;;535            p_tcb  = OSTCBCurPtr;                               /* Yes.                                                   */
;;;536            CPU_CRITICAL_EXIT();
;;;537        }
;;;538    
;;;539        OS_CRITICAL_ENTER();
;;;540        switch (p_tcb->TaskState) {
;;;541            case OS_TASK_STATE_RDY:
;;;542                 OS_RdyListRemove(p_tcb);
;;;543                 break;
;;;544    
;;;545            case OS_TASK_STATE_SUSPENDED:
;;;546                 break;
;;;547    
;;;548            case OS_TASK_STATE_DLY:                             /* Task is only delayed, not on any wait list             */
;;;549            case OS_TASK_STATE_DLY_SUSPENDED:
;;;550                 OS_TickListRemove(p_tcb);
;;;551                 break;
;;;552    
;;;553            case OS_TASK_STATE_PEND:
;;;554            case OS_TASK_STATE_PEND_SUSPENDED:
;;;555            case OS_TASK_STATE_PEND_TIMEOUT:
;;;556            case OS_TASK_STATE_PEND_TIMEOUT_SUSPENDED:
;;;557                 switch (p_tcb->PendOn) {                       /* See what we are pending on                             */
;;;558                     case OS_TASK_PEND_ON_NOTHING:
;;;559                     case OS_TASK_PEND_ON_TASK_Q:               /* There is no wait list for these two                    */
;;;560                     case OS_TASK_PEND_ON_TASK_SEM:
;;;561                          break;
;;;562    
;;;563                     case OS_TASK_PEND_ON_FLAG:                 /* Remove from wait list                                  */
;;;564                     case OS_TASK_PEND_ON_MULTI:
;;;565                     case OS_TASK_PEND_ON_Q:
;;;566                     case OS_TASK_PEND_ON_SEM:
;;;567                          OS_PendListRemove(p_tcb);
;;;568                          break;
;;;569    
;;;570    #if OS_CFG_MUTEX_EN > 0u
;;;571                     case OS_TASK_PEND_ON_MUTEX:
;;;572                          p_tcb_owner = ((OS_MUTEX *)p_tcb->PendDataTblPtr->PendObjPtr)->OwnerTCBPtr;
;;;573                          prio_new = p_tcb_owner->Prio;
;;;574                          OS_PendListRemove(p_tcb);
;;;575                          if ((p_tcb_owner->Prio != p_tcb_owner->BasePrio) &&
;;;576                              (p_tcb_owner->Prio == p_tcb->Prio)) { /* Has the owner inherited a priority?                */
;;;577                              prio_new = OS_MutexGrpPrioFindHighest(p_tcb_owner);
;;;578                              prio_new = prio_new > p_tcb_owner->BasePrio ? p_tcb_owner->BasePrio : prio_new;
;;;579                          }
;;;580                          p_tcb->PendOn = OS_TASK_PEND_ON_NOTHING;
;;;581    
;;;582                          if (prio_new != p_tcb_owner->Prio) {
;;;583                              OS_TaskChangePrio(p_tcb_owner, prio_new);
;;;584    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN > 0u))
;;;585                              TRACE_OS_MUTEX_TASK_PRIO_DISINHERIT(p_tcb_owner, p_tcb_owner->Prio);
;;;586    #endif
;;;587                          }
;;;588                          break;
;;;589    #endif
;;;590    
;;;591                     default:
;;;592                          break;
;;;593                 }
;;;594                 if ((p_tcb->TaskState == OS_TASK_STATE_PEND_TIMEOUT) ||
;;;595                     (p_tcb->TaskState == OS_TASK_STATE_PEND_TIMEOUT_SUSPENDED)) {
;;;596                     OS_TickListRemove(p_tcb);
;;;597                 }
;;;598    
;;;599                 break;
;;;600    
;;;601            default:
;;;602                OS_CRITICAL_EXIT();
;;;603               *p_err = OS_ERR_STATE_INVALID;
;;;604                return;
;;;605        }
;;;606    
;;;607    #if OS_CFG_MUTEX_EN > 0u
;;;608        if(p_tcb->MutexGrpHeadPtr != (OS_MUTEX *)0) {
;;;609            OS_MutexGrpPostAll(p_tcb);
;;;610        }
;;;611    #endif
;;;612    
;;;613    #if OS_CFG_TASK_Q_EN > 0u
;;;614        (void)OS_MsgQFreeAll(&p_tcb->MsgQ);                     /* Free task's message queue messages                     */
;;;615    #endif
;;;616    
;;;617        OSTaskDelHook(p_tcb);                                   /* Call user defined hook                                 */
;;;618    
;;;619    #if defined(OS_CFG_TLS_TBL_SIZE) && (OS_CFG_TLS_TBL_SIZE > 0u)
;;;620        OS_TLS_TaskDel(p_tcb);                                  /* Call TLS hook                                          */
;;;621    #endif
;;;622    
;;;623    #if OS_CFG_DBG_EN > 0u
;;;624        OS_TaskDbgListRemove(p_tcb);
;;;625    #endif
;;;626        OSTaskQty--;                                            /* One less task being managed                            */
;;;627    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN > 0u))
;;;628        TRACE_OS_TASK_DEL(p_tcb);                               /* Record the event.                                      */
;;;629    #endif
;;;630        OS_TaskInitTCB(p_tcb);                                  /* Initialize the TCB to default values                   */
;;;631        p_tcb->TaskState = (OS_STATE)OS_TASK_STATE_DEL;         /* Indicate that the task was deleted                     */
;;;632    
;;;633        OS_CRITICAL_EXIT_NO_SCHED();
;;;634    
;;;635       *p_err = OS_ERR_NONE;                                    /* See Note #1.                                           */
;;;636    
;;;637        OSSched();                                              /* Find new highest priority task                         */
;;;638    }
000018  e8bd81f0          POP      {r4-r8,pc}
                  |L3.28|
00001c  b97c              CBNZ     r4,|L3.62|
00001e  bf00              NOP                            ;534
000020  bf00              NOP                            ;534
000022  f7fffffe          BL       CPU_SR_Save
000026  4680              MOV      r8,r0                 ;534
000028  bf00              NOP                            ;534
00002a  bf00              NOP                            ;534
00002c  4854              LDR      r0,|L3.384|
00002e  6804              LDR      r4,[r0,#0]            ;535  ; OSTCBCurPtr
000030  bf00              NOP                            ;536
000032  bf00              NOP                            ;536
000034  4640              MOV      r0,r8                 ;536
000036  f7fffffe          BL       CPU_SR_Restore
00003a  bf00              NOP                            ;536
00003c  bf00              NOP                            ;536
                  |L3.62|
00003e  bf00              NOP                            ;539
000040  bf00              NOP                            ;539
000042  f7fffffe          BL       CPU_SR_Save
000046  4680              MOV      r8,r0                 ;539
000048  bf00              NOP                            ;539
00004a  bf00              NOP                            ;539
00004c  f8940036          LDRB     r0,[r4,#0x36]         ;540
000050  2808              CMP      r0,#8                 ;540
000052  d260              BCS      |L3.278|
000054  e8dff000          TBB      [pc,r0]               ;540
000058  04090e10          DCB      0x04,0x09,0x0e,0x10
00005c  080a0f11          DCB      0x08,0x0a,0x0f,0x11
000060  4620              MOV      r0,r4                 ;542
000062  f7fffffe          BL       OS_RdyListRemove
000066  e061              B        |L3.300|
000068  e060              B        |L3.300|
00006a  bf00              NOP                            ;549
00006c  4620              MOV      r0,r4                 ;550
00006e  f7fffffe          BL       OS_TickListRemove
000072  e05b              B        |L3.300|
000074  bf00              NOP                            ;554
000076  bf00              NOP                            ;555
000078  bf00              NOP                            ;556
00007a  f8940034          LDRB     r0,[r4,#0x34]         ;557
00007e  2808              CMP      r0,#8                 ;557
000080  d23b              BCS      |L3.250|
000082  e8dff000          TBB      [pc,r0]               ;557
000086  0407              DCB      0x04,0x07
000088  05080e09          DCB      0x05,0x08,0x0e,0x09
00008c  0a06              DCB      0x0a,0x06
00008e  bf00              NOP                            ;559
000090  bf00              NOP                            ;560
000092  e033              B        |L3.252|
000094  bf00              NOP                            ;564
000096  bf00              NOP                            ;565
000098  bf00              NOP                            ;566
00009a  4620              MOV      r0,r4                 ;567
00009c  f7fffffe          BL       OS_PendListRemove
0000a0  e02c              B        |L3.252|
0000a2  6b20              LDR      r0,[r4,#0x30]         ;572
0000a4  68c0              LDR      r0,[r0,#0xc]          ;572
0000a6  6a45              LDR      r5,[r0,#0x24]         ;572
0000a8  f8157f37          LDRB     r7,[r5,#0x37]!        ;573
0000ac  4620              MOV      r0,r4                 ;574
0000ae  f7fffffe          BL       OS_PendListRemove
0000b2  7828              LDRB     r0,[r5,#0]            ;575
0000b4  7869              LDRB     r1,[r5,#1]            ;575
0000b6  3d37              SUBS     r5,r5,#0x37           ;575
0000b8  4288              CMP      r0,r1                 ;575
0000ba  d012              BEQ      |L3.226|
0000bc  f8950037          LDRB     r0,[r5,#0x37]         ;576
0000c0  f8941037          LDRB     r1,[r4,#0x37]         ;576
0000c4  4288              CMP      r0,r1                 ;576
0000c6  d10c              BNE      |L3.226|
0000c8  4628              MOV      r0,r5                 ;577
0000ca  f7fffffe          BL       OS_MutexGrpPrioFindHighest
0000ce  4607              MOV      r7,r0                 ;577
0000d0  f8950038          LDRB     r0,[r5,#0x38]         ;578
0000d4  42b8              CMP      r0,r7                 ;578
0000d6  da02              BGE      |L3.222|
0000d8  f8950038          LDRB     r0,[r5,#0x38]         ;578
0000dc  e000              B        |L3.224|
                  |L3.222|
0000de  4638              MOV      r0,r7                 ;578
                  |L3.224|
0000e0  4607              MOV      r7,r0                 ;578
                  |L3.226|
0000e2  2000              MOVS     r0,#0                 ;580
0000e4  f8840034          STRB     r0,[r4,#0x34]         ;580
0000e8  f8950037          LDRB     r0,[r5,#0x37]         ;582
0000ec  42b8              CMP      r0,r7                 ;582
0000ee  d003              BEQ      |L3.248|
0000f0  4639              MOV      r1,r7                 ;583
0000f2  4628              MOV      r0,r5                 ;583
0000f4  f7fffffe          BL       OS_TaskChangePrio
                  |L3.248|
0000f8  e000              B        |L3.252|
                  |L3.250|
0000fa  bf00              NOP                            ;592
                  |L3.252|
0000fc  bf00              NOP                            ;561
0000fe  f8940036          LDRB     r0,[r4,#0x36]         ;594
000102  2803              CMP      r0,#3                 ;594
000104  d003              BEQ      |L3.270|
000106  f8940036          LDRB     r0,[r4,#0x36]         ;595
00010a  2807              CMP      r0,#7                 ;595
00010c  d102              BNE      |L3.276|
                  |L3.270|
00010e  4620              MOV      r0,r4                 ;596
000110  f7fffffe          BL       OS_TickListRemove
                  |L3.276|
000114  e00a              B        |L3.300|
                  |L3.278|
000116  bf00              NOP                            ;602
000118  bf00              NOP                            ;602
00011a  4640              MOV      r0,r8                 ;602
00011c  f7fffffe          BL       CPU_SR_Restore
000120  bf00              NOP                            ;602
000122  bf00              NOP                            ;602
000124  f646602d          MOV      r0,#0x6e2d            ;603
000128  8030              STRH     r0,[r6,#0]            ;603
00012a  e775              B        |L3.24|
                  |L3.300|
00012c  bf00              NOP                            ;543
00012e  6be0              LDR      r0,[r4,#0x3c]         ;608
000130  b110              CBZ      r0,|L3.312|
000132  4620              MOV      r0,r4                 ;609
000134  f7fffffe          BL       OS_MutexGrpPostAll
                  |L3.312|
000138  f1040060          ADD      r0,r4,#0x60           ;614
00013c  f7fffffe          BL       OS_MsgQFreeAll
000140  4620              MOV      r0,r4                 ;617
000142  f7fffffe          BL       OSTaskDelHook
000146  4620              MOV      r0,r4                 ;624
000148  f7fffffe          BL       OS_TaskDbgListRemove
00014c  480d              LDR      r0,|L3.388|
00014e  8800              LDRH     r0,[r0,#0]            ;626  ; OSTaskQty
000150  1e40              SUBS     r0,r0,#1              ;626
000152  490c              LDR      r1,|L3.388|
000154  8008              STRH     r0,[r1,#0]            ;626
000156  4620              MOV      r0,r4                 ;630
000158  f7fffffe          BL       OS_TaskInitTCB
00015c  20ff              MOVS     r0,#0xff              ;631
00015e  f8840036          STRB     r0,[r4,#0x36]         ;631
000162  bf00              NOP                            ;633
000164  bf00              NOP                            ;633
000166  4640              MOV      r0,r8                 ;633
000168  f7fffffe          BL       CPU_SR_Restore
00016c  bf00              NOP                            ;633
00016e  bf00              NOP                            ;633
000170  2000              MOVS     r0,#0                 ;635
000172  8030              STRH     r0,[r6,#0]            ;635
000174  f7fffffe          BL       OSSched
000178  bf00              NOP      
00017a  e74d              B        |L3.24|
;;;639    #endif
                          ENDP

                  |L3.380|
                          DCD      OSIdleTaskTCB
                  |L3.384|
                          DCD      OSTCBCurPtr
                  |L3.388|
                          DCD      OSTaskQty

                          AREA ||i.OSTaskQFlush||, CODE, READONLY, ALIGN=2

                  OSTaskQFlush PROC
;;;665    #if OS_CFG_TASK_Q_EN > 0u
;;;666    OS_MSG_QTY  OSTaskQFlush (OS_TCB  *p_tcb,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;667                              OS_ERR  *p_err)
;;;668    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;669        OS_MSG_QTY  entries;
;;;670        CPU_SR_ALLOC();
000008  2600              MOVS     r6,#0
;;;671    
;;;672    
;;;673    
;;;674    #ifdef OS_SAFETY_CRITICAL
;;;675        if (p_err == (OS_ERR *)0) {
;;;676            OS_SAFETY_CRITICAL_EXCEPTION();
;;;677            return ((OS_MSG_QTY)0);
;;;678        }
;;;679    #endif
;;;680    
;;;681    #if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
;;;682        if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* Can't flush a message queue from an ISR                */
;;;683           *p_err = OS_ERR_FLUSH_ISR;
;;;684            return ((OS_MSG_QTY)0);
;;;685        }
;;;686    #endif
;;;687    
;;;688        if (p_tcb == (OS_TCB *)0) {                             /* Flush message queue of calling task?                   */
00000a  b97c              CBNZ     r4,|L4.44|
;;;689            CPU_CRITICAL_ENTER();
00000c  bf00              NOP      
00000e  bf00              NOP      
000010  f7fffffe          BL       CPU_SR_Save
000014  4606              MOV      r6,r0
000016  bf00              NOP      
000018  bf00              NOP      
;;;690            p_tcb = OSTCBCurPtr;
00001a  4810              LDR      r0,|L4.92|
00001c  6804              LDR      r4,[r0,#0]  ; OSTCBCurPtr
;;;691            CPU_CRITICAL_EXIT();
00001e  bf00              NOP      
000020  bf00              NOP      
000022  4630              MOV      r0,r6
000024  f7fffffe          BL       CPU_SR_Restore
000028  bf00              NOP      
00002a  bf00              NOP      
                  |L4.44|
;;;692        }
;;;693    
;;;694        OS_CRITICAL_ENTER();
00002c  bf00              NOP      
00002e  bf00              NOP      
000030  f7fffffe          BL       CPU_SR_Save
000034  4606              MOV      r6,r0
000036  bf00              NOP      
000038  bf00              NOP      
;;;695        entries = OS_MsgQFreeAll(&p_tcb->MsgQ);                 /* Return all OS_MSGs to the OS_MSG pool                  */
00003a  f1040060          ADD      r0,r4,#0x60
00003e  f7fffffe          BL       OS_MsgQFreeAll
000042  4607              MOV      r7,r0
;;;696        OS_CRITICAL_EXIT();
000044  bf00              NOP      
000046  bf00              NOP      
000048  4630              MOV      r0,r6
00004a  f7fffffe          BL       CPU_SR_Restore
00004e  bf00              NOP      
000050  bf00              NOP      
;;;697       *p_err   = OS_ERR_NONE;
000052  2000              MOVS     r0,#0
000054  8028              STRH     r0,[r5,#0]
;;;698        return (entries);
000056  4638              MOV      r0,r7
;;;699    }
000058  e8bd81f0          POP      {r4-r8,pc}
;;;700    #endif
                          ENDP

                  |L4.92|
                          DCD      OSTCBCurPtr

                          AREA ||i.OSTaskQPend||, CODE, READONLY, ALIGN=2

                  OSTaskQPend PROC
;;;743    #if OS_CFG_TASK_Q_EN > 0u
;;;744    void  *OSTaskQPend (OS_TICK       timeout,
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;745                        OS_OPT        opt,
;;;746                        OS_MSG_SIZE  *p_msg_size,
;;;747                        CPU_TS       *p_ts,
;;;748                        OS_ERR       *p_err)
;;;749    {
000004  4680              MOV      r8,r0
000006  460f              MOV      r7,r1
000008  4616              MOV      r6,r2
00000a  461c              MOV      r4,r3
00000c  9d0a              LDR      r5,[sp,#0x28]
;;;750        OS_MSG_Q     *p_msg_q;
;;;751        void         *p_void;
;;;752        CPU_SR_ALLOC();
00000e  f04f0b00          MOV      r11,#0
;;;753    
;;;754    
;;;755    
;;;756    #ifdef OS_SAFETY_CRITICAL
;;;757        if (p_err == (OS_ERR *)0) {
;;;758            OS_SAFETY_CRITICAL_EXCEPTION();
;;;759            return ((void *)0);
;;;760        }
;;;761    #endif
;;;762    
;;;763    #if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
;;;764        if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* Can't Pend from an ISR                                 */
;;;765           *p_err = OS_ERR_PEND_ISR;
;;;766            return ((void *)0);
;;;767        }
;;;768    #endif
;;;769    
;;;770    #if OS_CFG_ARG_CHK_EN > 0u                                  /* ---------------- VALIDATE ARGUMENTS ------------------ */
;;;771        if (p_msg_size == (OS_MSG_SIZE *)0) {                   /* User must supply a valid destination for msg size      */
000012  b92e              CBNZ     r6,|L5.32|
;;;772           *p_err = OS_ERR_PTR_INVALID;
000014  f24620d5          MOV      r0,#0x62d5
000018  8028              STRH     r0,[r5,#0]
;;;773            return ((void *)0);
00001a  2000              MOVS     r0,#0
                  |L5.28|
;;;774        }
;;;775        switch (opt) {                                          /* User must supply a valid option                        */
;;;776            case OS_OPT_PEND_BLOCKING:
;;;777            case OS_OPT_PEND_NON_BLOCKING:
;;;778                 break;
;;;779    
;;;780            default:
;;;781                *p_err = OS_ERR_OPT_INVALID;
;;;782                 return ((void *)0);
;;;783        }
;;;784    #endif
;;;785    
;;;786        if (p_ts != (CPU_TS *)0) {
;;;787           *p_ts  = (CPU_TS  )0;                                /* Initialize the returned timestamp                      */
;;;788        }
;;;789    
;;;790        CPU_CRITICAL_ENTER();
;;;791        p_msg_q = &OSTCBCurPtr->MsgQ;                           /* Any message waiting in the message queue?              */
;;;792        p_void  = OS_MsgQGet(p_msg_q,
;;;793                             p_msg_size,
;;;794                             p_ts,
;;;795                             p_err);
;;;796        if (*p_err == OS_ERR_NONE) {
;;;797    #if OS_CFG_TASK_PROFILE_EN > 0u
;;;798            if (p_ts != (CPU_TS *)0) {
;;;799                OSTCBCurPtr->MsgQPendTime = OS_TS_GET() - *p_ts;
;;;800                if (OSTCBCurPtr->MsgQPendTimeMax < OSTCBCurPtr->MsgQPendTime) {
;;;801                    OSTCBCurPtr->MsgQPendTimeMax = OSTCBCurPtr->MsgQPendTime;
;;;802                }
;;;803            }
;;;804    #endif
;;;805            CPU_CRITICAL_EXIT();
;;;806    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN > 0u))
;;;807            TRACE_OS_TASK_MSG_Q_PEND(p_msg_q);                  /* Record the event.                                      */
;;;808    #endif
;;;809            return (p_void);                                    /* Yes, Return oldest message received                    */
;;;810        }
;;;811    
;;;812        if ((opt & OS_OPT_PEND_NON_BLOCKING) != (OS_OPT)0) {    /* Caller wants to block if not available?                */
;;;813           *p_err = OS_ERR_PEND_WOULD_BLOCK;                    /* No                                                     */
;;;814            CPU_CRITICAL_EXIT();
;;;815    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN > 0u))
;;;816            TRACE_OS_TASK_MSG_Q_PEND_FAILED(p_msg_q);           /* Record the event.                                      */
;;;817    #endif
;;;818            return ((void *)0);
;;;819        } else {                                                /* Yes                                                    */
;;;820            if (OSSchedLockNestingCtr > (OS_NESTING_CTR)0) {    /*     Can't block when the scheduler is locked           */
;;;821                CPU_CRITICAL_EXIT();
;;;822    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN > 0u))
;;;823                TRACE_OS_TASK_MSG_Q_PEND_FAILED(p_msg_q);       /* Record the event.                                      */
;;;824    #endif
;;;825               *p_err = OS_ERR_SCHED_LOCKED;
;;;826                return ((void *)0);
;;;827            }
;;;828        }
;;;829                                                                /* Lock the scheduler/re-enable interrupts                */
;;;830        OS_CRITICAL_ENTER_CPU_EXIT();
;;;831        OS_Pend((OS_PEND_DATA *)0,                              /* Block task pending on Message                          */
;;;832                (OS_PEND_OBJ  *)0,
;;;833                (OS_STATE      )OS_TASK_PEND_ON_TASK_Q,
;;;834                (OS_TICK       )timeout);
;;;835        OS_CRITICAL_EXIT_NO_SCHED();
;;;836    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN > 0u))
;;;837        TRACE_OS_TASK_MSG_Q_PEND_BLOCK(p_msg_q);                /* Record the event.                                      */
;;;838    #endif
;;;839        OSSched();                                              /* Find the next highest priority task ready to run       */
;;;840    
;;;841        CPU_CRITICAL_ENTER();
;;;842        switch (OSTCBCurPtr->PendStatus) {
;;;843            case OS_STATUS_PEND_OK:                             /* Extract message from TCB (Put there by Post)           */
;;;844                 p_void      = OSTCBCurPtr->MsgPtr;
;;;845                *p_msg_size  = OSTCBCurPtr->MsgSize;
;;;846                 if (p_ts != (CPU_TS *)0) {
;;;847                    *p_ts  = OSTCBCurPtr->TS;
;;;848    #if OS_CFG_TASK_PROFILE_EN > 0u
;;;849                    OSTCBCurPtr->MsgQPendTime = OS_TS_GET() - OSTCBCurPtr->TS;
;;;850                    if (OSTCBCurPtr->MsgQPendTimeMax < OSTCBCurPtr->MsgQPendTime) {
;;;851                        OSTCBCurPtr->MsgQPendTimeMax = OSTCBCurPtr->MsgQPendTime;
;;;852                    }
;;;853    #endif
;;;854                 }
;;;855    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN > 0u))
;;;856                 TRACE_OS_TASK_MSG_Q_PEND(p_msg_q);             /* Record the event.                                      */
;;;857    #endif
;;;858                *p_err = OS_ERR_NONE;
;;;859                 break;
;;;860    
;;;861            case OS_STATUS_PEND_ABORT:                          /* Indicate that we aborted                               */
;;;862                 p_void     = (void      *)0;
;;;863                *p_msg_size = (OS_MSG_SIZE)0;
;;;864                 if (p_ts  != (CPU_TS *)0) {
;;;865                    *p_ts   = (CPU_TS  )0;
;;;866                 }
;;;867    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN > 0u))
;;;868                 TRACE_OS_TASK_MSG_Q_PEND_FAILED(p_msg_q);      /* Record the event.                                      */
;;;869    #endif
;;;870                *p_err      =  OS_ERR_PEND_ABORT;
;;;871                 break;
;;;872    
;;;873            case OS_STATUS_PEND_TIMEOUT:                        /* Indicate that we didn't get event within TO            */
;;;874            default:
;;;875                 p_void     = (void      *)0;
;;;876                *p_msg_size = (OS_MSG_SIZE)0;
;;;877                 if (p_ts  != (CPU_TS *)0) {
;;;878                    *p_ts   =  OSTCBCurPtr->TS;
;;;879                 }
;;;880    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN > 0u))
;;;881                 TRACE_OS_TASK_MSG_Q_PEND_FAILED(p_msg_q);      /* Record the event.                                      */
;;;882    #endif
;;;883                *p_err      =  OS_ERR_TIMEOUT;
;;;884                 break;
;;;885        }
;;;886        CPU_CRITICAL_EXIT();
;;;887        return (p_void);                                        /* Return received message                                */
;;;888    }
00001c  e8bd9ff0          POP      {r4-r12,pc}
                  |L5.32|
000020  b11f              CBZ      r7,|L5.42|
000022  f5b74f00          CMP      r7,#0x8000            ;775
000026  d102              BNE      |L5.46|
000028  e000              B        |L5.44|
                  |L5.42|
00002a  bf00              NOP                            ;777
                  |L5.44|
00002c  e004              B        |L5.56|
                  |L5.46|
00002e  f6456025          MOV      r0,#0x5e25            ;781
000032  8028              STRH     r0,[r5,#0]            ;781
000034  2000              MOVS     r0,#0                 ;782
000036  e7f1              B        |L5.28|
                  |L5.56|
000038  bf00              NOP                            ;778
00003a  b10c              CBZ      r4,|L5.64|
00003c  2000              MOVS     r0,#0                 ;787
00003e  6020              STR      r0,[r4,#0]            ;787
                  |L5.64|
000040  bf00              NOP                            ;790
000042  bf00              NOP                            ;790
000044  f7fffffe          BL       CPU_SR_Save
000048  4683              MOV      r11,r0                ;790
00004a  bf00              NOP                            ;790
00004c  bf00              NOP                            ;790
00004e  485a              LDR      r0,|L5.440|
000050  6800              LDR      r0,[r0,#0]            ;791  ; OSTCBCurPtr
000052  f1000960          ADD      r9,r0,#0x60           ;791
000056  462b              MOV      r3,r5                 ;792
000058  4622              MOV      r2,r4                 ;792
00005a  4631              MOV      r1,r6                 ;792
00005c  4648              MOV      r0,r9                 ;792
00005e  f7fffffe          BL       OS_MsgQGet
000062  4682              MOV      r10,r0                ;792
000064  8828              LDRH     r0,[r5,#0]            ;796
000066  b9f0              CBNZ     r0,|L5.166|
000068  b1a4              CBZ      r4,|L5.148|
00006a  f7fffffe          BL       CPU_TS_TmrRd
00006e  6821              LDR      r1,[r4,#0]            ;799
000070  1a40              SUBS     r0,r0,r1              ;799
000072  4951              LDR      r1,|L5.440|
000074  6809              LDR      r1,[r1,#0]            ;799  ; OSTCBCurPtr
000076  6708              STR      r0,[r1,#0x70]         ;799
000078  484f              LDR      r0,|L5.440|
00007a  6800              LDR      r0,[r0,#0]            ;800  ; OSTCBCurPtr
00007c  6f40              LDR      r0,[r0,#0x74]         ;800
00007e  494e              LDR      r1,|L5.440|
000080  6809              LDR      r1,[r1,#0]            ;800  ; OSTCBCurPtr
000082  6f09              LDR      r1,[r1,#0x70]         ;800
000084  4288              CMP      r0,r1                 ;800
000086  d205              BCS      |L5.148|
000088  484b              LDR      r0,|L5.440|
00008a  6800              LDR      r0,[r0,#0]            ;801  ; OSTCBCurPtr
00008c  6f00              LDR      r0,[r0,#0x70]         ;801
00008e  494a              LDR      r1,|L5.440|
000090  6809              LDR      r1,[r1,#0]            ;801  ; OSTCBCurPtr
000092  6748              STR      r0,[r1,#0x74]         ;801
                  |L5.148|
000094  bf00              NOP                            ;805
000096  bf00              NOP                            ;805
000098  4658              MOV      r0,r11                ;805
00009a  f7fffffe          BL       CPU_SR_Restore
00009e  bf00              NOP                            ;805
0000a0  bf00              NOP                            ;805
0000a2  4650              MOV      r0,r10                ;809
0000a4  e7ba              B        |L5.28|
                  |L5.166|
0000a6  f4074000          AND      r0,r7,#0x8000         ;812
0000aa  b158              CBZ      r0,|L5.196|
0000ac  f24610b0          MOV      r0,#0x61b0            ;813
0000b0  8028              STRH     r0,[r5,#0]            ;813
0000b2  bf00              NOP                            ;814
0000b4  bf00              NOP                            ;814
0000b6  4658              MOV      r0,r11                ;814
0000b8  f7fffffe          BL       CPU_SR_Restore
0000bc  bf00              NOP                            ;814
0000be  bf00              NOP                            ;814
0000c0  2000              MOVS     r0,#0                 ;818
0000c2  e7ab              B        |L5.28|
                  |L5.196|
0000c4  483d              LDR      r0,|L5.444|
0000c6  7800              LDRB     r0,[r0,#0]            ;820  ; OSSchedLockNestingCtr
0000c8  2800              CMP      r0,#0                 ;820
0000ca  dd0b              BLE      |L5.228|
0000cc  bf00              NOP                            ;821
0000ce  bf00              NOP                            ;821
0000d0  4658              MOV      r0,r11                ;821
0000d2  f7fffffe          BL       CPU_SR_Restore
0000d6  bf00              NOP                            ;821
0000d8  bf00              NOP                            ;821
0000da  f6465063          MOV      r0,#0x6d63            ;825
0000de  8028              STRH     r0,[r5,#0]            ;825
0000e0  2000              MOVS     r0,#0                 ;826
0000e2  e79b              B        |L5.28|
                  |L5.228|
0000e4  4643              MOV      r3,r8                 ;831
0000e6  2202              MOVS     r2,#2                 ;831
0000e8  2100              MOVS     r1,#0                 ;831
0000ea  4608              MOV      r0,r1                 ;831
0000ec  f7fffffe          BL       OS_Pend
0000f0  bf00              NOP                            ;835
0000f2  bf00              NOP                            ;835
0000f4  4658              MOV      r0,r11                ;835
0000f6  f7fffffe          BL       CPU_SR_Restore
0000fa  bf00              NOP                            ;835
0000fc  bf00              NOP                            ;835
0000fe  f7fffffe          BL       OSSched
000102  bf00              NOP                            ;841
000104  bf00              NOP                            ;841
000106  f7fffffe          BL       CPU_SR_Save
00010a  4683              MOV      r11,r0                ;841
00010c  bf00              NOP                            ;841
00010e  bf00              NOP                            ;841
000110  4829              LDR      r0,|L5.440|
000112  6800              LDR      r0,[r0,#0]            ;842  ; OSTCBCurPtr
000114  f8900035          LDRB     r0,[r0,#0x35]         ;842
000118  b120              CBZ      r0,|L5.292|
00011a  2801              CMP      r0,#1                 ;842
00011c  d02a              BEQ      |L5.372|
00011e  2803              CMP      r0,#3                 ;842
000120  d132              BNE      |L5.392|
000122  e032              B        |L5.394|
                  |L5.292|
000124  4824              LDR      r0,|L5.440|
000126  6800              LDR      r0,[r0,#0]            ;844  ; OSTCBCurPtr
000128  f8d0a058          LDR      r10,[r0,#0x58]        ;844
00012c  4822              LDR      r0,|L5.440|
00012e  6800              LDR      r0,[r0,#0]            ;845  ; OSTCBCurPtr
000130  f8b0005c          LDRH     r0,[r0,#0x5c]         ;845
000134  8030              STRH     r0,[r6,#0]            ;845
000136  b1d4              CBZ      r4,|L5.366|
000138  481f              LDR      r0,|L5.440|
00013a  6800              LDR      r0,[r0,#0]            ;847  ; OSTCBCurPtr
00013c  6c80              LDR      r0,[r0,#0x48]         ;847
00013e  6020              STR      r0,[r4,#0]            ;847
000140  f7fffffe          BL       CPU_TS_TmrRd
000144  491c              LDR      r1,|L5.440|
000146  6809              LDR      r1,[r1,#0]            ;849  ; OSTCBCurPtr
000148  6c89              LDR      r1,[r1,#0x48]         ;849
00014a  1a40              SUBS     r0,r0,r1              ;849
00014c  491a              LDR      r1,|L5.440|
00014e  6809              LDR      r1,[r1,#0]            ;849  ; OSTCBCurPtr
000150  6708              STR      r0,[r1,#0x70]         ;849
000152  4819              LDR      r0,|L5.440|
000154  6800              LDR      r0,[r0,#0]            ;850  ; OSTCBCurPtr
000156  6f40              LDR      r0,[r0,#0x74]         ;850
000158  4917              LDR      r1,|L5.440|
00015a  6809              LDR      r1,[r1,#0]            ;850  ; OSTCBCurPtr
00015c  6f09              LDR      r1,[r1,#0x70]         ;850
00015e  4288              CMP      r0,r1                 ;850
000160  d205              BCS      |L5.366|
000162  4815              LDR      r0,|L5.440|
000164  6800              LDR      r0,[r0,#0]            ;851  ; OSTCBCurPtr
000166  6f00              LDR      r0,[r0,#0x70]         ;851
000168  4913              LDR      r1,|L5.440|
00016a  6809              LDR      r1,[r1,#0]            ;851  ; OSTCBCurPtr
00016c  6748              STR      r0,[r1,#0x74]         ;851
                  |L5.366|
00016e  2000              MOVS     r0,#0                 ;858
000170  8028              STRH     r0,[r5,#0]            ;858
000172  e017              B        |L5.420|
                  |L5.372|
000174  f04f0a00          MOV      r10,#0                ;862
000178  2000              MOVS     r0,#0                 ;863
00017a  8030              STRH     r0,[r6,#0]            ;863
00017c  b104              CBZ      r4,|L5.384|
00017e  6020              STR      r0,[r4,#0]            ;865
                  |L5.384|
000180  f24610a9          MOV      r0,#0x61a9            ;870
000184  8028              STRH     r0,[r5,#0]            ;870
000186  e00d              B        |L5.420|
                  |L5.392|
000188  bf00              NOP                            ;873
                  |L5.394|
00018a  f04f0a00          MOV      r10,#0                ;875
00018e  2000              MOVS     r0,#0                 ;876
000190  8030              STRH     r0,[r6,#0]            ;876
000192  b11c              CBZ      r4,|L5.412|
000194  4808              LDR      r0,|L5.440|
000196  6800              LDR      r0,[r0,#0]            ;878  ; OSTCBCurPtr
000198  6c80              LDR      r0,[r0,#0x48]         ;878
00019a  6020              STR      r0,[r4,#0]            ;878
                  |L5.412|
00019c  f24720d9          MOV      r0,#0x72d9            ;883
0001a0  8028              STRH     r0,[r5,#0]            ;883
0001a2  bf00              NOP                            ;884
                  |L5.420|
0001a4  bf00              NOP                            ;859
0001a6  bf00              NOP                            ;886
0001a8  bf00              NOP                            ;886
0001aa  4658              MOV      r0,r11                ;886
0001ac  f7fffffe          BL       CPU_SR_Restore
0001b0  bf00              NOP                            ;886
0001b2  bf00              NOP                            ;886
0001b4  4650              MOV      r0,r10                ;887
0001b6  e731              B        |L5.28|
;;;889    #endif
                          ENDP

                  |L5.440|
                          DCD      OSTCBCurPtr
                  |L5.444|
                          DCD      OSSchedLockNestingCtr

                          AREA ||i.OSTaskQPendAbort||, CODE, READONLY, ALIGN=2

                  OSTaskQPendAbort PROC
;;;919    #if (OS_CFG_TASK_Q_EN > 0u) && (OS_CFG_TASK_Q_PEND_ABORT_EN > 0u)
;;;920    CPU_BOOLEAN  OSTaskQPendAbort (OS_TCB  *p_tcb,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;921                                   OS_OPT   opt,
;;;922                                   OS_ERR  *p_err)
;;;923    {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4615              MOV      r5,r2
;;;924        CPU_TS         ts;
;;;925        CPU_SR_ALLOC();
00000a  2700              MOVS     r7,#0
;;;926    
;;;927    
;;;928    
;;;929    #ifdef OS_SAFETY_CRITICAL
;;;930        if (p_err == (OS_ERR *)0) {
;;;931            OS_SAFETY_CRITICAL_EXCEPTION();
;;;932            return (DEF_FALSE);
;;;933        }
;;;934    #endif
;;;935    
;;;936    #if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
;;;937        if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* See if called from ISR ...                             */
;;;938           *p_err = OS_ERR_PEND_ABORT_ISR;                      /* ... can't Pend Abort from an ISR                       */
;;;939            return (DEF_FALSE);
;;;940        }
;;;941    #endif
;;;942    
;;;943    #if OS_CFG_ARG_CHK_EN > 0u                                  /* ---------------- VALIDATE ARGUMENTS ------------------ */
;;;944        switch (opt) {                                          /* User must supply a valid option                        */
00000c  b11e              CBZ      r6,|L6.22|
00000e  f5b64f00          CMP      r6,#0x8000
000012  d102              BNE      |L6.26|
000014  e000              B        |L6.24|
                  |L6.22|
;;;945            case OS_OPT_POST_NONE:
;;;946            case OS_OPT_POST_NO_SCHED:
000016  bf00              NOP      
                  |L6.24|
;;;947                 break;
000018  e005              B        |L6.38|
                  |L6.26|
;;;948    
;;;949            default:
;;;950                *p_err = OS_ERR_OPT_INVALID;
00001a  f6456025          MOV      r0,#0x5e25
00001e  8028              STRH     r0,[r5,#0]
;;;951                 return (DEF_FALSE);
000020  2000              MOVS     r0,#0
                  |L6.34|
;;;952        }
;;;953    #endif
;;;954    
;;;955        CPU_CRITICAL_ENTER();
;;;956    #if OS_CFG_ARG_CHK_EN > 0u
;;;957        if ((p_tcb == (OS_TCB *)0) ||                           /* Pend abort self?                                       */
;;;958            (p_tcb == OSTCBCurPtr)) {
;;;959            CPU_CRITICAL_EXIT();
;;;960           *p_err = OS_ERR_PEND_ABORT_SELF;                     /* ... doesn't make sense                                 */
;;;961            return (DEF_FALSE);
;;;962        }
;;;963    #endif
;;;964    
;;;965        if (p_tcb->PendOn != OS_TASK_PEND_ON_TASK_Q) {          /* Is task waiting for a message?                         */
;;;966            CPU_CRITICAL_EXIT();                                /* No                                                     */
;;;967           *p_err = OS_ERR_PEND_ABORT_NONE;
;;;968            return (DEF_FALSE);
;;;969        }
;;;970    
;;;971        OS_CRITICAL_ENTER_CPU_EXIT();
;;;972        ts = OS_TS_GET();                                       /* Get timestamp of when the abort occurred               */
;;;973        OS_PendAbort((OS_PEND_OBJ *)0,                          /* Abort the pend                                         */
;;;974                     p_tcb,
;;;975                     ts);
;;;976        OS_CRITICAL_EXIT_NO_SCHED();
;;;977        if ((opt & OS_OPT_POST_NO_SCHED) == (OS_OPT)0) {
;;;978            OSSched();                                          /* Run the scheduler                                      */
;;;979        }
;;;980       *p_err = OS_ERR_NONE;
;;;981        return (DEF_TRUE);
;;;982    }
000022  e8bd81f0          POP      {r4-r8,pc}
                  |L6.38|
000026  bf00              NOP                            ;947
000028  bf00              NOP                            ;955
00002a  bf00              NOP                            ;955
00002c  f7fffffe          BL       CPU_SR_Save
000030  4607              MOV      r7,r0                 ;955
000032  bf00              NOP                            ;955
000034  bf00              NOP                            ;955
000036  b11c              CBZ      r4,|L6.64|
000038  481b              LDR      r0,|L6.168|
00003a  6800              LDR      r0,[r0,#0]            ;958  ; OSTCBCurPtr
00003c  4284              CMP      r4,r0                 ;958
00003e  d10b              BNE      |L6.88|
                  |L6.64|
000040  bf00              NOP                            ;959
000042  bf00              NOP                            ;959
000044  4638              MOV      r0,r7                 ;959
000046  f7fffffe          BL       CPU_SR_Restore
00004a  bf00              NOP                            ;959
00004c  bf00              NOP                            ;959
00004e  f24610ac          MOV      r0,#0x61ac            ;960
000052  8028              STRH     r0,[r5,#0]            ;960
000054  2000              MOVS     r0,#0                 ;961
000056  e7e4              B        |L6.34|
                  |L6.88|
000058  f8940034          LDRB     r0,[r4,#0x34]         ;965
00005c  2802              CMP      r0,#2                 ;965
00005e  d00b              BEQ      |L6.120|
000060  bf00              NOP                            ;966
000062  bf00              NOP                            ;966
000064  4638              MOV      r0,r7                 ;966
000066  f7fffffe          BL       CPU_SR_Restore
00006a  bf00              NOP                            ;966
00006c  bf00              NOP                            ;966
00006e  f24610ab          MOV      r0,#0x61ab            ;967
000072  8028              STRH     r0,[r5,#0]            ;967
000074  2000              MOVS     r0,#0                 ;968
000076  e7d4              B        |L6.34|
                  |L6.120|
000078  f7fffffe          BL       CPU_TS_TmrRd
00007c  4680              MOV      r8,r0                 ;972
00007e  4642              MOV      r2,r8                 ;973
000080  4621              MOV      r1,r4                 ;973
000082  2000              MOVS     r0,#0                 ;973
000084  f7fffffe          BL       OS_PendAbort
000088  bf00              NOP                            ;976
00008a  bf00              NOP                            ;976
00008c  4638              MOV      r0,r7                 ;976
00008e  f7fffffe          BL       CPU_SR_Restore
000092  bf00              NOP                            ;976
000094  bf00              NOP                            ;976
000096  f4064000          AND      r0,r6,#0x8000         ;977
00009a  b908              CBNZ     r0,|L6.160|
00009c  f7fffffe          BL       OSSched
                  |L6.160|
0000a0  2000              MOVS     r0,#0                 ;980
0000a2  8028              STRH     r0,[r5,#0]            ;980
0000a4  2001              MOVS     r0,#1                 ;981
0000a6  e7bc              B        |L6.34|
;;;983    #endif
                          ENDP

                  |L6.168|
                          DCD      OSTCBCurPtr

                          AREA ||i.OSTaskQPost||, CODE, READONLY, ALIGN=1

                  OSTaskQPost PROC
;;;1021   #if OS_CFG_TASK_Q_EN > 0u
;;;1022   void  OSTaskQPost (OS_TCB       *p_tcb,
000000  e92d47fc          PUSH     {r2-r10,lr}
;;;1023                      void         *p_void,
;;;1024                      OS_MSG_SIZE   msg_size,
;;;1025                      OS_OPT        opt,
;;;1026                      OS_ERR       *p_err)
;;;1027   {
000004  4607              MOV      r7,r0
000006  4688              MOV      r8,r1
000008  4691              MOV      r9,r2
00000a  461c              MOV      r4,r3
00000c  9d0a              LDR      r5,[sp,#0x28]
;;;1028       CPU_TS   ts;
;;;1029   
;;;1030   
;;;1031   
;;;1032   #ifdef OS_SAFETY_CRITICAL
;;;1033       if (p_err == (OS_ERR *)0) {
;;;1034   #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN > 0u))
;;;1035           TRACE_OS_TASK_MSG_Q_POST_FAILED(&p_tcb->MsgQ);      /* Record the event.                                      */
;;;1036   #endif
;;;1037           OS_SAFETY_CRITICAL_EXCEPTION();
;;;1038           return;
;;;1039       }
;;;1040   #endif
;;;1041   
;;;1042   #if OS_CFG_ARG_CHK_EN > 0u                                  /* ---------------- VALIDATE ARGUMENTS ------------------ */
;;;1043       switch (opt) {                                          /* User must supply a valid option                        */
00000e  b14c              CBZ      r4,|L7.36|
000010  2c10              CMP      r4,#0x10
000012  d008              BEQ      |L7.38|
000014  f5b44f00          CMP      r4,#0x8000
000018  d006              BEQ      |L7.40|
00001a  f5a44000          SUB      r0,r4,#0x8000
00001e  3810              SUBS     r0,r0,#0x10
000020  b920              CBNZ     r0,|L7.44|
000022  e002              B        |L7.42|
                  |L7.36|
;;;1044           case OS_OPT_POST_FIFO:
;;;1045           case OS_OPT_POST_LIFO:
000024  bf00              NOP      
                  |L7.38|
;;;1046           case OS_OPT_POST_FIFO | OS_OPT_POST_NO_SCHED:
000026  bf00              NOP      
                  |L7.40|
;;;1047           case OS_OPT_POST_LIFO | OS_OPT_POST_NO_SCHED:
000028  bf00              NOP      
                  |L7.42|
;;;1048                break;
00002a  e004              B        |L7.54|
                  |L7.44|
;;;1049   
;;;1050           default:
;;;1051   #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN > 0u))
;;;1052                TRACE_OS_TASK_MSG_Q_POST_FAILED(&p_tcb->MsgQ); /* Record the event.                                      */
;;;1053   #endif
;;;1054               *p_err = OS_ERR_OPT_INVALID;
00002c  f6456025          MOV      r0,#0x5e25
000030  8028              STRH     r0,[r5,#0]
                  |L7.50|
;;;1055                return;
;;;1056       }
;;;1057   #endif
;;;1058   
;;;1059       ts = OS_TS_GET();                                       /* Get timestamp                                          */
;;;1060   
;;;1061   #if OS_CFG_ISR_POST_DEFERRED_EN > 0u
;;;1062       if (OSIntNestingCtr > (OS_NESTING_CTR)0) {
;;;1063           OS_IntQPost((OS_OBJ_TYPE)OS_OBJ_TYPE_TASK_MSG,      /* Post to ISR queue                                      */
;;;1064                       (void      *)p_tcb,
;;;1065                       (void      *)p_void,
;;;1066                       (OS_MSG_SIZE)msg_size,
;;;1067                       (OS_FLAGS   )0,
;;;1068                       (OS_OPT     )opt,
;;;1069                       (CPU_TS     )ts,
;;;1070                       (OS_ERR    *)p_err);
;;;1071           return;
;;;1072       }
;;;1073   #endif
;;;1074   
;;;1075   #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN > 0u))
;;;1076       TRACE_OS_TASK_MSG_Q_POST(&p_tcb->MsgQ);                 /* Record the event.                                      */
;;;1077   #endif
;;;1078   
;;;1079       OS_TaskQPost(p_tcb,
;;;1080                    p_void,
;;;1081                    msg_size,
;;;1082                    opt,
;;;1083                    ts,
;;;1084                    p_err);
;;;1085   }
000032  e8bd87fc          POP      {r2-r10,pc}
                  |L7.54|
000036  bf00              NOP                            ;1048
000038  f7fffffe          BL       CPU_TS_TmrRd
00003c  4606              MOV      r6,r0                 ;1059
00003e  4623              MOV      r3,r4                 ;1079
000040  464a              MOV      r2,r9                 ;1079
000042  4641              MOV      r1,r8                 ;1079
000044  4638              MOV      r0,r7                 ;1079
000046  e9cd6500          STRD     r6,r5,[sp,#0]         ;1079
00004a  f7fffffe          BL       OS_TaskQPost
00004e  bf00              NOP      
000050  e7ef              B        |L7.50|
;;;1086   #endif
                          ENDP


                          AREA ||i.OSTaskRegGet||, CODE, READONLY, ALIGN=2

                  OSTaskRegGet PROC
;;;1112   #if OS_CFG_TASK_REG_TBL_SIZE > 0u
;;;1113   OS_REG  OSTaskRegGet (OS_TCB     *p_tcb,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1114                         OS_REG_ID   id,
;;;1115                         OS_ERR     *p_err)
;;;1116   {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
;;;1117       OS_REG     value;
;;;1118       CPU_SR_ALLOC();
00000a  f04f0800          MOV      r8,#0
;;;1119   
;;;1120   
;;;1121   
;;;1122   #ifdef OS_SAFETY_CRITICAL
;;;1123       if (p_err == (OS_ERR *)0) {
;;;1124           OS_SAFETY_CRITICAL_EXCEPTION();
;;;1125           return ((OS_REG)0);
;;;1126       }
;;;1127   #endif
;;;1128   
;;;1129   #if OS_CFG_ARG_CHK_EN > 0u
;;;1130       if (id >= OS_CFG_TASK_REG_TBL_SIZE) {
00000e  b12d              CBZ      r5,|L8.28|
;;;1131          *p_err = OS_ERR_REG_ID_INVALID;
000010  f6461079          MOV      r0,#0x6979
000014  8030              STRH     r0,[r6,#0]
;;;1132           return ((OS_REG)0);
000016  2000              MOVS     r0,#0
                  |L8.24|
;;;1133       }
;;;1134   #endif
;;;1135   
;;;1136       CPU_CRITICAL_ENTER();
;;;1137       if (p_tcb == (OS_TCB *)0) {
;;;1138           p_tcb = OSTCBCurPtr;
;;;1139       }
;;;1140       value = p_tcb->RegTbl[id];
;;;1141       CPU_CRITICAL_EXIT();
;;;1142      *p_err = OS_ERR_NONE;
;;;1143       return ((OS_REG)value);
;;;1144   }
000018  e8bd81f0          POP      {r4-r8,pc}
                  |L8.28|
00001c  bf00              NOP                            ;1136
00001e  bf00              NOP                            ;1136
000020  f7fffffe          BL       CPU_SR_Save
000024  4680              MOV      r8,r0                 ;1136
000026  bf00              NOP                            ;1136
000028  bf00              NOP                            ;1136
00002a  b90c              CBNZ     r4,|L8.48|
00002c  4808              LDR      r0,|L8.80|
00002e  6804              LDR      r4,[r0,#0]            ;1138  ; OSTCBCurPtr
                  |L8.48|
000030  f1040078          ADD      r0,r4,#0x78           ;1140
000034  f8507025          LDR      r7,[r0,r5,LSL #2]     ;1140
000038  bf00              NOP                            ;1141
00003a  bf00              NOP                            ;1141
00003c  4640              MOV      r0,r8                 ;1141
00003e  f7fffffe          BL       CPU_SR_Restore
000042  bf00              NOP                            ;1141
000044  bf00              NOP                            ;1141
000046  2000              MOVS     r0,#0                 ;1142
000048  8030              STRH     r0,[r6,#0]            ;1142
00004a  4638              MOV      r0,r7                 ;1143
00004c  e7e4              B        |L8.24|
;;;1145   #endif
                          ENDP

00004e  0000              DCW      0x0000
                  |L8.80|
                          DCD      OSTCBCurPtr

                          AREA ||i.OSTaskRegGetID||, CODE, READONLY, ALIGN=2

                  OSTaskRegGetID PROC
;;;1165   #if OS_CFG_TASK_REG_TBL_SIZE > 0u
;;;1166   OS_REG_ID  OSTaskRegGetID (OS_ERR  *p_err)
000000  b570              PUSH     {r4-r6,lr}
;;;1167   {
000002  4604              MOV      r4,r0
;;;1168       OS_REG_ID  id;
;;;1169       CPU_SR_ALLOC();
000004  2600              MOVS     r6,#0
;;;1170   
;;;1171   
;;;1172   
;;;1173   #ifdef OS_SAFETY_CRITICAL
;;;1174       if (p_err == (OS_ERR *)0) {
;;;1175           OS_SAFETY_CRITICAL_EXCEPTION();
;;;1176           return ((OS_REG_ID)OS_CFG_TASK_REG_TBL_SIZE);
;;;1177       }
;;;1178   #endif
;;;1179   
;;;1180       CPU_CRITICAL_ENTER();
000006  bf00              NOP      
000008  bf00              NOP      
00000a  f7fffffe          BL       CPU_SR_Save
00000e  4606              MOV      r6,r0
000010  bf00              NOP      
000012  bf00              NOP      
;;;1181       if (OSTaskRegNextAvailID >= OS_CFG_TASK_REG_TBL_SIZE) {       /* See if we exceeded the number of IDs available   */
000014  480f              LDR      r0,|L9.84|
000016  7800              LDRB     r0,[r0,#0]  ; OSTaskRegNextAvailID
000018  b158              CBZ      r0,|L9.50|
;;;1182          *p_err = OS_ERR_NO_MORE_ID_AVAIL;                          /* Yes, cannot allocate more task register IDs      */
00001a  f64510da          MOV      r0,#0x59da
00001e  8020              STRH     r0,[r4,#0]
;;;1183           CPU_CRITICAL_EXIT();
000020  bf00              NOP      
000022  bf00              NOP      
000024  4630              MOV      r0,r6
000026  f7fffffe          BL       CPU_SR_Restore
00002a  bf00              NOP      
00002c  bf00              NOP      
;;;1184           return ((OS_REG_ID)OS_CFG_TASK_REG_TBL_SIZE);
00002e  2001              MOVS     r0,#1
                  |L9.48|
;;;1185       }
;;;1186        
;;;1187       id    = OSTaskRegNextAvailID;                                 /* Assign the next available ID                     */
;;;1188       OSTaskRegNextAvailID++;                                       /* Increment available ID for next request          */
;;;1189       CPU_CRITICAL_EXIT();
;;;1190      *p_err = OS_ERR_NONE;
;;;1191       return (id);
;;;1192   }
000030  bd70              POP      {r4-r6,pc}
                  |L9.50|
000032  4808              LDR      r0,|L9.84|
000034  7805              LDRB     r5,[r0,#0]            ;1187  ; OSTaskRegNextAvailID
000036  7800              LDRB     r0,[r0,#0]            ;1188  ; OSTaskRegNextAvailID
000038  1c40              ADDS     r0,r0,#1              ;1188
00003a  4906              LDR      r1,|L9.84|
00003c  7008              STRB     r0,[r1,#0]            ;1188
00003e  bf00              NOP                            ;1189
000040  bf00              NOP                            ;1189
000042  4630              MOV      r0,r6                 ;1189
000044  f7fffffe          BL       CPU_SR_Restore
000048  bf00              NOP                            ;1189
00004a  bf00              NOP                            ;1189
00004c  2000              MOVS     r0,#0                 ;1190
00004e  8020              STRH     r0,[r4,#0]            ;1190
000050  4628              MOV      r0,r5                 ;1191
000052  e7ed              B        |L9.48|
;;;1193   #endif
                          ENDP

                  |L9.84|
                          DCD      OSTaskRegNextAvailID

                          AREA ||i.OSTaskRegSet||, CODE, READONLY, ALIGN=2

                  OSTaskRegSet PROC
;;;1221   #if OS_CFG_TASK_REG_TBL_SIZE > 0u
;;;1222   void  OSTaskRegSet (OS_TCB     *p_tcb,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1223                       OS_REG_ID   id,
;;;1224                       OS_REG      value,
;;;1225                       OS_ERR     *p_err)
;;;1226   {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4617              MOV      r7,r2
00000a  461e              MOV      r6,r3
;;;1227       CPU_SR_ALLOC();
00000c  f04f0800          MOV      r8,#0
;;;1228   
;;;1229   
;;;1230   
;;;1231   #ifdef OS_SAFETY_CRITICAL
;;;1232       if (p_err == (OS_ERR *)0) {
;;;1233           OS_SAFETY_CRITICAL_EXCEPTION();
;;;1234           return;
;;;1235       }
;;;1236   #endif
;;;1237   
;;;1238   #if OS_CFG_ARG_CHK_EN > 0u
;;;1239       if (id >= OS_CFG_TASK_REG_TBL_SIZE) {
000010  b125              CBZ      r5,|L10.28|
;;;1240          *p_err = OS_ERR_REG_ID_INVALID;
000012  f6461079          MOV      r0,#0x6979
000016  8030              STRH     r0,[r6,#0]
                  |L10.24|
;;;1241           return;
;;;1242       }
;;;1243   #endif
;;;1244   
;;;1245       CPU_CRITICAL_ENTER();
;;;1246       if (p_tcb == (OS_TCB *)0) {
;;;1247           p_tcb = OSTCBCurPtr;
;;;1248       }
;;;1249       p_tcb->RegTbl[id] = value;
;;;1250       CPU_CRITICAL_EXIT();
;;;1251      *p_err             = OS_ERR_NONE;
;;;1252   }
000018  e8bd81f0          POP      {r4-r8,pc}
                  |L10.28|
00001c  bf00              NOP                            ;1245
00001e  bf00              NOP                            ;1245
000020  f7fffffe          BL       CPU_SR_Save
000024  4680              MOV      r8,r0                 ;1245
000026  bf00              NOP                            ;1245
000028  bf00              NOP                            ;1245
00002a  b90c              CBNZ     r4,|L10.48|
00002c  4808              LDR      r0,|L10.80|
00002e  6804              LDR      r4,[r0,#0]            ;1247  ; OSTCBCurPtr
                  |L10.48|
000030  f1040078          ADD      r0,r4,#0x78           ;1249
000034  f8407025          STR      r7,[r0,r5,LSL #2]     ;1249
000038  bf00              NOP                            ;1250
00003a  bf00              NOP                            ;1250
00003c  4640              MOV      r0,r8                 ;1250
00003e  f7fffffe          BL       CPU_SR_Restore
000042  bf00              NOP                            ;1250
000044  bf00              NOP                            ;1250
000046  2000              MOVS     r0,#0                 ;1251
000048  8030              STRH     r0,[r6,#0]            ;1251
00004a  bf00              NOP      
00004c  e7e4              B        |L10.24|
;;;1253   #endif
                          ENDP

00004e  0000              DCW      0x0000
                  |L10.80|
                          DCD      OSTCBCurPtr

                          AREA ||i.OSTaskResume||, CODE, READONLY, ALIGN=2

                  OSTaskResume PROC
;;;1277   #if OS_CFG_TASK_SUSPEND_EN > 0u
;;;1278   void  OSTaskResume (OS_TCB  *p_tcb,
000000  b570              PUSH     {r4-r6,lr}
;;;1279                       OS_ERR  *p_err)
;;;1280   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1281       CPU_SR_ALLOC();
000006  2600              MOVS     r6,#0
;;;1282   
;;;1283   
;;;1284   
;;;1285   #ifdef OS_SAFETY_CRITICAL
;;;1286       if (p_err == (OS_ERR *)0) {
;;;1287           OS_SAFETY_CRITICAL_EXCEPTION();
;;;1288           return;
;;;1289       }
;;;1290   #endif
;;;1291   
;;;1292   #if (OS_CFG_ISR_POST_DEFERRED_EN   == 0u) && \
;;;1293       (OS_CFG_CALLED_FROM_ISR_CHK_EN >  0u)
;;;1294       if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* Not allowed to call from an ISR                        */
;;;1295          *p_err = OS_ERR_TASK_RESUME_ISR;
;;;1296           return;
;;;1297       }
;;;1298   #endif
;;;1299   
;;;1300   
;;;1301       CPU_CRITICAL_ENTER();
000008  bf00              NOP      
00000a  bf00              NOP      
00000c  f7fffffe          BL       CPU_SR_Save
000010  4606              MOV      r6,r0
000012  bf00              NOP      
000014  bf00              NOP      
;;;1302   #if OS_CFG_ARG_CHK_EN > 0u
;;;1303       if ((p_tcb == (OS_TCB *)0) ||                           /* We cannot resume 'self'                                */
000016  b11c              CBZ      r4,|L11.32|
;;;1304           (p_tcb == OSTCBCurPtr)) {
000018  480d              LDR      r0,|L11.80|
00001a  6800              LDR      r0,[r0,#0]  ; OSTCBCurPtr
00001c  4284              CMP      r4,r0
00001e  d10a              BNE      |L11.54|
                  |L11.32|
;;;1305           CPU_CRITICAL_EXIT();
000020  bf00              NOP      
000022  bf00              NOP      
000024  4630              MOV      r0,r6
000026  f7fffffe          BL       CPU_SR_Restore
00002a  bf00              NOP      
00002c  bf00              NOP      
;;;1306          *p_err  = OS_ERR_TASK_RESUME_SELF;
00002e  f2471057          MOV      r0,#0x7157
000032  8028              STRH     r0,[r5,#0]
                  |L11.52|
;;;1307           return;
;;;1308       }
;;;1309   #endif
;;;1310       CPU_CRITICAL_EXIT();
;;;1311   
;;;1312   #if OS_CFG_ISR_POST_DEFERRED_EN > 0u
;;;1313       if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* See if called from an ISR                              */
;;;1314           OS_IntQPost((OS_OBJ_TYPE)OS_OBJ_TYPE_TASK_RESUME,   /* Post to ISR queue                                      */
;;;1315                       (void      *)p_tcb,
;;;1316                       (void      *)0,
;;;1317                       (OS_MSG_SIZE)0,
;;;1318                       (OS_FLAGS   )0,
;;;1319                       (OS_OPT     )0,
;;;1320                       (CPU_TS     )0,
;;;1321                       (OS_ERR    *)p_err);
;;;1322           return;
;;;1323       }
;;;1324   #endif
;;;1325   
;;;1326       OS_TaskResume(p_tcb, p_err);
;;;1327   
;;;1328   #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN > 0u))
;;;1329       TRACE_OS_TASK_RESUME(p_tcb);                            /* Record the event.                                      */
;;;1330   #endif
;;;1331   }
000034  bd70              POP      {r4-r6,pc}
                  |L11.54|
000036  bf00              NOP                            ;1310
000038  bf00              NOP                            ;1310
00003a  4630              MOV      r0,r6                 ;1310
00003c  f7fffffe          BL       CPU_SR_Restore
000040  bf00              NOP                            ;1310
000042  bf00              NOP                            ;1310
000044  4629              MOV      r1,r5                 ;1326
000046  4620              MOV      r0,r4                 ;1326
000048  f7fffffe          BL       OS_TaskResume
00004c  bf00              NOP      
00004e  e7f1              B        |L11.52|
;;;1332   #endif
                          ENDP

                  |L11.80|
                          DCD      OSTCBCurPtr

                          AREA ||i.OSTaskSemPend||, CODE, READONLY, ALIGN=2

                  OSTaskSemPend PROC
;;;1367   
;;;1368   OS_SEM_CTR  OSTaskSemPend (OS_TICK   timeout,
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;1369                              OS_OPT    opt,
;;;1370                              CPU_TS   *p_ts,
;;;1371                              OS_ERR   *p_err)
;;;1372   {
000004  4680              MOV      r8,r0
000006  460e              MOV      r6,r1
000008  4614              MOV      r4,r2
00000a  461d              MOV      r5,r3
;;;1373       OS_SEM_CTR    ctr;
;;;1374       CPU_SR_ALLOC();
00000c  f04f0900          MOV      r9,#0
;;;1375   
;;;1376   
;;;1377   
;;;1378   #ifdef OS_SAFETY_CRITICAL
;;;1379       if (p_err == (OS_ERR *)0) {
;;;1380   #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN > 0u))
;;;1381           TRACE_OS_TASK_SEM_PEND_FAILED(OSTCBCurPtr);         /* Record the event.                                      */
;;;1382   #endif
;;;1383           OS_SAFETY_CRITICAL_EXCEPTION();
;;;1384           return ((OS_SEM_CTR)0);
;;;1385       }
;;;1386   #endif
;;;1387   
;;;1388   #if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
;;;1389       if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* Not allowed to call from an ISR                        */
;;;1390   #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN > 0u))
;;;1391           TRACE_OS_TASK_SEM_PEND_FAILED(OSTCBCurPtr);         /* Record the event.                                      */
;;;1392   #endif
;;;1393          *p_err = OS_ERR_PEND_ISR;
;;;1394           return ((OS_SEM_CTR)0);
;;;1395       }
;;;1396   #endif
;;;1397   
;;;1398   #if OS_CFG_ARG_CHK_EN > 0u
;;;1399       switch (opt) {                                          /* Validate 'opt'                                         */
000010  b11e              CBZ      r6,|L12.26|
000012  f5b64f00          CMP      r6,#0x8000
000016  d102              BNE      |L12.30|
000018  e000              B        |L12.28|
                  |L12.26|
;;;1400           case OS_OPT_PEND_BLOCKING:
;;;1401           case OS_OPT_PEND_NON_BLOCKING:
00001a  bf00              NOP      
                  |L12.28|
;;;1402                break;
00001c  e005              B        |L12.42|
                  |L12.30|
;;;1403   
;;;1404           default:
;;;1405   #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN > 0u))
;;;1406                TRACE_OS_TASK_SEM_PEND_FAILED(OSTCBCurPtr);    /* Record the event.                                      */
;;;1407   #endif
;;;1408               *p_err = OS_ERR_OPT_INVALID;
00001e  f6456025          MOV      r0,#0x5e25
000022  8028              STRH     r0,[r5,#0]
;;;1409                return ((OS_SEM_CTR)0);
000024  2000              MOVS     r0,#0
                  |L12.38|
;;;1410       }
;;;1411   #endif
;;;1412   
;;;1413       if (p_ts != (CPU_TS *)0) {
;;;1414          *p_ts  = (CPU_TS  )0;                                /* Initialize the returned timestamp                      */
;;;1415       }
;;;1416   
;;;1417       CPU_CRITICAL_ENTER();
;;;1418       if (OSTCBCurPtr->SemCtr > (OS_SEM_CTR)0) {              /* See if task already been signaled                      */
;;;1419           OSTCBCurPtr->SemCtr--;
;;;1420           ctr    = OSTCBCurPtr->SemCtr;
;;;1421           if (p_ts != (CPU_TS *)0) {
;;;1422              *p_ts  = OSTCBCurPtr->TS;
;;;1423           }
;;;1424   #if OS_CFG_TASK_PROFILE_EN > 0u
;;;1425           OSTCBCurPtr->SemPendTime = OS_TS_GET() - OSTCBCurPtr->TS;
;;;1426           if (OSTCBCurPtr->SemPendTimeMax < OSTCBCurPtr->SemPendTime) {
;;;1427               OSTCBCurPtr->SemPendTimeMax = OSTCBCurPtr->SemPendTime;
;;;1428           }
;;;1429   #endif
;;;1430           CPU_CRITICAL_EXIT();
;;;1431   #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN > 0u))
;;;1432           TRACE_OS_TASK_SEM_PEND(OSTCBCurPtr);                /* Record the event.                                      */
;;;1433   #endif
;;;1434          *p_err = OS_ERR_NONE;
;;;1435           return (ctr);
;;;1436       }
;;;1437   
;;;1438       if ((opt & OS_OPT_PEND_NON_BLOCKING) != (OS_OPT)0) {    /* Caller wants to block if not available?                */
;;;1439           CPU_CRITICAL_EXIT();        
;;;1440          *p_err = OS_ERR_PEND_WOULD_BLOCK;                    /* No                                                     */
;;;1441   #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN > 0u))
;;;1442           TRACE_OS_TASK_SEM_PEND_FAILED(OSTCBCurPtr);         /* Record the event.                                      */
;;;1443   #endif
;;;1444           return ((OS_SEM_CTR)0);
;;;1445       } else {                                                /* Yes                                                    */
;;;1446           if (OSSchedLockNestingCtr > (OS_NESTING_CTR)0) {    /* Can't pend when the scheduler is locked                */
;;;1447               CPU_CRITICAL_EXIT();
;;;1448   #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN > 0u))
;;;1449               TRACE_OS_TASK_SEM_PEND_FAILED(OSTCBCurPtr);     /* Record the event.                                      */
;;;1450   #endif
;;;1451              *p_err = OS_ERR_SCHED_LOCKED;
;;;1452               return ((OS_SEM_CTR)0);
;;;1453           }
;;;1454       }
;;;1455                                                               /* Lock the scheduler/re-enable interrupts                */
;;;1456       OS_CRITICAL_ENTER_CPU_EXIT();
;;;1457       OS_Pend((OS_PEND_DATA *)0,                              /* Block task pending on Signal                           */
;;;1458               (OS_PEND_OBJ  *)0,
;;;1459               (OS_STATE      )OS_TASK_PEND_ON_TASK_SEM,
;;;1460               (OS_TICK       )timeout);
;;;1461       OS_CRITICAL_EXIT_NO_SCHED();
;;;1462   #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN > 0u))
;;;1463       TRACE_OS_TASK_SEM_PEND_BLOCK(OSTCBCurPtr);              /* Record the event.                                      */
;;;1464   #endif
;;;1465       OSSched();                                              /* Find next highest priority task ready to run           */
;;;1466   
;;;1467       CPU_CRITICAL_ENTER();
;;;1468       switch (OSTCBCurPtr->PendStatus) {                      /* See if we timed-out or aborted                         */
;;;1469           case OS_STATUS_PEND_OK:
;;;1470                if (p_ts != (CPU_TS *)0) {
;;;1471                   *p_ts                    =  OSTCBCurPtr->TS;
;;;1472   #if OS_CFG_TASK_PROFILE_EN > 0u
;;;1473                   OSTCBCurPtr->SemPendTime = OS_TS_GET() - OSTCBCurPtr->TS;
;;;1474                   if (OSTCBCurPtr->SemPendTimeMax < OSTCBCurPtr->SemPendTime) {
;;;1475                       OSTCBCurPtr->SemPendTimeMax = OSTCBCurPtr->SemPendTime;
;;;1476                   }
;;;1477   #endif
;;;1478                }
;;;1479   #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN > 0u))
;;;1480                TRACE_OS_TASK_SEM_PEND(OSTCBCurPtr);           /* Record the event.                                      */
;;;1481   #endif
;;;1482               *p_err = OS_ERR_NONE;
;;;1483                break;
;;;1484   
;;;1485           case OS_STATUS_PEND_ABORT:
;;;1486                if (p_ts != (CPU_TS *)0) {
;;;1487                   *p_ts  =  OSTCBCurPtr->TS;
;;;1488                }
;;;1489   #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN > 0u))
;;;1490                TRACE_OS_TASK_SEM_PEND_FAILED(OSTCBCurPtr);    /* Record the event.                                      */
;;;1491   #endif
;;;1492               *p_err = OS_ERR_PEND_ABORT;                     /* Indicate that we aborted                               */
;;;1493                break;
;;;1494   
;;;1495           case OS_STATUS_PEND_TIMEOUT:
;;;1496                if (p_ts != (CPU_TS *)0) {
;;;1497                   *p_ts  = (CPU_TS  )0;
;;;1498                }
;;;1499   #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN > 0u))
;;;1500                TRACE_OS_TASK_SEM_PEND_FAILED(OSTCBCurPtr);    /* Record the event.                                      */
;;;1501   #endif
;;;1502               *p_err = OS_ERR_TIMEOUT;                        /* Indicate that we didn't get event within TO            */
;;;1503                break;
;;;1504   
;;;1505           default:
;;;1506   #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN > 0u))
;;;1507                TRACE_OS_TASK_SEM_PEND_FAILED(OSTCBCurPtr);    /* Record the event.                                      */
;;;1508   #endif
;;;1509               *p_err = OS_ERR_STATUS_INVALID;
;;;1510                break;
;;;1511       }
;;;1512       ctr = OSTCBCurPtr->SemCtr;
;;;1513       CPU_CRITICAL_EXIT();
;;;1514       return (ctr);
;;;1515   }
000026  e8bd87f0          POP      {r4-r10,pc}
                  |L12.42|
00002a  bf00              NOP                            ;1402
00002c  b10c              CBZ      r4,|L12.50|
00002e  2000              MOVS     r0,#0                 ;1414
000030  6020              STR      r0,[r4,#0]            ;1414
                  |L12.50|
000032  bf00              NOP                            ;1417
000034  bf00              NOP                            ;1417
000036  f7fffffe          BL       CPU_SR_Save
00003a  4681              MOV      r9,r0                 ;1417
00003c  bf00              NOP                            ;1417
00003e  bf00              NOP                            ;1417
000040  485f              LDR      r0,|L12.448|
000042  6800              LDR      r0,[r0,#0]            ;1418  ; OSTCBCurPtr
000044  6cc0              LDR      r0,[r0,#0x4c]         ;1418
000046  b3a8              CBZ      r0,|L12.180|
000048  485d              LDR      r0,|L12.448|
00004a  6800              LDR      r0,[r0,#0]            ;1419  ; OSTCBCurPtr
00004c  6cc0              LDR      r0,[r0,#0x4c]         ;1419
00004e  1e40              SUBS     r0,r0,#1              ;1419
000050  495b              LDR      r1,|L12.448|
000052  6809              LDR      r1,[r1,#0]            ;1419  ; OSTCBCurPtr
000054  64c8              STR      r0,[r1,#0x4c]         ;1419
000056  485a              LDR      r0,|L12.448|
000058  6800              LDR      r0,[r0,#0]            ;1420  ; OSTCBCurPtr
00005a  6cc7              LDR      r7,[r0,#0x4c]         ;1420
00005c  b11c              CBZ      r4,|L12.102|
00005e  4858              LDR      r0,|L12.448|
000060  6800              LDR      r0,[r0,#0]            ;1422  ; OSTCBCurPtr
000062  6c80              LDR      r0,[r0,#0x48]         ;1422
000064  6020              STR      r0,[r4,#0]            ;1422
                  |L12.102|
000066  f7fffffe          BL       CPU_TS_TmrRd
00006a  4955              LDR      r1,|L12.448|
00006c  6809              LDR      r1,[r1,#0]            ;1425  ; OSTCBCurPtr
00006e  6c89              LDR      r1,[r1,#0x48]         ;1425
000070  1a40              SUBS     r0,r0,r1              ;1425
000072  4953              LDR      r1,|L12.448|
000074  6809              LDR      r1,[r1,#0]            ;1425  ; OSTCBCurPtr
000076  f8c100a0          STR      r0,[r1,#0xa0]         ;1425
00007a  4851              LDR      r0,|L12.448|
00007c  6800              LDR      r0,[r0,#0]            ;1426  ; OSTCBCurPtr
00007e  f8d000a4          LDR      r0,[r0,#0xa4]         ;1426
000082  494f              LDR      r1,|L12.448|
000084  6809              LDR      r1,[r1,#0]            ;1426  ; OSTCBCurPtr
000086  f8d110a0          LDR      r1,[r1,#0xa0]         ;1426
00008a  4288              CMP      r0,r1                 ;1426
00008c  d207              BCS      |L12.158|
00008e  484c              LDR      r0,|L12.448|
000090  6800              LDR      r0,[r0,#0]            ;1427  ; OSTCBCurPtr
000092  f8d000a0          LDR      r0,[r0,#0xa0]         ;1427
000096  494a              LDR      r1,|L12.448|
000098  6809              LDR      r1,[r1,#0]            ;1427  ; OSTCBCurPtr
00009a  f8c100a4          STR      r0,[r1,#0xa4]         ;1427
                  |L12.158|
00009e  bf00              NOP                            ;1430
0000a0  bf00              NOP                            ;1430
0000a2  4648              MOV      r0,r9                 ;1430
0000a4  f7fffffe          BL       CPU_SR_Restore
0000a8  bf00              NOP                            ;1430
0000aa  bf00              NOP                            ;1430
0000ac  2000              MOVS     r0,#0                 ;1434
0000ae  8028              STRH     r0,[r5,#0]            ;1434
0000b0  4638              MOV      r0,r7                 ;1435
0000b2  e7b8              B        |L12.38|
                  |L12.180|
0000b4  e7ff              B        |L12.182|
                  |L12.182|
0000b6  f4064000          AND      r0,r6,#0x8000         ;1438
0000ba  b158              CBZ      r0,|L12.212|
0000bc  bf00              NOP                            ;1439
0000be  bf00              NOP                            ;1439
0000c0  4648              MOV      r0,r9                 ;1439
0000c2  f7fffffe          BL       CPU_SR_Restore
0000c6  bf00              NOP                            ;1439
0000c8  bf00              NOP                            ;1439
0000ca  f24610b0          MOV      r0,#0x61b0            ;1440
0000ce  8028              STRH     r0,[r5,#0]            ;1440
0000d0  2000              MOVS     r0,#0                 ;1444
0000d2  e7a8              B        |L12.38|
                  |L12.212|
0000d4  483b              LDR      r0,|L12.452|
0000d6  7800              LDRB     r0,[r0,#0]            ;1446  ; OSSchedLockNestingCtr
0000d8  2800              CMP      r0,#0                 ;1446
0000da  dd0b              BLE      |L12.244|
0000dc  bf00              NOP                            ;1447
0000de  bf00              NOP                            ;1447
0000e0  4648              MOV      r0,r9                 ;1447
0000e2  f7fffffe          BL       CPU_SR_Restore
0000e6  bf00              NOP                            ;1447
0000e8  bf00              NOP                            ;1447
0000ea  f6465063          MOV      r0,#0x6d63            ;1451
0000ee  8028              STRH     r0,[r5,#0]            ;1451
0000f0  2000              MOVS     r0,#0                 ;1452
0000f2  e798              B        |L12.38|
                  |L12.244|
0000f4  4643              MOV      r3,r8                 ;1457
0000f6  2207              MOVS     r2,#7                 ;1457
0000f8  2100              MOVS     r1,#0                 ;1457
0000fa  4608              MOV      r0,r1                 ;1457
0000fc  f7fffffe          BL       OS_Pend
000100  bf00              NOP                            ;1461
000102  bf00              NOP                            ;1461
000104  4648              MOV      r0,r9                 ;1461
000106  f7fffffe          BL       CPU_SR_Restore
00010a  bf00              NOP                            ;1461
00010c  bf00              NOP                            ;1461
00010e  f7fffffe          BL       OSSched
000112  bf00              NOP                            ;1467
000114  bf00              NOP                            ;1467
000116  f7fffffe          BL       CPU_SR_Save
00011a  4681              MOV      r9,r0                 ;1467
00011c  bf00              NOP                            ;1467
00011e  bf00              NOP                            ;1467
000120  4827              LDR      r0,|L12.448|
000122  6800              LDR      r0,[r0,#0]            ;1468  ; OSTCBCurPtr
000124  f8900035          LDRB     r0,[r0,#0x35]         ;1468
000128  b120              CBZ      r0,|L12.308|
00012a  2801              CMP      r0,#1                 ;1468
00012c  d026              BEQ      |L12.380|
00012e  2803              CMP      r0,#3                 ;1468
000130  d134              BNE      |L12.412|
000132  e02c              B        |L12.398|
                  |L12.308|
000134  b1fc              CBZ      r4,|L12.374|
000136  4822              LDR      r0,|L12.448|
000138  6800              LDR      r0,[r0,#0]            ;1471  ; OSTCBCurPtr
00013a  6c80              LDR      r0,[r0,#0x48]         ;1471
00013c  6020              STR      r0,[r4,#0]            ;1471
00013e  f7fffffe          BL       CPU_TS_TmrRd
000142  491f              LDR      r1,|L12.448|
000144  6809              LDR      r1,[r1,#0]            ;1473  ; OSTCBCurPtr
000146  6c89              LDR      r1,[r1,#0x48]         ;1473
000148  1a40              SUBS     r0,r0,r1              ;1473
00014a  491d              LDR      r1,|L12.448|
00014c  6809              LDR      r1,[r1,#0]            ;1473  ; OSTCBCurPtr
00014e  f8c100a0          STR      r0,[r1,#0xa0]         ;1473
000152  481b              LDR      r0,|L12.448|
000154  6800              LDR      r0,[r0,#0]            ;1474  ; OSTCBCurPtr
000156  f8d000a4          LDR      r0,[r0,#0xa4]         ;1474
00015a  4919              LDR      r1,|L12.448|
00015c  6809              LDR      r1,[r1,#0]            ;1474  ; OSTCBCurPtr
00015e  f8d110a0          LDR      r1,[r1,#0xa0]         ;1474
000162  4288              CMP      r0,r1                 ;1474
000164  d207              BCS      |L12.374|
000166  4816              LDR      r0,|L12.448|
000168  6800              LDR      r0,[r0,#0]            ;1475  ; OSTCBCurPtr
00016a  f8d000a0          LDR      r0,[r0,#0xa0]         ;1475
00016e  4914              LDR      r1,|L12.448|
000170  6809              LDR      r1,[r1,#0]            ;1475  ; OSTCBCurPtr
000172  f8c100a4          STR      r0,[r1,#0xa4]         ;1475
                  |L12.374|
000176  2000              MOVS     r0,#0                 ;1482
000178  8028              STRH     r0,[r5,#0]            ;1482
00017a  e013              B        |L12.420|
                  |L12.380|
00017c  b11c              CBZ      r4,|L12.390|
00017e  4810              LDR      r0,|L12.448|
000180  6800              LDR      r0,[r0,#0]            ;1487  ; OSTCBCurPtr
000182  6c80              LDR      r0,[r0,#0x48]         ;1487
000184  6020              STR      r0,[r4,#0]            ;1487
                  |L12.390|
000186  f24610a9          MOV      r0,#0x61a9            ;1492
00018a  8028              STRH     r0,[r5,#0]            ;1492
00018c  e00a              B        |L12.420|
                  |L12.398|
00018e  b10c              CBZ      r4,|L12.404|
000190  2000              MOVS     r0,#0                 ;1497
000192  6020              STR      r0,[r4,#0]            ;1497
                  |L12.404|
000194  f24720d9          MOV      r0,#0x72d9            ;1502
000198  8028              STRH     r0,[r5,#0]            ;1502
00019a  e003              B        |L12.420|
                  |L12.412|
00019c  f646602e          MOV      r0,#0x6e2e            ;1509
0001a0  8028              STRH     r0,[r5,#0]            ;1509
0001a2  bf00              NOP                            ;1510
                  |L12.420|
0001a4  bf00              NOP                            ;1483
0001a6  4806              LDR      r0,|L12.448|
0001a8  6800              LDR      r0,[r0,#0]            ;1512  ; OSTCBCurPtr
0001aa  6cc7              LDR      r7,[r0,#0x4c]         ;1512
0001ac  bf00              NOP                            ;1513
0001ae  bf00              NOP                            ;1513
0001b0  4648              MOV      r0,r9                 ;1513
0001b2  f7fffffe          BL       CPU_SR_Restore
0001b6  bf00              NOP                            ;1513
0001b8  bf00              NOP                            ;1513
0001ba  4638              MOV      r0,r7                 ;1514
0001bc  e733              B        |L12.38|
;;;1516   
                          ENDP

0001be  0000              DCW      0x0000
                  |L12.448|
                          DCD      OSTCBCurPtr
                  |L12.452|
                          DCD      OSSchedLockNestingCtr

                          AREA ||i.OSTaskSemPendAbort||, CODE, READONLY, ALIGN=2

                  OSTaskSemPendAbort PROC
;;;1546   #if OS_CFG_TASK_SEM_PEND_ABORT_EN > 0u
;;;1547   CPU_BOOLEAN  OSTaskSemPendAbort (OS_TCB  *p_tcb,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1548                                    OS_OPT   opt,
;;;1549                                    OS_ERR  *p_err)
;;;1550   {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4615              MOV      r5,r2
;;;1551       CPU_TS         ts;
;;;1552       CPU_SR_ALLOC();
00000a  2700              MOVS     r7,#0
;;;1553   
;;;1554   
;;;1555   
;;;1556   #ifdef OS_SAFETY_CRITICAL
;;;1557       if (p_err == (OS_ERR *)0) {
;;;1558           OS_SAFETY_CRITICAL_EXCEPTION();
;;;1559           return (DEF_FALSE);
;;;1560       }
;;;1561   #endif
;;;1562   
;;;1563   #if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
;;;1564       if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* See if called from ISR ...                             */
;;;1565          *p_err = OS_ERR_PEND_ABORT_ISR;                      /* ... can't Pend Abort from an ISR                       */
;;;1566           return (DEF_FALSE);
;;;1567       }
;;;1568   #endif
;;;1569   
;;;1570   #if OS_CFG_ARG_CHK_EN > 0u
;;;1571       switch (opt) {                                          /* Validate 'opt'                                         */
00000c  b11e              CBZ      r6,|L13.22|
00000e  f5b64f00          CMP      r6,#0x8000
000012  d102              BNE      |L13.26|
000014  e000              B        |L13.24|
                  |L13.22|
;;;1572           case OS_OPT_POST_NONE:
;;;1573           case OS_OPT_POST_NO_SCHED:
000016  bf00              NOP      
                  |L13.24|
;;;1574                break;
000018  e005              B        |L13.38|
                  |L13.26|
;;;1575   
;;;1576           default:
;;;1577               *p_err =  OS_ERR_OPT_INVALID;
00001a  f6456025          MOV      r0,#0x5e25
00001e  8028              STRH     r0,[r5,#0]
;;;1578                return (DEF_FALSE);
000020  2000              MOVS     r0,#0
                  |L13.34|
;;;1579       }
;;;1580   #endif
;;;1581   
;;;1582       CPU_CRITICAL_ENTER();
;;;1583       if ((p_tcb == (OS_TCB *)0) ||                           /* Pend abort self?                                       */
;;;1584           (p_tcb == OSTCBCurPtr)) {
;;;1585           CPU_CRITICAL_EXIT();                                /* ... doesn't make sense!                                */
;;;1586          *p_err = OS_ERR_PEND_ABORT_SELF;
;;;1587           return (DEF_FALSE);
;;;1588       }
;;;1589   
;;;1590       if (p_tcb->PendOn != OS_TASK_PEND_ON_TASK_SEM) {        /* Is task waiting for a signal?                          */
;;;1591           CPU_CRITICAL_EXIT();
;;;1592          *p_err = OS_ERR_PEND_ABORT_NONE;
;;;1593           return (DEF_FALSE);
;;;1594       }
;;;1595       CPU_CRITICAL_EXIT();
;;;1596   
;;;1597       OS_CRITICAL_ENTER();
;;;1598       ts = OS_TS_GET();
;;;1599       OS_PendAbort((OS_PEND_OBJ *)0,
;;;1600                    p_tcb,
;;;1601                    ts);
;;;1602       OS_CRITICAL_EXIT_NO_SCHED();
;;;1603       if ((opt & OS_OPT_POST_NO_SCHED) == (OS_OPT)0) {
;;;1604           OSSched();                                          /* Run the scheduler                                      */
;;;1605       }
;;;1606      *p_err = OS_ERR_NONE;
;;;1607       return (DEF_TRUE);
;;;1608   }
000022  e8bd81f0          POP      {r4-r8,pc}
                  |L13.38|
000026  bf00              NOP                            ;1574
000028  bf00              NOP                            ;1582
00002a  bf00              NOP                            ;1582
00002c  f7fffffe          BL       CPU_SR_Save
000030  4607              MOV      r7,r0                 ;1582
000032  bf00              NOP                            ;1582
000034  bf00              NOP                            ;1582
000036  b11c              CBZ      r4,|L13.64|
000038  4822              LDR      r0,|L13.196|
00003a  6800              LDR      r0,[r0,#0]            ;1584  ; OSTCBCurPtr
00003c  4284              CMP      r4,r0                 ;1584
00003e  d10b              BNE      |L13.88|
                  |L13.64|
000040  bf00              NOP                            ;1585
000042  bf00              NOP                            ;1585
000044  4638              MOV      r0,r7                 ;1585
000046  f7fffffe          BL       CPU_SR_Restore
00004a  bf00              NOP                            ;1585
00004c  bf00              NOP                            ;1585
00004e  f24610ac          MOV      r0,#0x61ac            ;1586
000052  8028              STRH     r0,[r5,#0]            ;1586
000054  2000              MOVS     r0,#0                 ;1587
000056  e7e4              B        |L13.34|
                  |L13.88|
000058  f8940034          LDRB     r0,[r4,#0x34]         ;1590
00005c  2807              CMP      r0,#7                 ;1590
00005e  d00b              BEQ      |L13.120|
000060  bf00              NOP                            ;1591
000062  bf00              NOP                            ;1591
000064  4638              MOV      r0,r7                 ;1591
000066  f7fffffe          BL       CPU_SR_Restore
00006a  bf00              NOP                            ;1591
00006c  bf00              NOP                            ;1591
00006e  f24610ab          MOV      r0,#0x61ab            ;1592
000072  8028              STRH     r0,[r5,#0]            ;1592
000074  2000              MOVS     r0,#0                 ;1593
000076  e7d4              B        |L13.34|
                  |L13.120|
000078  bf00              NOP                            ;1595
00007a  bf00              NOP                            ;1595
00007c  4638              MOV      r0,r7                 ;1595
00007e  f7fffffe          BL       CPU_SR_Restore
000082  bf00              NOP                            ;1595
000084  bf00              NOP                            ;1595
000086  bf00              NOP                            ;1597
000088  bf00              NOP                            ;1597
00008a  f7fffffe          BL       CPU_SR_Save
00008e  4607              MOV      r7,r0                 ;1597
000090  bf00              NOP                            ;1597
000092  bf00              NOP                            ;1597
000094  f7fffffe          BL       CPU_TS_TmrRd
000098  4680              MOV      r8,r0                 ;1598
00009a  4642              MOV      r2,r8                 ;1599
00009c  4621              MOV      r1,r4                 ;1599
00009e  2000              MOVS     r0,#0                 ;1599
0000a0  f7fffffe          BL       OS_PendAbort
0000a4  bf00              NOP                            ;1602
0000a6  bf00              NOP                            ;1602
0000a8  4638              MOV      r0,r7                 ;1602
0000aa  f7fffffe          BL       CPU_SR_Restore
0000ae  bf00              NOP                            ;1602
0000b0  bf00              NOP                            ;1602
0000b2  f4064000          AND      r0,r6,#0x8000         ;1603
0000b6  b908              CBNZ     r0,|L13.188|
0000b8  f7fffffe          BL       OSSched
                  |L13.188|
0000bc  2000              MOVS     r0,#0                 ;1606
0000be  8028              STRH     r0,[r5,#0]            ;1606
0000c0  2001              MOVS     r0,#1                 ;1607
0000c2  e7ae              B        |L13.34|
;;;1609   #endif
                          ENDP

                  |L13.196|
                          DCD      OSTCBCurPtr

                          AREA ||i.OSTaskSemPost||, CODE, READONLY, ALIGN=1

                  OSTaskSemPost PROC
;;;1634   
;;;1635   OS_SEM_CTR  OSTaskSemPost (OS_TCB  *p_tcb,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1636                              OS_OPT   opt,
;;;1637                              OS_ERR  *p_err)
;;;1638   {
000004  4606              MOV      r6,r0
000006  460d              MOV      r5,r1
000008  4614              MOV      r4,r2
;;;1639       OS_SEM_CTR  ctr;
;;;1640       CPU_TS      ts;
;;;1641   
;;;1642   
;;;1643   
;;;1644   #ifdef OS_SAFETY_CRITICAL
;;;1645       if (p_err == (OS_ERR *)0) {
;;;1646   #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN > 0u))
;;;1647           TRACE_OS_TASK_SEM_POST_FAILED(p_tcb);               /* Record the event.                                      */
;;;1648   #endif
;;;1649           OS_SAFETY_CRITICAL_EXCEPTION();
;;;1650           return ((OS_SEM_CTR)0);
;;;1651       }
;;;1652   #endif
;;;1653   
;;;1654   #if OS_CFG_ARG_CHK_EN > 0u
;;;1655       switch (opt) {                                          /* Validate 'opt'                                         */
00000a  b11d              CBZ      r5,|L14.20|
00000c  f5b54f00          CMP      r5,#0x8000
000010  d102              BNE      |L14.24|
000012  e000              B        |L14.22|
                  |L14.20|
;;;1656           case OS_OPT_POST_NONE:
;;;1657           case OS_OPT_POST_NO_SCHED:
000014  bf00              NOP      
                  |L14.22|
;;;1658                break;
000016  e005              B        |L14.36|
                  |L14.24|
;;;1659   
;;;1660           default:
;;;1661   #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN > 0u))
;;;1662                TRACE_OS_TASK_SEM_POST_FAILED(p_tcb);          /* Record the event.                                      */
;;;1663   #endif
;;;1664               *p_err =  OS_ERR_OPT_INVALID;
000018  f6456025          MOV      r0,#0x5e25
00001c  8020              STRH     r0,[r4,#0]
;;;1665                return ((OS_SEM_CTR)0u);
00001e  2000              MOVS     r0,#0
                  |L14.32|
;;;1666       }
;;;1667   #endif
;;;1668   
;;;1669       ts = OS_TS_GET();                                       /* Get timestamp                                          */
;;;1670   
;;;1671   #if OS_CFG_ISR_POST_DEFERRED_EN > 0u
;;;1672       if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* See if called from an ISR                              */
;;;1673           OS_IntQPost((OS_OBJ_TYPE)OS_OBJ_TYPE_TASK_SIGNAL,   /* Post to ISR queue                                      */
;;;1674                       (void      *)p_tcb,
;;;1675                       (void      *)0,
;;;1676                       (OS_MSG_SIZE)0,
;;;1677                       (OS_FLAGS   )0,
;;;1678                       (OS_OPT     )0,
;;;1679                       (CPU_TS     )ts,
;;;1680                       (OS_ERR    *)p_err);
;;;1681           return ((OS_SEM_CTR)0);
;;;1682       }
;;;1683   #endif
;;;1684   
;;;1685   #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN > 0u))
;;;1686       TRACE_OS_TASK_SEM_POST(p_tcb);                          /* Record the event.                                      */
;;;1687   #endif
;;;1688   
;;;1689       ctr = OS_TaskSemPost(p_tcb,
;;;1690                            opt,
;;;1691                            ts,
;;;1692                            p_err);
;;;1693   
;;;1694       return (ctr);
;;;1695   }
000020  e8bd81f0          POP      {r4-r8,pc}
                  |L14.36|
000024  bf00              NOP                            ;1658
000026  f7fffffe          BL       CPU_TS_TmrRd
00002a  4680              MOV      r8,r0                 ;1669
00002c  4623              MOV      r3,r4                 ;1689
00002e  4642              MOV      r2,r8                 ;1689
000030  4629              MOV      r1,r5                 ;1689
000032  4630              MOV      r0,r6                 ;1689
000034  f7fffffe          BL       OS_TaskSemPost
000038  4607              MOV      r7,r0                 ;1689
00003a  4638              MOV      r0,r7                 ;1694
00003c  e7f0              B        |L14.32|
;;;1696   
                          ENDP


                          AREA ||i.OSTaskSemSet||, CODE, READONLY, ALIGN=2

                  OSTaskSemSet PROC
;;;1717   
;;;1718   OS_SEM_CTR  OSTaskSemSet (OS_TCB      *p_tcb,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1719                             OS_SEM_CTR   cnt,
;;;1720                             OS_ERR      *p_err)
;;;1721   {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
;;;1722       OS_SEM_CTR  ctr;
;;;1723       CPU_SR_ALLOC();
00000a  f04f0800          MOV      r8,#0
;;;1724   
;;;1725   
;;;1726   
;;;1727   #ifdef OS_SAFETY_CRITICAL
;;;1728       if (p_err == (OS_ERR *)0) {
;;;1729           OS_SAFETY_CRITICAL_EXCEPTION();
;;;1730           return ((OS_SEM_CTR)0);
;;;1731       }
;;;1732   #endif
;;;1733   
;;;1734   #if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
;;;1735       if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* Not allowed to call from an ISR                        */
;;;1736          *p_err = OS_ERR_SET_ISR;
;;;1737           return ((OS_SEM_CTR)0);
;;;1738       }
;;;1739   #endif
;;;1740   
;;;1741       CPU_CRITICAL_ENTER();
00000e  bf00              NOP      
000010  bf00              NOP      
000012  f7fffffe          BL       CPU_SR_Save
000016  4680              MOV      r8,r0
000018  bf00              NOP      
00001a  bf00              NOP      
;;;1742       if (p_tcb == (OS_TCB *)0) {
00001c  b90c              CBNZ     r4,|L15.34|
;;;1743           p_tcb = OSTCBCurPtr;
00001e  4808              LDR      r0,|L15.64|
000020  6804              LDR      r4,[r0,#0]  ; OSTCBCurPtr
                  |L15.34|
;;;1744       }
;;;1745       ctr           = p_tcb->SemCtr;
000022  6ce7              LDR      r7,[r4,#0x4c]
;;;1746       p_tcb->SemCtr = (OS_SEM_CTR)cnt;
000024  64e5              STR      r5,[r4,#0x4c]
;;;1747       CPU_CRITICAL_EXIT();
000026  bf00              NOP      
000028  bf00              NOP      
00002a  4640              MOV      r0,r8
00002c  f7fffffe          BL       CPU_SR_Restore
000030  bf00              NOP      
000032  bf00              NOP      
;;;1748      *p_err         =  OS_ERR_NONE;
000034  2000              MOVS     r0,#0
000036  8030              STRH     r0,[r6,#0]
;;;1749       return (ctr);
000038  4638              MOV      r0,r7
;;;1750   }
00003a  e8bd81f0          POP      {r4-r8,pc}
;;;1751   
                          ENDP

00003e  0000              DCW      0x0000
                  |L15.64|
                          DCD      OSTCBCurPtr

                          AREA ||i.OSTaskStkChk||, CODE, READONLY, ALIGN=2

                  OSTaskStkChk PROC
;;;1777   #if OS_CFG_STAT_TASK_STK_CHK_EN > 0u
;;;1778   void  OSTaskStkChk (OS_TCB        *p_tcb,
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;1779                       CPU_STK_SIZE  *p_free,
;;;1780                       CPU_STK_SIZE  *p_used,
;;;1781                       OS_ERR        *p_err)
;;;1782   {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
00000a  461d              MOV      r5,r3
;;;1783       CPU_STK_SIZE  free_stk;
;;;1784       CPU_STK      *p_stk;
;;;1785       CPU_SR_ALLOC();
00000c  f04f0a00          MOV      r10,#0
;;;1786   
;;;1787   
;;;1788   
;;;1789   #ifdef OS_SAFETY_CRITICAL
;;;1790       if (p_err == (OS_ERR *)0) {
;;;1791           OS_SAFETY_CRITICAL_EXCEPTION();
;;;1792           return;
;;;1793       }
;;;1794   #endif
;;;1795   
;;;1796   #if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
;;;1797       if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* See if trying to check stack from ISR                  */
;;;1798          *p_err = OS_ERR_TASK_STK_CHK_ISR;
;;;1799           return;
;;;1800       }
;;;1801   #endif
;;;1802   
;;;1803   #if OS_CFG_ARG_CHK_EN > 0u
;;;1804       if (p_free == (CPU_STK_SIZE*)0) {                       /* User must specify valid destinations for the sizes     */
000010  b926              CBNZ     r6,|L16.28|
;;;1805          *p_err  = OS_ERR_PTR_INVALID;
000012  f24620d5          MOV      r0,#0x62d5
000016  8028              STRH     r0,[r5,#0]
                  |L16.24|
;;;1806           return;
;;;1807       }
;;;1808   
;;;1809       if (p_used == (CPU_STK_SIZE*)0) {
;;;1810          *p_err  = OS_ERR_PTR_INVALID;
;;;1811           return;
;;;1812       }
;;;1813   #endif
;;;1814   
;;;1815       CPU_CRITICAL_ENTER();
;;;1816       if (p_tcb == (OS_TCB *)0) {                             /* Check the stack of the current task?                   */
;;;1817           p_tcb = OSTCBCurPtr;                                /* Yes                                                    */
;;;1818       }
;;;1819   
;;;1820       if (p_tcb->StkPtr == (CPU_STK*)0) {                     /* Make sure task exist                                   */
;;;1821           CPU_CRITICAL_EXIT();
;;;1822          *p_free = (CPU_STK_SIZE)0;
;;;1823          *p_used = (CPU_STK_SIZE)0;
;;;1824          *p_err  =  OS_ERR_TASK_NOT_EXIST;
;;;1825           return;
;;;1826       }
;;;1827   
;;;1828       if ((p_tcb->Opt & OS_OPT_TASK_STK_CHK) == (OS_OPT)0) {  /* Make sure stack checking option is set                 */
;;;1829           CPU_CRITICAL_EXIT();
;;;1830          *p_free = (CPU_STK_SIZE)0;
;;;1831          *p_used = (CPU_STK_SIZE)0;
;;;1832          *p_err  =  OS_ERR_TASK_OPT;
;;;1833           return;
;;;1834       }
;;;1835       CPU_CRITICAL_EXIT();
;;;1836   
;;;1837       free_stk  = 0u;
;;;1838   #if CPU_CFG_STK_GROWTH == CPU_STK_GROWTH_HI_TO_LO
;;;1839       p_stk = p_tcb->StkBasePtr;                              /* Start at the lowest memory and go up                   */
;;;1840       while (*p_stk == (CPU_STK)0) {                          /* Compute the number of zero entries on the stk          */
;;;1841           p_stk++;
;;;1842           free_stk++;
;;;1843       }
;;;1844   #else
;;;1845       p_stk = p_tcb->StkBasePtr + p_tcb->StkSize - 1u;        /* Start at the highest memory and go down                */
;;;1846       while (*p_stk == (CPU_STK)0) {
;;;1847           free_stk++;
;;;1848           p_stk--;
;;;1849       }
;;;1850   #endif
;;;1851      *p_free = free_stk;
;;;1852      *p_used = (p_tcb->StkSize - free_stk);                   /* Compute number of entries used on the stack            */
;;;1853      *p_err  = OS_ERR_NONE;
;;;1854   }
000018  e8bd87f0          POP      {r4-r10,pc}
                  |L16.28|
00001c  b91f              CBNZ     r7,|L16.38|
00001e  f24620d5          MOV      r0,#0x62d5            ;1810
000022  8028              STRH     r0,[r5,#0]            ;1810
000024  e7f8              B        |L16.24|
                  |L16.38|
000026  bf00              NOP                            ;1815
000028  bf00              NOP                            ;1815
00002a  f7fffffe          BL       CPU_SR_Save
00002e  4682              MOV      r10,r0                ;1815
000030  bf00              NOP                            ;1815
000032  bf00              NOP                            ;1815
000034  b90c              CBNZ     r4,|L16.58|
000036  4821              LDR      r0,|L16.188|
000038  6804              LDR      r4,[r0,#0]            ;1817  ; OSTCBCurPtr
                  |L16.58|
00003a  6820              LDR      r0,[r4,#0]            ;1820
00003c  b968              CBNZ     r0,|L16.90|
00003e  bf00              NOP                            ;1821
000040  bf00              NOP                            ;1821
000042  4650              MOV      r0,r10                ;1821
000044  f7fffffe          BL       CPU_SR_Restore
000048  bf00              NOP                            ;1821
00004a  bf00              NOP                            ;1821
00004c  2000              MOVS     r0,#0                 ;1822
00004e  6030              STR      r0,[r6,#0]            ;1822
000050  6038              STR      r0,[r7,#0]            ;1823
000052  f2471052          MOV      r0,#0x7152            ;1824
000056  8028              STRH     r0,[r5,#0]            ;1824
000058  e7de              B        |L16.24|
                  |L16.90|
00005a  f8940044          LDRB     r0,[r4,#0x44]         ;1828
00005e  f0000001          AND      r0,r0,#1              ;1828
000062  b968              CBNZ     r0,|L16.128|
000064  bf00              NOP                            ;1829
000066  bf00              NOP                            ;1829
000068  4650              MOV      r0,r10                ;1829
00006a  f7fffffe          BL       CPU_SR_Restore
00006e  bf00              NOP                            ;1829
000070  bf00              NOP                            ;1829
000072  2000              MOVS     r0,#0                 ;1830
000074  6030              STR      r0,[r6,#0]            ;1830
000076  6038              STR      r0,[r7,#0]            ;1831
000078  f2471054          MOV      r0,#0x7154            ;1832
00007c  8028              STRH     r0,[r5,#0]            ;1832
00007e  e7cb              B        |L16.24|
                  |L16.128|
000080  bf00              NOP                            ;1835
000082  bf00              NOP                            ;1835
000084  4650              MOV      r0,r10                ;1835
000086  f7fffffe          BL       CPU_SR_Restore
00008a  bf00              NOP                            ;1835
00008c  bf00              NOP                            ;1835
00008e  f04f0800          MOV      r8,#0                 ;1837
000092  f8d49024          LDR      r9,[r4,#0x24]         ;1839
000096  e003              B        |L16.160|
                  |L16.152|
000098  f1090904          ADD      r9,r9,#4              ;1841
00009c  f1080801          ADD      r8,r8,#1              ;1842
                  |L16.160|
0000a0  f8d90000          LDR      r0,[r9,#0]            ;1840
0000a4  2800              CMP      r0,#0                 ;1840
0000a6  d0f7              BEQ      |L16.152|
0000a8  f8c68000          STR      r8,[r6,#0]            ;1851
0000ac  6c20              LDR      r0,[r4,#0x40]         ;1852
0000ae  eba00008          SUB      r0,r0,r8              ;1852
0000b2  6038              STR      r0,[r7,#0]            ;1852
0000b4  2000              MOVS     r0,#0                 ;1853
0000b6  8028              STRH     r0,[r5,#0]            ;1853
0000b8  bf00              NOP      
0000ba  e7ad              B        |L16.24|
;;;1855   #endif
                          ENDP

                  |L16.188|
                          DCD      OSTCBCurPtr

                          AREA ||i.OSTaskSuspend||, CODE, READONLY, ALIGN=2

                  OSTaskSuspend PROC
;;;1887   #if OS_CFG_TASK_SUSPEND_EN > 0u
;;;1888   void   OSTaskSuspend (OS_TCB  *p_tcb,
000000  b570              PUSH     {r4-r6,lr}
;;;1889                         OS_ERR  *p_err)
;;;1890   {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;1891   #ifdef OS_SAFETY_CRITICAL
;;;1892       if (p_err == (OS_ERR *)0) {
;;;1893           OS_SAFETY_CRITICAL_EXCEPTION();
;;;1894           return;
;;;1895       }
;;;1896   #endif
;;;1897   
;;;1898   #if (OS_CFG_ISR_POST_DEFERRED_EN   == 0u) && \
;;;1899       (OS_CFG_CALLED_FROM_ISR_CHK_EN >  0u)
;;;1900       if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* Not allowed to call from an ISR                        */
;;;1901          *p_err = OS_ERR_TASK_SUSPEND_ISR;
;;;1902           return;
;;;1903       }
;;;1904   #endif
;;;1905   
;;;1906       if (p_tcb == &OSIdleTaskTCB) {                          /* Make sure not suspending the idle task                 */
000006  4806              LDR      r0,|L17.32|
000008  4285              CMP      r5,r0
00000a  d103              BNE      |L17.20|
;;;1907          *p_err = OS_ERR_TASK_SUSPEND_IDLE;
00000c  f247105b          MOV      r0,#0x715b
000010  8020              STRH     r0,[r4,#0]
                  |L17.18|
;;;1908           return;
;;;1909       }
;;;1910   
;;;1911   #if OS_CFG_ISR_POST_DEFERRED_EN > 0u
;;;1912       if (p_tcb == &OSIntQTaskTCB) {                          /* Not allowed to suspend the ISR handler task            */
;;;1913          *p_err = OS_ERR_TASK_SUSPEND_INT_HANDLER;
;;;1914           return;
;;;1915       }
;;;1916   
;;;1917       if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* See if called from an ISR                              */
;;;1918           OS_IntQPost((OS_OBJ_TYPE)OS_OBJ_TYPE_TASK_SUSPEND,  /* Post to ISR queue                                      */
;;;1919                       (void      *)p_tcb,
;;;1920                       (void      *)0,
;;;1921                       (OS_MSG_SIZE)0,
;;;1922                       (OS_FLAGS   )0,
;;;1923                       (OS_OPT     )0,
;;;1924                       (CPU_TS     )0,
;;;1925                       (OS_ERR    *)p_err);
;;;1926           return;
;;;1927       }
;;;1928   #endif
;;;1929   
;;;1930       OS_TaskSuspend(p_tcb, p_err);
;;;1931   }
000012  bd70              POP      {r4-r6,pc}
                  |L17.20|
000014  4621              MOV      r1,r4                 ;1930
000016  4628              MOV      r0,r5                 ;1930
000018  f7fffffe          BL       OS_TaskSuspend
00001c  bf00              NOP      
00001e  e7f8              B        |L17.18|
;;;1932   #endif
                          ENDP

                  |L17.32|
                          DCD      OSIdleTaskTCB

                          AREA ||i.OS_TaskChangePrio||, CODE, READONLY, ALIGN=2

                  OS_TaskChangePrio PROC
;;;2736   
;;;2737   void  OS_TaskChangePrio(OS_TCB  *p_tcb,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;2738                           OS_PRIO  prio_new)
;;;2739   {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;2740       OS_TCB  *p_tcb_owner;
;;;2741   #if OS_CFG_MUTEX_EN > 0
;;;2742       OS_PRIO  prio_cur;
;;;2743   #endif
;;;2744   
;;;2745   
;;;2746       do {
000008  bf00              NOP      
                  |L18.10|
;;;2747           p_tcb_owner = (OS_TCB *)0;
00000a  2600              MOVS     r6,#0
;;;2748   #if OS_CFG_MUTEX_EN > 0
;;;2749           prio_cur    = p_tcb->Prio;
00000c  f8947037          LDRB     r7,[r4,#0x37]
;;;2750   #endif
;;;2751           switch (p_tcb->TaskState) {
000010  f8940036          LDRB     r0,[r4,#0x36]
000014  2808              CMP      r0,#8
000016  d25f              BCS      |L18.216|
000018  e8dff000          TBB      [pc,r0]
00001c  04191e1f          DCB      0x04,0x19,0x1e,0x1f
000020  1a1b2021          DCB      0x1a,0x1b,0x20,0x21
;;;2752               case OS_TASK_STATE_RDY:
;;;2753                    OS_RdyListRemove(p_tcb);                   /* Remove from current priority                           */
000024  4620              MOV      r0,r4
000026  f7fffffe          BL       OS_RdyListRemove
;;;2754                    p_tcb->Prio = prio_new;                    /* Set new task priority                                  */
00002a  f8845037          STRB     r5,[r4,#0x37]
;;;2755                    OS_PrioInsert(p_tcb->Prio);
00002e  f8940037          LDRB     r0,[r4,#0x37]
000032  f7fffffe          BL       OS_PrioInsert
;;;2756                    if (p_tcb == OSTCBCurPtr) {
000036  482c              LDR      r0,|L18.232|
000038  6800              LDR      r0,[r0,#0]  ; OSTCBCurPtr
00003a  4284              CMP      r4,r0
00003c  d103              BNE      |L18.70|
;;;2757                        OS_RdyListInsertHead(p_tcb);
00003e  4620              MOV      r0,r4
000040  f7fffffe          BL       OS_RdyListInsertHead
000044  e002              B        |L18.76|
                  |L18.70|
;;;2758                    } else {
;;;2759                        OS_RdyListInsertTail(p_tcb);
000046  4620              MOV      r0,r4
000048  f7fffffe          BL       OS_RdyListInsertTail
                  |L18.76|
;;;2760                    }
;;;2761                    break;
00004c  e046              B        |L18.220|
;;;2762   
;;;2763               case OS_TASK_STATE_DLY:                         /* Nothing to do except change the priority in the OS_TCB */
;;;2764               case OS_TASK_STATE_SUSPENDED:
00004e  bf00              NOP      
;;;2765               case OS_TASK_STATE_DLY_SUSPENDED:
000050  bf00              NOP      
;;;2766                    p_tcb->Prio = prio_new;                    /* Set new task priority                                  */
000052  f8845037          STRB     r5,[r4,#0x37]
;;;2767                    break;
000056  e041              B        |L18.220|
;;;2768   
;;;2769               case OS_TASK_STATE_PEND:
;;;2770               case OS_TASK_STATE_PEND_TIMEOUT:
000058  bf00              NOP      
;;;2771               case OS_TASK_STATE_PEND_SUSPENDED:
00005a  bf00              NOP      
;;;2772               case OS_TASK_STATE_PEND_TIMEOUT_SUSPENDED:
00005c  bf00              NOP      
;;;2773                    p_tcb->Prio = prio_new;                    /* Set new task priority                                  */
00005e  f8845037          STRB     r5,[r4,#0x37]
;;;2774                    switch (p_tcb->PendOn) {                   /* What to do depends on what we are pending on           */
000062  f8940034          LDRB     r0,[r4,#0x34]
000066  2808              CMP      r0,#8
000068  d231              BCS      |L18.206|
00006a  e8dff000          TBB      [pc,r0]
00006e  3004              DCB      0x30,0x04
000070  31050b06          DCB      0x31,0x05,0x0b,0x06
000074  0732              DCB      0x07,0x32
;;;2775                        case OS_TASK_PEND_ON_FLAG:
;;;2776                        case OS_TASK_PEND_ON_MULTI:
000076  bf00              NOP      
;;;2777                        case OS_TASK_PEND_ON_Q:
000078  bf00              NOP      
;;;2778                        case OS_TASK_PEND_ON_SEM:
00007a  bf00              NOP      
;;;2779                             OS_PendListChangePrio(p_tcb);
00007c  4620              MOV      r0,r4
00007e  f7fffffe          BL       OS_PendListChangePrio
;;;2780                             break;
000082  e027              B        |L18.212|
;;;2781   
;;;2782                        case OS_TASK_PEND_ON_MUTEX:
;;;2783   #if OS_CFG_MUTEX_EN > 0
;;;2784                             OS_PendListChangePrio(p_tcb);
000084  4620              MOV      r0,r4
000086  f7fffffe          BL       OS_PendListChangePrio
;;;2785                             p_tcb_owner = ((OS_MUTEX *)p_tcb->PendDataTblPtr->PendObjPtr)->OwnerTCBPtr;
00008a  6b20              LDR      r0,[r4,#0x30]
00008c  68c0              LDR      r0,[r0,#0xc]
00008e  6a46              LDR      r6,[r0,#0x24]
;;;2786                             if (prio_cur > prio_new) {         /* Are we increasing the priority?                        */
000090  42af              CMP      r7,r5
000092  dd05              BLE      |L18.160|
;;;2787                                 if (p_tcb_owner->Prio <= prio_new) {/* Yes, do we need to give this prio to the owner?   */
000094  f8960037          LDRB     r0,[r6,#0x37]
000098  42a8              CMP      r0,r5
00009a  dc17              BGT      |L18.204|
;;;2788                                     p_tcb_owner = (OS_TCB *)0;
00009c  2600              MOVS     r6,#0
00009e  e015              B        |L18.204|
                  |L18.160|
;;;2789                                 } else {
;;;2790   #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN > 0u))
;;;2791                                    TRACE_OS_MUTEX_TASK_PRIO_INHERIT(p_tcb_owner, prio_new);
;;;2792   #endif
;;;2793                                 }
;;;2794                             } else {
;;;2795                                 if (p_tcb_owner->Prio == prio_cur) {/* No, is it required to check for a lower prio?     */
0000a0  f8960037          LDRB     r0,[r6,#0x37]
0000a4  42b8              CMP      r0,r7
0000a6  d111              BNE      |L18.204|
;;;2796                                     prio_new = OS_MutexGrpPrioFindHighest(p_tcb_owner);
0000a8  4630              MOV      r0,r6
0000aa  f7fffffe          BL       OS_MutexGrpPrioFindHighest
0000ae  4605              MOV      r5,r0
;;;2797                                     prio_new = prio_new > p_tcb_owner->BasePrio ? p_tcb_owner->BasePrio : prio_new;
0000b0  f8960038          LDRB     r0,[r6,#0x38]
0000b4  42a8              CMP      r0,r5
0000b6  da02              BGE      |L18.190|
0000b8  f8960038          LDRB     r0,[r6,#0x38]
0000bc  e000              B        |L18.192|
                  |L18.190|
0000be  4628              MOV      r0,r5
                  |L18.192|
0000c0  4605              MOV      r5,r0
;;;2798                                     if (prio_new == p_tcb_owner->Prio) {
0000c2  f8960037          LDRB     r0,[r6,#0x37]
0000c6  42a8              CMP      r0,r5
0000c8  d100              BNE      |L18.204|
;;;2799                                         p_tcb_owner = (OS_TCB *)0;
0000ca  2600              MOVS     r6,#0
                  |L18.204|
;;;2800                                     } else {
;;;2801   #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN > 0u))
;;;2802                                        TRACE_OS_MUTEX_TASK_PRIO_DISINHERIT(p_tcb_owner, prio_new);
;;;2803   #endif
;;;2804                                     }
;;;2805                                 }
;;;2806                             }
;;;2807   #endif
;;;2808                            break;
0000cc  e002              B        |L18.212|
                  |L18.206|
;;;2809   
;;;2810                        case OS_TASK_PEND_ON_TASK_Q:
0000ce  bf00              NOP      
;;;2811                        case OS_TASK_PEND_ON_TASK_SEM:
0000d0  bf00              NOP      
;;;2812                        default:
;;;2813                             break;
0000d2  bf00              NOP      
                  |L18.212|
0000d4  bf00              NOP                            ;2780
;;;2814                    }
;;;2815                    break;
0000d6  e001              B        |L18.220|
                  |L18.216|
;;;2816   
;;;2817               default:
;;;2818                    return;
;;;2819           }
;;;2820           p_tcb = p_tcb_owner;
;;;2821       } while (p_tcb != (OS_TCB *)0);
;;;2822   }
0000d8  e8bd81f0          POP      {r4-r8,pc}
                  |L18.220|
0000dc  bf00              NOP                            ;2761
0000de  4634              MOV      r4,r6                 ;2820
0000e0  2c00              CMP      r4,#0                 ;2821
0000e2  d192              BNE      |L18.10|
0000e4  bf00              NOP      
0000e6  e7f7              B        |L18.216|
                          ENDP

                  |L18.232|
                          DCD      OSTCBCurPtr

                          AREA ||i.OS_TaskDbgListAdd||, CODE, READONLY, ALIGN=2

                  OS_TaskDbgListAdd PROC
;;;2011   #if OS_CFG_DBG_EN > 0u
;;;2012   void  OS_TaskDbgListAdd (OS_TCB  *p_tcb)
000000  2100              MOVS     r1,#0
;;;2013   {
;;;2014       p_tcb->DbgPrevPtr                = (OS_TCB *)0;
000002  f8c010b4          STR      r1,[r0,#0xb4]
;;;2015       if (OSTaskDbgListPtr == (OS_TCB *)0) {
000006  4909              LDR      r1,|L19.44|
000008  6809              LDR      r1,[r1,#0]  ; OSTaskDbgListPtr
00000a  b919              CBNZ     r1,|L19.20|
;;;2016           p_tcb->DbgNextPtr            = (OS_TCB *)0;
00000c  2100              MOVS     r1,#0
00000e  f8c010b8          STR      r1,[r0,#0xb8]
000012  e007              B        |L19.36|
                  |L19.20|
;;;2017       } else {
;;;2018           p_tcb->DbgNextPtr            =  OSTaskDbgListPtr;
000014  4905              LDR      r1,|L19.44|
000016  6809              LDR      r1,[r1,#0]  ; OSTaskDbgListPtr
000018  f8c010b8          STR      r1,[r0,#0xb8]
;;;2019           OSTaskDbgListPtr->DbgPrevPtr =  p_tcb;
00001c  4903              LDR      r1,|L19.44|
00001e  6809              LDR      r1,[r1,#0]  ; OSTaskDbgListPtr
000020  f8c100b4          STR      r0,[r1,#0xb4]
                  |L19.36|
;;;2020       }
;;;2021       OSTaskDbgListPtr                 =  p_tcb;
000024  4901              LDR      r1,|L19.44|
000026  6008              STR      r0,[r1,#0]  ; OSTaskDbgListPtr
;;;2022   }
000028  4770              BX       lr
;;;2023   
                          ENDP

00002a  0000              DCW      0x0000
                  |L19.44|
                          DCD      OSTaskDbgListPtr

                          AREA ||i.OS_TaskDbgListRemove||, CODE, READONLY, ALIGN=2

                  OS_TaskDbgListRemove PROC
;;;2025   
;;;2026   void  OS_TaskDbgListRemove (OS_TCB  *p_tcb)
000000  f8d020b4          LDR      r2,[r0,#0xb4]
;;;2027   {
;;;2028       OS_TCB  *p_tcb_next;
;;;2029       OS_TCB  *p_tcb_prev;
;;;2030   
;;;2031   
;;;2032       p_tcb_prev = p_tcb->DbgPrevPtr;
;;;2033       p_tcb_next = p_tcb->DbgNextPtr;
000004  f8d010b8          LDR      r1,[r0,#0xb8]
;;;2034   
;;;2035       if (p_tcb_prev == (OS_TCB *)0) {
000008  b94a              CBNZ     r2,|L20.30|
;;;2036           OSTaskDbgListPtr = p_tcb_next;
00000a  4b0d              LDR      r3,|L20.64|
00000c  6019              STR      r1,[r3,#0]  ; OSTaskDbgListPtr
;;;2037           if (p_tcb_next != (OS_TCB *)0) {
00000e  b111              CBZ      r1,|L20.22|
;;;2038               p_tcb_next->DbgPrevPtr = (OS_TCB *)0;
000010  2300              MOVS     r3,#0
000012  f8c130b4          STR      r3,[r1,#0xb4]
                  |L20.22|
;;;2039           }
;;;2040           p_tcb->DbgNextPtr = (OS_TCB *)0;
000016  2300              MOVS     r3,#0
000018  f8c030b8          STR      r3,[r0,#0xb8]
00001c  e00f              B        |L20.62|
                  |L20.30|
;;;2041   
;;;2042       } else if (p_tcb_next == (OS_TCB *)0) {
00001e  b929              CBNZ     r1,|L20.44|
;;;2043           p_tcb_prev->DbgNextPtr = (OS_TCB *)0;
000020  2300              MOVS     r3,#0
000022  f8c230b8          STR      r3,[r2,#0xb8]
;;;2044           p_tcb->DbgPrevPtr      = (OS_TCB *)0;
000026  f8c030b4          STR      r3,[r0,#0xb4]
00002a  e008              B        |L20.62|
                  |L20.44|
;;;2045   
;;;2046       } else {
;;;2047           p_tcb_prev->DbgNextPtr =  p_tcb_next;
00002c  f8c210b8          STR      r1,[r2,#0xb8]
;;;2048           p_tcb_next->DbgPrevPtr =  p_tcb_prev;
000030  f8c120b4          STR      r2,[r1,#0xb4]
;;;2049           p_tcb->DbgNextPtr      = (OS_TCB *)0;
000034  2300              MOVS     r3,#0
000036  f8c030b8          STR      r3,[r0,#0xb8]
;;;2050           p_tcb->DbgPrevPtr      = (OS_TCB *)0;
00003a  f8c030b4          STR      r3,[r0,#0xb4]
                  |L20.62|
;;;2051       }
;;;2052   }
00003e  4770              BX       lr
;;;2053   #endif
                          ENDP

                  |L20.64|
                          DCD      OSTaskDbgListPtr

                          AREA ||i.OS_TaskInit||, CODE, READONLY, ALIGN=2

                  OS_TaskInit PROC
;;;2072   
;;;2073   void  OS_TaskInit (OS_ERR  *p_err)
000000  2100              MOVS     r1,#0
;;;2074   {
;;;2075   #ifdef OS_SAFETY_CRITICAL
;;;2076       if (p_err == (OS_ERR *)0) {
;;;2077           OS_SAFETY_CRITICAL_EXCEPTION();
;;;2078           return;
;;;2079       }
;;;2080   #endif
;;;2081   
;;;2082   #if OS_CFG_DBG_EN > 0u
;;;2083       OSTaskDbgListPtr = (OS_TCB      *)0;
000002  4a04              LDR      r2,|L21.20|
000004  6011              STR      r1,[r2,#0]  ; OSTaskDbgListPtr
;;;2084   #endif
;;;2085   
;;;2086       OSTaskQty        = (OS_OBJ_QTY   )0;                    /* Clear the number of tasks                              */
000006  4a04              LDR      r2,|L21.24|
000008  8011              STRH     r1,[r2,#0]
;;;2087       OSTaskCtxSwCtr   = (OS_CTX_SW_CTR)0;                    /* Clear the context switch counter                       */
00000a  4a04              LDR      r2,|L21.28|
00000c  6011              STR      r1,[r2,#0]  ; OSTaskCtxSwCtr
;;;2088   
;;;2089      *p_err            = OS_ERR_NONE;
00000e  8001              STRH     r1,[r0,#0]
;;;2090   }
000010  4770              BX       lr
;;;2091   
                          ENDP

000012  0000              DCW      0x0000
                  |L21.20|
                          DCD      OSTaskDbgListPtr
                  |L21.24|
                          DCD      OSTaskQty
                  |L21.28|
                          DCD      OSTaskCtxSwCtr

                          AREA ||i.OS_TaskInitTCB||, CODE, READONLY, ALIGN=2

                  OS_TaskInitTCB PROC
;;;2106   
;;;2107   void  OS_TaskInitTCB (OS_TCB  *p_tcb)
000000  b570              PUSH     {r4-r6,lr}
;;;2108   {
000002  4604              MOV      r4,r0
;;;2109   #if OS_CFG_TASK_REG_TBL_SIZE > 0u
;;;2110       OS_REG_ID   reg_id;
;;;2111   #endif
;;;2112   #if defined(OS_CFG_TLS_TBL_SIZE) && (OS_CFG_TLS_TBL_SIZE > 0u)
;;;2113       OS_TLS_ID   id;
;;;2114   #endif
;;;2115   #if OS_CFG_TASK_PROFILE_EN > 0u
;;;2116       CPU_TS      ts;
;;;2117   #endif
;;;2118   
;;;2119   
;;;2120       p_tcb->StkPtr             = (CPU_STK       *)0;
000004  2000              MOVS     r0,#0
000006  6020              STR      r0,[r4,#0]
;;;2121   #if ((OS_CFG_DBG_EN > 0u) || (OS_CFG_STAT_TASK_STK_CHK_EN > 0u))
;;;2122       p_tcb->StkLimitPtr        = (CPU_STK       *)0;
000008  60a0              STR      r0,[r4,#8]
;;;2123   #endif
;;;2124   
;;;2125       p_tcb->ExtPtr             = (void          *)0;
00000a  6060              STR      r0,[r4,#4]
;;;2126   
;;;2127       p_tcb->NextPtr            = (OS_TCB        *)0;
00000c  60e0              STR      r0,[r4,#0xc]
;;;2128       p_tcb->PrevPtr            = (OS_TCB        *)0;
00000e  6120              STR      r0,[r4,#0x10]
;;;2129   
;;;2130       p_tcb->TickNextPtr        = (OS_TCB        *)0;
000010  6160              STR      r0,[r4,#0x14]
;;;2131       p_tcb->TickPrevPtr        = (OS_TCB        *)0;
000012  61a0              STR      r0,[r4,#0x18]
;;;2132       p_tcb->TickListPtr        = (OS_TICK_LIST  *)0;
000014  61e0              STR      r0,[r4,#0x1c]
;;;2133   
;;;2134   #if OS_CFG_DBG_EN > 0u
;;;2135       p_tcb->NamePtr            = (CPU_CHAR      *)((void *)"?Task");
000016  a026              ADR      r0,|L22.176|
000018  6220              STR      r0,[r4,#0x20]
;;;2136   #endif
;;;2137   
;;;2138   #if ((OS_CFG_DBG_EN > 0u) || (OS_CFG_STAT_TASK_STK_CHK_EN > 0u))
;;;2139       p_tcb->StkBasePtr         = (CPU_STK       *)0;
00001a  2000              MOVS     r0,#0
00001c  6260              STR      r0,[r4,#0x24]
;;;2140   #endif
;;;2141   
;;;2142   #if OS_CFG_DBG_EN > 0u
;;;2143       p_tcb->TaskEntryAddr      = (OS_TASK_PTR    )0;
00001e  62a0              STR      r0,[r4,#0x28]
;;;2144       p_tcb->TaskEntryArg       = (void          *)0;
000020  62e0              STR      r0,[r4,#0x2c]
;;;2145   #endif
;;;2146   
;;;2147   #if (OS_CFG_PEND_MULTI_EN > 0u)
;;;2148       p_tcb->PendDataTblPtr     = (OS_PEND_DATA  *)0;
;;;2149       p_tcb->PendDataTblEntries = (OS_OBJ_QTY     )0u;
;;;2150   #endif
;;;2151   
;;;2152       p_tcb->TS                 = (CPU_TS         )0u;
000022  64a0              STR      r0,[r4,#0x48]
;;;2153   
;;;2154   #if (OS_MSG_EN > 0u)
;;;2155       p_tcb->MsgPtr             = (void          *)0;
000024  65a0              STR      r0,[r4,#0x58]
;;;2156       p_tcb->MsgSize            = (OS_MSG_SIZE    )0u;
000026  f8a4005c          STRH     r0,[r4,#0x5c]
;;;2157   #endif
;;;2158   
;;;2159   #if OS_CFG_TASK_Q_EN > 0u
;;;2160       OS_MsgQInit(&p_tcb->MsgQ,
00002a  2100              MOVS     r1,#0
00002c  f1040060          ADD      r0,r4,#0x60
000030  f7fffffe          BL       OS_MsgQInit
;;;2161                   (OS_MSG_QTY)0u);
;;;2162   #if OS_CFG_TASK_PROFILE_EN > 0u
;;;2163       p_tcb->MsgQPendTime       = (CPU_TS         )0u;
000034  2000              MOVS     r0,#0
000036  6720              STR      r0,[r4,#0x70]
;;;2164       p_tcb->MsgQPendTimeMax    = (CPU_TS         )0u;
000038  6760              STR      r0,[r4,#0x74]
;;;2165   #endif
;;;2166   #endif
;;;2167   
;;;2168   #if OS_CFG_FLAG_EN > 0u
;;;2169       p_tcb->FlagsPend          = (OS_FLAGS       )0u;
00003a  67e0              STR      r0,[r4,#0x7c]
;;;2170       p_tcb->FlagsOpt           = (OS_OPT         )0u;
00003c  f8a40084          STRH     r0,[r4,#0x84]
;;;2171       p_tcb->FlagsRdy           = (OS_FLAGS       )0u;
000040  f8c40080          STR      r0,[r4,#0x80]
;;;2172   #endif
;;;2173   
;;;2174   #if OS_CFG_TASK_REG_TBL_SIZE > 0u
;;;2175       for (reg_id = 0u; reg_id < OS_CFG_TASK_REG_TBL_SIZE; reg_id++) {
000044  2500              MOVS     r5,#0
000046  e006              B        |L22.86|
                  |L22.72|
;;;2176           p_tcb->RegTbl[reg_id] = (OS_REG)0u;
000048  2100              MOVS     r1,#0
00004a  f1040078          ADD      r0,r4,#0x78
00004e  f8401025          STR      r1,[r0,r5,LSL #2]
000052  1c68              ADDS     r0,r5,#1              ;2175
000054  b2c5              UXTB     r5,r0                 ;2175
                  |L22.86|
000056  2d00              CMP      r5,#0                 ;2175
000058  d0f6              BEQ      |L22.72|
;;;2177       }
;;;2178   #endif
;;;2179   
;;;2180   #if defined(OS_CFG_TLS_TBL_SIZE) && (OS_CFG_TLS_TBL_SIZE > 0u)
;;;2181       for (id = 0u; id < OS_CFG_TLS_TBL_SIZE; id++) {
;;;2182           p_tcb->TLS_Tbl[id]    = (OS_TLS)0;
;;;2183       }
;;;2184   #endif
;;;2185   
;;;2186       p_tcb->SemCtr             = (OS_SEM_CTR     )0u;
00005a  2000              MOVS     r0,#0
00005c  3434              ADDS     r4,r4,#0x34
00005e  61a0              STR      r0,[r4,#0x18]
;;;2187   #if OS_CFG_TASK_PROFILE_EN > 0u
;;;2188       p_tcb->SemPendTime        = (CPU_TS         )0u;
000060  66e0              STR      r0,[r4,#0x6c]
;;;2189       p_tcb->SemPendTimeMax     = (CPU_TS         )0u;
000062  6720              STR      r0,[r4,#0x70]
;;;2190   #endif
;;;2191   
;;;2192   #if ((OS_CFG_DBG_EN > 0u) || (OS_CFG_STAT_TASK_STK_CHK_EN > 0u))
;;;2193       p_tcb->StkSize            = (CPU_STK_SIZE   )0u;
000064  60e0              STR      r0,[r4,#0xc]
;;;2194   #endif
;;;2195   
;;;2196   
;;;2197   #if OS_CFG_TASK_SUSPEND_EN > 0u
;;;2198       p_tcb->SuspendCtr         = (OS_NESTING_CTR )0u;
000066  f8840052          STRB     r0,[r4,#0x52]
;;;2199   #endif
;;;2200   
;;;2201   #if OS_CFG_STAT_TASK_STK_CHK_EN > 0u
;;;2202       p_tcb->StkFree            = (CPU_STK_SIZE   )0u;
00006a  67a0              STR      r0,[r4,#0x78]
;;;2203       p_tcb->StkUsed            = (CPU_STK_SIZE   )0u;
00006c  6760              STR      r0,[r4,#0x74]
;;;2204   #endif
;;;2205   
;;;2206       p_tcb->Opt                = (OS_OPT         )0u;
00006e  8220              STRH     r0,[r4,#0x10]
;;;2207   
;;;2208       p_tcb->TickRemain         = (OS_TICK        )0u;
000070  61e0              STR      r0,[r4,#0x1c]
;;;2209       p_tcb->TickCtrPrev        = (OS_TICK        )0u;
000072  6220              STR      r0,[r4,#0x20]
;;;2210   
;;;2211   #if OS_CFG_SCHED_ROUND_ROBIN_EN > 0u
;;;2212       p_tcb->TimeQuanta         = (OS_TICK        )0u;
;;;2213       p_tcb->TimeQuantaCtr      = (OS_TICK        )0u;
;;;2214   #endif
;;;2215   
;;;2216   #if OS_CFG_TASK_PROFILE_EN > 0u
;;;2217       p_tcb->CPUUsage           = (OS_CPU_USAGE   )0u;
000074  f8a40054          STRH     r0,[r4,#0x54]
;;;2218       p_tcb->CPUUsageMax        = (OS_CPU_USAGE   )0u;
000078  f8a40056          STRH     r0,[r4,#0x56]
;;;2219       p_tcb->CtxSwCtr           = (OS_CTX_SW_CTR  )0u;
00007c  65a0              STR      r0,[r4,#0x58]
;;;2220       p_tcb->CyclesDelta        = (CPU_TS         )0u;
00007e  65e0              STR      r0,[r4,#0x5c]
;;;2221       ts                        = OS_TS_GET();                /* Read the current timestamp and save                    */
000080  f7fffffe          BL       CPU_TS_TmrRd
000084  4606              MOV      r6,r0
;;;2222       p_tcb->CyclesStart        = ts;
000086  6626              STR      r6,[r4,#0x60]
;;;2223       p_tcb->CyclesTotal        = (OS_CYCLES      )0u;
000088  2000              MOVS     r0,#0
00008a  6660              STR      r0,[r4,#0x64]
;;;2224   #endif
;;;2225   #ifdef CPU_CFG_INT_DIS_MEAS_EN
;;;2226       p_tcb->IntDisTimeMax      = (CPU_TS         )0u;
;;;2227   #endif
;;;2228   #if OS_CFG_SCHED_LOCK_TIME_MEAS_EN > 0u
;;;2229       p_tcb->SchedLockTimeMax   = (CPU_TS         )0u;
00008c  67e0              STR      r0,[r4,#0x7c]
;;;2230   #endif
;;;2231   
;;;2232       p_tcb->PendOn             = (OS_STATE       )OS_TASK_PEND_ON_NOTHING;
00008e  7020              STRB     r0,[r4,#0]
;;;2233       p_tcb->PendStatus         = (OS_STATUS      )OS_STATUS_PEND_OK;
000090  7060              STRB     r0,[r4,#1]
;;;2234       p_tcb->TaskState          = (OS_STATE       )OS_TASK_STATE_RDY;
000092  70a0              STRB     r0,[r4,#2]
;;;2235   
;;;2236       p_tcb->Prio               = (OS_PRIO        )OS_PRIO_INIT;
000094  2040              MOVS     r0,#0x40
000096  70e0              STRB     r0,[r4,#3]
;;;2237   #if OS_CFG_MUTEX_EN > 0u
;;;2238       p_tcb->BasePrio           = (OS_PRIO        )OS_PRIO_INIT;
000098  7120              STRB     r0,[r4,#4]
;;;2239       p_tcb->MutexGrpHeadPtr    = (OS_MUTEX      *)0;
00009a  2000              MOVS     r0,#0
00009c  60a0              STR      r0,[r4,#8]
;;;2240   #endif
;;;2241   
;;;2242   #if OS_CFG_DBG_EN > 0u
;;;2243       p_tcb->DbgPrevPtr         = (OS_TCB        *)0;
00009e  f8c40080          STR      r0,[r4,#0x80]
;;;2244       p_tcb->DbgNextPtr         = (OS_TCB        *)0;
0000a2  f8c40084          STR      r0,[r4,#0x84]
;;;2245       p_tcb->DbgNamePtr         = (CPU_CHAR      *)((void *)" ");
0000a6  a004              ADR      r0,|L22.184|
0000a8  f8c40088          STR      r0,[r4,#0x88]
0000ac  3c34              SUBS     r4,r4,#0x34
;;;2246   #endif
;;;2247   }
0000ae  bd70              POP      {r4-r6,pc}
;;;2248   
                          ENDP

                  |L22.176|
0000b0  3f546173          DCB      "?Task",0
0000b4  6b00    
0000b6  00                DCB      0
0000b7  00                DCB      0
                  |L22.184|
0000b8  2000              DCB      " ",0
0000ba  00                DCB      0
0000bb  00                DCB      0

                          AREA ||i.OS_TaskQPost||, CODE, READONLY, ALIGN=2

                  OS_TaskQPost PROC
;;;2291   #if OS_CFG_TASK_Q_EN > 0u
;;;2292   void  OS_TaskQPost (OS_TCB       *p_tcb,
000000  e92d47fc          PUSH     {r2-r10,lr}
;;;2293                       void         *p_void,
;;;2294                       OS_MSG_SIZE   msg_size,
;;;2295                       OS_OPT        opt,
;;;2296                       CPU_TS        ts,
;;;2297                       OS_ERR       *p_err)
;;;2298   {
000004  4604              MOV      r4,r0
000006  460f              MOV      r7,r1
000008  4690              MOV      r8,r2
00000a  4699              MOV      r9,r3
00000c  e9dd650a          LDRD     r6,r5,[sp,#0x28]
;;;2299       CPU_SR_ALLOC();
000010  f04f0a00          MOV      r10,#0
;;;2300   
;;;2301   
;;;2302   
;;;2303      *p_err = OS_ERR_NONE;                                    /* Assume we won't have any errors                        */
000014  2000              MOVS     r0,#0
000016  8028              STRH     r0,[r5,#0]
;;;2304       OS_CRITICAL_ENTER();
000018  bf00              NOP      
00001a  bf00              NOP      
00001c  f7fffffe          BL       CPU_SR_Save
000020  4682              MOV      r10,r0
000022  bf00              NOP      
000024  bf00              NOP      
;;;2305       if (p_tcb == (OS_TCB *)0) {                             /* Post msg to 'self'?                                    */
000026  b90c              CBNZ     r4,|L23.44|
;;;2306           p_tcb = OSTCBCurPtr;
000028  482c              LDR      r0,|L23.220|
00002a  6804              LDR      r4,[r0,#0]  ; OSTCBCurPtr
                  |L23.44|
;;;2307       }
;;;2308       switch (p_tcb->TaskState) {
00002c  f8940036          LDRB     r0,[r4,#0x36]
000030  2808              CMP      r0,#8
000032  d245              BCS      |L23.192|
000034  e8dff000          TBB      [pc,r0]
000038  04051819          DCB      0x04,0x05,0x18,0x19
00003c  06071a1b          DCB      0x06,0x07,0x1a,0x1b
;;;2309           case OS_TASK_STATE_RDY:
;;;2310           case OS_TASK_STATE_DLY:
000040  bf00              NOP      
;;;2311           case OS_TASK_STATE_SUSPENDED:
000042  bf00              NOP      
;;;2312           case OS_TASK_STATE_DLY_SUSPENDED:
000044  bf00              NOP      
;;;2313                OS_MsgQPut(&p_tcb->MsgQ,                       /* Deposit the message in the queue                       */
000046  464b              MOV      r3,r9
000048  4642              MOV      r2,r8
00004a  4639              MOV      r1,r7
00004c  f1040060          ADD      r0,r4,#0x60
000050  e9cd6500          STRD     r6,r5,[sp,#0]
000054  f7fffffe          BL       OS_MsgQPut
;;;2314                           p_void,
;;;2315                           msg_size,
;;;2316                           opt,
;;;2317                           ts,
;;;2318                           p_err);
;;;2319                OS_CRITICAL_EXIT();
000058  bf00              NOP      
00005a  bf00              NOP      
00005c  4650              MOV      r0,r10
00005e  f7fffffe          BL       CPU_SR_Restore
000062  bf00              NOP      
000064  bf00              NOP      
;;;2320                break;
000066  e036              B        |L23.214|
;;;2321   
;;;2322           case OS_TASK_STATE_PEND:
;;;2323           case OS_TASK_STATE_PEND_TIMEOUT:
000068  bf00              NOP      
;;;2324           case OS_TASK_STATE_PEND_SUSPENDED:
00006a  bf00              NOP      
;;;2325           case OS_TASK_STATE_PEND_TIMEOUT_SUSPENDED:
00006c  bf00              NOP      
;;;2326                if (p_tcb->PendOn == OS_TASK_PEND_ON_TASK_Q) { /* Is task waiting for a message to be sent to it?        */
00006e  f8940034          LDRB     r0,[r4,#0x34]
000072  2802              CMP      r0,#2
000074  d113              BNE      |L23.158|
;;;2327                    OS_Post((OS_PEND_OBJ *)0,
000076  4643              MOV      r3,r8
000078  463a              MOV      r2,r7
00007a  4621              MOV      r1,r4
00007c  2000              MOVS     r0,#0
00007e  9600              STR      r6,[sp,#0]
000080  f7fffffe          BL       OS_Post
;;;2328                            p_tcb,
;;;2329                            p_void,
;;;2330                            msg_size,
;;;2331                            ts);
;;;2332                    OS_CRITICAL_EXIT_NO_SCHED();
000084  bf00              NOP      
000086  bf00              NOP      
000088  4650              MOV      r0,r10
00008a  f7fffffe          BL       CPU_SR_Restore
00008e  bf00              NOP      
000090  bf00              NOP      
;;;2333                    if ((opt & OS_OPT_POST_NO_SCHED) == (OS_OPT)0u) {
000092  f4094000          AND      r0,r9,#0x8000
000096  b990              CBNZ     r0,|L23.190|
;;;2334                        OSSched();                             /* Run the scheduler                                      */
000098  f7fffffe          BL       OSSched
00009c  e00f              B        |L23.190|
                  |L23.158|
;;;2335                    }
;;;2336                } else {
;;;2337                    OS_MsgQPut(&p_tcb->MsgQ,                   /* No,  Task is pending on something else ...             */
00009e  464b              MOV      r3,r9
0000a0  4642              MOV      r2,r8
0000a2  4639              MOV      r1,r7
0000a4  f1040060          ADD      r0,r4,#0x60
0000a8  e9cd6500          STRD     r6,r5,[sp,#0]
0000ac  f7fffffe          BL       OS_MsgQPut
;;;2338                               p_void,                         /*      ... Deposit the message in the task's queue       */
;;;2339                               msg_size,
;;;2340                               opt,
;;;2341                               ts,
;;;2342                               p_err);
;;;2343                    OS_CRITICAL_EXIT();
0000b0  bf00              NOP      
0000b2  bf00              NOP      
0000b4  4650              MOV      r0,r10
0000b6  f7fffffe          BL       CPU_SR_Restore
0000ba  bf00              NOP      
0000bc  bf00              NOP      
                  |L23.190|
;;;2344                }
;;;2345                break;
0000be  e00a              B        |L23.214|
                  |L23.192|
;;;2346   
;;;2347           default:
;;;2348                OS_CRITICAL_EXIT();
0000c0  bf00              NOP      
0000c2  bf00              NOP      
0000c4  4650              MOV      r0,r10
0000c6  f7fffffe          BL       CPU_SR_Restore
0000ca  bf00              NOP      
0000cc  bf00              NOP      
;;;2349               *p_err = OS_ERR_STATE_INVALID;
0000ce  f646602d          MOV      r0,#0x6e2d
0000d2  8028              STRH     r0,[r5,#0]
;;;2350                break;
0000d4  bf00              NOP      
                  |L23.214|
0000d6  bf00              NOP                            ;2320
;;;2351       }
;;;2352   }
0000d8  e8bd87fc          POP      {r2-r10,pc}
;;;2353   #endif
                          ENDP

                  |L23.220|
                          DCD      OSTCBCurPtr

                          AREA ||i.OS_TaskResume||, CODE, READONLY, ALIGN=1

                  OS_TaskResume PROC
;;;2379   #if OS_CFG_TASK_SUSPEND_EN > 0u
;;;2380   void  OS_TaskResume (OS_TCB  *p_tcb,
000000  b570              PUSH     {r4-r6,lr}
;;;2381                        OS_ERR  *p_err)
;;;2382   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;2383       CPU_SR_ALLOC();
000006  2600              MOVS     r6,#0
;;;2384   
;;;2385   
;;;2386       CPU_CRITICAL_ENTER();
000008  bf00              NOP      
00000a  bf00              NOP      
00000c  f7fffffe          BL       CPU_SR_Save
000010  4606              MOV      r6,r0
000012  bf00              NOP      
000014  bf00              NOP      
;;;2387      *p_err  = OS_ERR_NONE;
000016  2000              MOVS     r0,#0
000018  8028              STRH     r0,[r5,#0]
;;;2388       switch (p_tcb->TaskState) {
00001a  f8940036          LDRB     r0,[r4,#0x36]
00001e  2808              CMP      r0,#8
000020  d25e              BCS      |L24.224|
000022  e8dff000          TBB      [pc,r0]
000026  0405              DCB      0x04,0x05
000028  06071227          DCB      0x06,0x07,0x12,0x27
00002c  394b              DCB      0x39,0x4b
;;;2389           case OS_TASK_STATE_RDY:
;;;2390           case OS_TASK_STATE_DLY:
00002e  bf00              NOP      
;;;2391           case OS_TASK_STATE_PEND:
000030  bf00              NOP      
;;;2392           case OS_TASK_STATE_PEND_TIMEOUT:
000032  bf00              NOP      
;;;2393                CPU_CRITICAL_EXIT();
000034  bf00              NOP      
000036  bf00              NOP      
000038  4630              MOV      r0,r6
00003a  f7fffffe          BL       CPU_SR_Restore
00003e  bf00              NOP      
000040  bf00              NOP      
;;;2394               *p_err = OS_ERR_TASK_NOT_SUSPENDED;
000042  f2471053          MOV      r0,#0x7153
000046  8028              STRH     r0,[r5,#0]
;;;2395                break;
000048  e055              B        |L24.246|
;;;2396   
;;;2397           case OS_TASK_STATE_SUSPENDED:
;;;2398                OS_CRITICAL_ENTER_CPU_EXIT();
;;;2399                p_tcb->SuspendCtr--;
00004a  f8140f86          LDRB     r0,[r4,#0x86]!
00004e  1e40              SUBS     r0,r0,#1
000050  7020              STRB     r0,[r4,#0]
;;;2400                if (p_tcb->SuspendCtr == (OS_NESTING_CTR)0) {
000052  f8140986          LDRB     r0,[r4],#-0x86
000056  b928              CBNZ     r0,|L24.100|
;;;2401                    p_tcb->TaskState = OS_TASK_STATE_RDY;
000058  2000              MOVS     r0,#0
00005a  f8840036          STRB     r0,[r4,#0x36]
;;;2402                    OS_RdyListInsert(p_tcb);                            /* Insert the task in the ready list                      */
00005e  4620              MOV      r0,r4
000060  f7fffffe          BL       OS_RdyListInsert
                  |L24.100|
;;;2403                }
;;;2404                OS_CRITICAL_EXIT_NO_SCHED();
000064  bf00              NOP      
000066  bf00              NOP      
000068  4630              MOV      r0,r6
00006a  f7fffffe          BL       CPU_SR_Restore
00006e  bf00              NOP      
000070  bf00              NOP      
;;;2405                break;
000072  e040              B        |L24.246|
;;;2406   
;;;2407           case OS_TASK_STATE_DLY_SUSPENDED:
;;;2408                p_tcb->SuspendCtr--;
000074  f8140f86          LDRB     r0,[r4,#0x86]!
000078  1e40              SUBS     r0,r0,#1
00007a  7020              STRB     r0,[r4,#0]
;;;2409                if (p_tcb->SuspendCtr == (OS_NESTING_CTR)0) {
00007c  f8140986          LDRB     r0,[r4],#-0x86
000080  b910              CBNZ     r0,|L24.136|
;;;2410                    p_tcb->TaskState = OS_TASK_STATE_DLY;
000082  2001              MOVS     r0,#1
000084  f8840036          STRB     r0,[r4,#0x36]
                  |L24.136|
;;;2411                }
;;;2412                CPU_CRITICAL_EXIT();
000088  bf00              NOP      
00008a  bf00              NOP      
00008c  4630              MOV      r0,r6
00008e  f7fffffe          BL       CPU_SR_Restore
000092  bf00              NOP      
000094  bf00              NOP      
;;;2413                break;
000096  e02e              B        |L24.246|
;;;2414   
;;;2415           case OS_TASK_STATE_PEND_SUSPENDED:
;;;2416                p_tcb->SuspendCtr--;
000098  f8140f86          LDRB     r0,[r4,#0x86]!
00009c  1e40              SUBS     r0,r0,#1
00009e  7020              STRB     r0,[r4,#0]
;;;2417                if (p_tcb->SuspendCtr == (OS_NESTING_CTR)0) {
0000a0  f8140986          LDRB     r0,[r4],#-0x86
0000a4  b910              CBNZ     r0,|L24.172|
;;;2418                    p_tcb->TaskState = OS_TASK_STATE_PEND;
0000a6  2002              MOVS     r0,#2
0000a8  f8840036          STRB     r0,[r4,#0x36]
                  |L24.172|
;;;2419                }
;;;2420                CPU_CRITICAL_EXIT();
0000ac  bf00              NOP      
0000ae  bf00              NOP      
0000b0  4630              MOV      r0,r6
0000b2  f7fffffe          BL       CPU_SR_Restore
0000b6  bf00              NOP      
0000b8  bf00              NOP      
;;;2421                break;
0000ba  e01c              B        |L24.246|
;;;2422   
;;;2423           case OS_TASK_STATE_PEND_TIMEOUT_SUSPENDED:
;;;2424                p_tcb->SuspendCtr--;
0000bc  f8140f86          LDRB     r0,[r4,#0x86]!
0000c0  1e40              SUBS     r0,r0,#1
0000c2  7020              STRB     r0,[r4,#0]
;;;2425                if (p_tcb->SuspendCtr == (OS_NESTING_CTR)0) {
0000c4  f8140986          LDRB     r0,[r4],#-0x86
0000c8  b910              CBNZ     r0,|L24.208|
;;;2426                    p_tcb->TaskState = OS_TASK_STATE_PEND_TIMEOUT;
0000ca  2003              MOVS     r0,#3
0000cc  f8840036          STRB     r0,[r4,#0x36]
                  |L24.208|
;;;2427                }
;;;2428                CPU_CRITICAL_EXIT();
0000d0  bf00              NOP      
0000d2  bf00              NOP      
0000d4  4630              MOV      r0,r6
0000d6  f7fffffe          BL       CPU_SR_Restore
0000da  bf00              NOP      
0000dc  bf00              NOP      
;;;2429                break;
0000de  e00a              B        |L24.246|
                  |L24.224|
;;;2430   
;;;2431           default:
;;;2432                CPU_CRITICAL_EXIT();
0000e0  bf00              NOP      
0000e2  bf00              NOP      
0000e4  4630              MOV      r0,r6
0000e6  f7fffffe          BL       CPU_SR_Restore
0000ea  bf00              NOP      
0000ec  bf00              NOP      
;;;2433               *p_err = OS_ERR_STATE_INVALID;
0000ee  f646602d          MOV      r0,#0x6e2d
0000f2  8028              STRH     r0,[r5,#0]
                  |L24.244|
;;;2434                return;
;;;2435       }
;;;2436   
;;;2437       OSSched();
;;;2438   }
0000f4  bd70              POP      {r4-r6,pc}
                  |L24.246|
0000f6  bf00              NOP                            ;2395
0000f8  f7fffffe          BL       OSSched
0000fc  bf00              NOP      
0000fe  e7f9              B        |L24.244|
;;;2439   #endif
                          ENDP


                          AREA ||i.OS_TaskReturn||, CODE, READONLY, ALIGN=2

                  OS_TaskReturn PROC
;;;2456   
;;;2457   void  OS_TaskReturn (void)
000000  b508              PUSH     {r3,lr}
;;;2458   {
;;;2459       OS_ERR  err;
;;;2460   
;;;2461   
;;;2462   
;;;2463       OSTaskReturnHook(OSTCBCurPtr);                          /* Call hook to let user decide on what to do             */
000002  4804              LDR      r0,|L25.20|
000004  6800              LDR      r0,[r0,#0]  ; OSTCBCurPtr
000006  f7fffffe          BL       OSTaskReturnHook
;;;2464   #if OS_CFG_TASK_DEL_EN > 0u
;;;2465       OSTaskDel((OS_TCB *)0,                                  /* Delete task if it accidentally returns!                */
00000a  4669              MOV      r1,sp
00000c  2000              MOVS     r0,#0
00000e  f7fffffe          BL       OSTaskDel
;;;2466                 (OS_ERR *)&err);
;;;2467   #else
;;;2468       for (;;) {
;;;2469           OSTimeDly((OS_TICK )OSCfg_TickRate_Hz,
;;;2470                     (OS_OPT  )OS_OPT_TIME_DLY,
;;;2471                     (OS_ERR *)&err);
;;;2472       }
;;;2473   #endif
;;;2474   }
000012  bd08              POP      {r3,pc}
;;;2475   
                          ENDP

                  |L25.20|
                          DCD      OSTCBCurPtr

                          AREA ||i.OS_TaskSemPost||, CODE, READONLY, ALIGN=2

                  OS_TaskSemPost PROC
;;;2506   
;;;2507   OS_SEM_CTR  OS_TaskSemPost (OS_TCB  *p_tcb,
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;2508                               OS_OPT   opt,
;;;2509                               CPU_TS   ts,
;;;2510                               OS_ERR  *p_err)
;;;2511   {
000004  4604              MOV      r4,r0
000006  4688              MOV      r8,r1
000008  4617              MOV      r7,r2
00000a  461d              MOV      r5,r3
;;;2512       OS_SEM_CTR  ctr;
;;;2513       CPU_SR_ALLOC();
00000c  f04f0900          MOV      r9,#0
;;;2514   
;;;2515   
;;;2516   
;;;2517       OS_CRITICAL_ENTER();
000010  bf00              NOP      
000012  bf00              NOP      
000014  f7fffffe          BL       CPU_SR_Save
000018  4681              MOV      r9,r0
00001a  bf00              NOP      
00001c  bf00              NOP      
;;;2518       if (p_tcb == (OS_TCB *)0) {                             /* Post signal to 'self'?                                 */
00001e  b90c              CBNZ     r4,|L26.36|
;;;2519           p_tcb = OSTCBCurPtr;
000020  4867              LDR      r0,|L26.448|
000022  6804              LDR      r4,[r0,#0]  ; OSTCBCurPtr
                  |L26.36|
;;;2520       }
;;;2521       p_tcb->TS = ts;
000024  64a7              STR      r7,[r4,#0x48]
;;;2522      *p_err     = OS_ERR_NONE;                                /* Assume we won't have any errors                        */
000026  2000              MOVS     r0,#0
000028  8028              STRH     r0,[r5,#0]
;;;2523       switch (p_tcb->TaskState) {
00002a  f8940036          LDRB     r0,[r4,#0x36]
00002e  2808              CMP      r0,#8
000030  d276              BCS      |L26.288|
000032  e8dff000          TBB      [pc,r0]
000036  0405              DCB      0x04,0x05
000038  50510607          DCB      0x50,0x51,0x06,0x07
00003c  5253              DCB      0x52,0x53
;;;2524           case OS_TASK_STATE_RDY:
;;;2525           case OS_TASK_STATE_DLY:
00003e  bf00              NOP      
;;;2526           case OS_TASK_STATE_SUSPENDED:
000040  bf00              NOP      
;;;2527           case OS_TASK_STATE_DLY_SUSPENDED:
000042  bf00              NOP      
;;;2528                switch (sizeof(OS_SEM_CTR)) {
000044  2004              MOVS     r0,#4
000046  2801              CMP      r0,#1
000048  d004              BEQ      |L26.84|
00004a  2802              CMP      r0,#2
00004c  d013              BEQ      |L26.118|
00004e  2804              CMP      r0,#4
000050  d133              BNE      |L26.186|
000052  e022              B        |L26.154|
                  |L26.84|
;;;2529                    case 1u:
;;;2530                         if (p_tcb->SemCtr == DEF_INT_08U_MAX_VAL) {
000054  6ce0              LDR      r0,[r4,#0x4c]
000056  28ff              CMP      r0,#0xff
000058  d10c              BNE      |L26.116|
;;;2531                             OS_CRITICAL_EXIT();
00005a  bf00              NOP      
00005c  bf00              NOP      
00005e  4648              MOV      r0,r9
000060  f7fffffe          BL       CPU_SR_Restore
000064  bf00              NOP      
000066  bf00              NOP      
;;;2532                            *p_err = OS_ERR_SEM_OVF;
000068  f64650c5          MOV      r0,#0x6dc5
00006c  8028              STRH     r0,[r5,#0]
;;;2533                             return ((OS_SEM_CTR)0);
00006e  2000              MOVS     r0,#0
                  |L26.112|
;;;2534                         }
;;;2535                         break;
;;;2536   
;;;2537                    case 2u:
;;;2538                         if (p_tcb->SemCtr == DEF_INT_16U_MAX_VAL) {
;;;2539                             OS_CRITICAL_EXIT();
;;;2540                            *p_err = OS_ERR_SEM_OVF;
;;;2541                             return ((OS_SEM_CTR)0);
;;;2542                         }
;;;2543                         break;
;;;2544   
;;;2545                    case 4u:
;;;2546                         if (p_tcb->SemCtr == DEF_INT_32U_MAX_VAL) {
;;;2547                             OS_CRITICAL_EXIT();
;;;2548                            *p_err = OS_ERR_SEM_OVF;
;;;2549                             return ((OS_SEM_CTR)0);
;;;2550                         }
;;;2551                         break;
;;;2552   
;;;2553                    default:
;;;2554                         break;
;;;2555                }
;;;2556                p_tcb->SemCtr++;                               /* Task signaled is not pending on anything               */
;;;2557                ctr = p_tcb->SemCtr;
;;;2558                OS_CRITICAL_EXIT();
;;;2559                break;
;;;2560   
;;;2561           case OS_TASK_STATE_PEND:
;;;2562           case OS_TASK_STATE_PEND_TIMEOUT:
;;;2563           case OS_TASK_STATE_PEND_SUSPENDED:
;;;2564           case OS_TASK_STATE_PEND_TIMEOUT_SUSPENDED:
;;;2565                if (p_tcb->PendOn == OS_TASK_PEND_ON_TASK_SEM) {   /* Is task signaled waiting for a signal?             */
;;;2566                    OS_Post((OS_PEND_OBJ *)0,                      /*      Task is pending on signal                     */
;;;2567                            (OS_TCB      *)p_tcb,
;;;2568                            (void        *)0,
;;;2569                            (OS_MSG_SIZE  )0u,
;;;2570                            (CPU_TS       )ts);
;;;2571                    ctr = p_tcb->SemCtr;
;;;2572                    OS_CRITICAL_EXIT_NO_SCHED();
;;;2573                    if ((opt & OS_OPT_POST_NO_SCHED) == (OS_OPT)0) {
;;;2574                        OSSched();                                 /* Run the scheduler                                  */
;;;2575                    }
;;;2576                } else {
;;;2577                    switch (sizeof(OS_SEM_CTR)) {
;;;2578                        case 1u:
;;;2579                             if (p_tcb->SemCtr == DEF_INT_08U_MAX_VAL) {
;;;2580                                 OS_CRITICAL_EXIT();
;;;2581                                *p_err = OS_ERR_SEM_OVF;
;;;2582                                 return ((OS_SEM_CTR)0);
;;;2583                             }
;;;2584                             break;
;;;2585   
;;;2586                        case 2u:
;;;2587                             if (p_tcb->SemCtr == DEF_INT_16U_MAX_VAL) {
;;;2588                                 OS_CRITICAL_EXIT();
;;;2589                                *p_err = OS_ERR_SEM_OVF;
;;;2590                                 return ((OS_SEM_CTR)0);
;;;2591                             }
;;;2592                             break;
;;;2593   
;;;2594                        case 4u:
;;;2595                             if (p_tcb->SemCtr == DEF_INT_32U_MAX_VAL) {
;;;2596                                 OS_CRITICAL_EXIT();
;;;2597                                *p_err = OS_ERR_SEM_OVF;
;;;2598                                 return ((OS_SEM_CTR)0);
;;;2599                             }
;;;2600                             break;
;;;2601   
;;;2602                        default:
;;;2603                             break;
;;;2604                    }
;;;2605                    p_tcb->SemCtr++;                           /* No,  Task signaled is NOT pending on semaphore ...     */
;;;2606                    ctr = p_tcb->SemCtr;                       /*      ... it must be waiting on something else          */
;;;2607                    OS_CRITICAL_EXIT();
;;;2608                }
;;;2609                break;
;;;2610   
;;;2611           default:
;;;2612                OS_CRITICAL_EXIT();
;;;2613               *p_err = OS_ERR_STATE_INVALID;
;;;2614                ctr   = (OS_SEM_CTR)0;
;;;2615                break;
;;;2616       }
;;;2617       return (ctr);
;;;2618   }
000070  e8bd83f8          POP      {r3-r9,pc}
                  |L26.116|
000074  e022              B        |L26.188|
                  |L26.118|
000076  f64f71ff          MOV      r1,#0xffff            ;2538
00007a  6ce0              LDR      r0,[r4,#0x4c]         ;2538
00007c  4288              CMP      r0,r1                 ;2538
00007e  d10b              BNE      |L26.152|
000080  bf00              NOP                            ;2539
000082  bf00              NOP                            ;2539
000084  4648              MOV      r0,r9                 ;2539
000086  f7fffffe          BL       CPU_SR_Restore
00008a  bf00              NOP                            ;2539
00008c  bf00              NOP                            ;2539
00008e  f64650c5          MOV      r0,#0x6dc5            ;2540
000092  8028              STRH     r0,[r5,#0]            ;2540
000094  2000              MOVS     r0,#0                 ;2541
000096  e7eb              B        |L26.112|
                  |L26.152|
000098  e010              B        |L26.188|
                  |L26.154|
00009a  6ce0              LDR      r0,[r4,#0x4c]         ;2546
00009c  1c40              ADDS     r0,r0,#1              ;2546
00009e  b958              CBNZ     r0,|L26.184|
0000a0  bf00              NOP                            ;2547
0000a2  bf00              NOP                            ;2547
0000a4  4648              MOV      r0,r9                 ;2547
0000a6  f7fffffe          BL       CPU_SR_Restore
0000aa  bf00              NOP                            ;2547
0000ac  bf00              NOP                            ;2547
0000ae  f64650c5          MOV      r0,#0x6dc5            ;2548
0000b2  8028              STRH     r0,[r5,#0]            ;2548
0000b4  2000              MOVS     r0,#0                 ;2549
0000b6  e7db              B        |L26.112|
                  |L26.184|
0000b8  e000              B        |L26.188|
                  |L26.186|
0000ba  bf00              NOP                            ;2554
                  |L26.188|
0000bc  bf00              NOP                            ;2535
0000be  6ce0              LDR      r0,[r4,#0x4c]         ;2556
0000c0  1c40              ADDS     r0,r0,#1              ;2556
0000c2  64e0              STR      r0,[r4,#0x4c]         ;2556
0000c4  6ce6              LDR      r6,[r4,#0x4c]         ;2557
0000c6  bf00              NOP                            ;2558
0000c8  bf00              NOP                            ;2558
0000ca  4648              MOV      r0,r9                 ;2558
0000cc  f7fffffe          BL       CPU_SR_Restore
0000d0  bf00              NOP                            ;2558
0000d2  bf00              NOP                            ;2558
0000d4  e071              B        |L26.442|
0000d6  bf00              NOP                            ;2562
0000d8  bf00              NOP                            ;2563
0000da  bf00              NOP                            ;2564
0000dc  f8940034          LDRB     r0,[r4,#0x34]         ;2565
0000e0  2807              CMP      r0,#7                 ;2565
0000e2  d115              BNE      |L26.272|
0000e4  2300              MOVS     r3,#0                 ;2566
0000e6  461a              MOV      r2,r3                 ;2566
0000e8  4621              MOV      r1,r4                 ;2566
0000ea  4618              MOV      r0,r3                 ;2566
0000ec  9700              STR      r7,[sp,#0]            ;2566
0000ee  f7fffffe          BL       OS_Post
0000f2  6ce6              LDR      r6,[r4,#0x4c]         ;2571
0000f4  bf00              NOP                            ;2572
0000f6  bf00              NOP                            ;2572
0000f8  4648              MOV      r0,r9                 ;2572
0000fa  f7fffffe          BL       CPU_SR_Restore
0000fe  bf00              NOP                            ;2572
000100  bf00              NOP                            ;2572
000102  f4084000          AND      r0,r8,#0x8000         ;2573
000106  2800              CMP      r0,#0                 ;2573
000108  d14a              BNE      |L26.416|
00010a  f7fffffe          BL       OSSched
00010e  e047              B        |L26.416|
                  |L26.272|
000110  2004              MOVS     r0,#4                 ;2577
000112  2801              CMP      r0,#1                 ;2577
000114  d005              BEQ      |L26.290|
000116  2802              CMP      r0,#2                 ;2577
000118  d013              BEQ      |L26.322|
00011a  2804              CMP      r0,#4                 ;2577
00011c  d133              BNE      |L26.390|
00011e  e022              B        |L26.358|
                  |L26.288|
000120  e03f              B        |L26.418|
                  |L26.290|
000122  6ce0              LDR      r0,[r4,#0x4c]         ;2579
000124  28ff              CMP      r0,#0xff              ;2579
000126  d10b              BNE      |L26.320|
000128  bf00              NOP                            ;2580
00012a  bf00              NOP                            ;2580
00012c  4648              MOV      r0,r9                 ;2580
00012e  f7fffffe          BL       CPU_SR_Restore
000132  bf00              NOP                            ;2580
000134  bf00              NOP                            ;2580
000136  f64650c5          MOV      r0,#0x6dc5            ;2581
00013a  8028              STRH     r0,[r5,#0]            ;2581
00013c  2000              MOVS     r0,#0                 ;2582
00013e  e797              B        |L26.112|
                  |L26.320|
000140  e022              B        |L26.392|
                  |L26.322|
000142  f64f71ff          MOV      r1,#0xffff            ;2587
000146  6ce0              LDR      r0,[r4,#0x4c]         ;2587
000148  4288              CMP      r0,r1                 ;2587
00014a  d10b              BNE      |L26.356|
00014c  bf00              NOP                            ;2588
00014e  bf00              NOP                            ;2588
000150  4648              MOV      r0,r9                 ;2588
000152  f7fffffe          BL       CPU_SR_Restore
000156  bf00              NOP                            ;2588
000158  bf00              NOP                            ;2588
00015a  f64650c5          MOV      r0,#0x6dc5            ;2589
00015e  8028              STRH     r0,[r5,#0]            ;2589
000160  2000              MOVS     r0,#0                 ;2590
000162  e785              B        |L26.112|
                  |L26.356|
000164  e010              B        |L26.392|
                  |L26.358|
000166  6ce0              LDR      r0,[r4,#0x4c]         ;2595
000168  1c40              ADDS     r0,r0,#1              ;2595
00016a  b958              CBNZ     r0,|L26.388|
00016c  bf00              NOP                            ;2596
00016e  bf00              NOP                            ;2596
000170  4648              MOV      r0,r9                 ;2596
000172  f7fffffe          BL       CPU_SR_Restore
000176  bf00              NOP                            ;2596
000178  bf00              NOP                            ;2596
00017a  f64650c5          MOV      r0,#0x6dc5            ;2597
00017e  8028              STRH     r0,[r5,#0]            ;2597
000180  2000              MOVS     r0,#0                 ;2598
000182  e775              B        |L26.112|
                  |L26.388|
000184  e000              B        |L26.392|
                  |L26.390|
000186  bf00              NOP                            ;2603
                  |L26.392|
000188  bf00              NOP                            ;2584
00018a  6ce0              LDR      r0,[r4,#0x4c]         ;2605
00018c  1c40              ADDS     r0,r0,#1              ;2605
00018e  64e0              STR      r0,[r4,#0x4c]         ;2605
000190  6ce6              LDR      r6,[r4,#0x4c]         ;2606
000192  bf00              NOP                            ;2607
000194  bf00              NOP                            ;2607
000196  4648              MOV      r0,r9                 ;2607
000198  f7fffffe          BL       CPU_SR_Restore
00019c  bf00              NOP                            ;2607
00019e  bf00              NOP                            ;2607
                  |L26.416|
0001a0  e00b              B        |L26.442|
                  |L26.418|
0001a2  bf00              NOP                            ;2612
0001a4  bf00              NOP                            ;2612
0001a6  4648              MOV      r0,r9                 ;2612
0001a8  f7fffffe          BL       CPU_SR_Restore
0001ac  bf00              NOP                            ;2612
0001ae  bf00              NOP                            ;2612
0001b0  f646602d          MOV      r0,#0x6e2d            ;2613
0001b4  8028              STRH     r0,[r5,#0]            ;2613
0001b6  2600              MOVS     r6,#0                 ;2614
0001b8  bf00              NOP                            ;2615
                  |L26.442|
0001ba  bf00              NOP                            ;2559
0001bc  4630              MOV      r0,r6                 ;2617
0001be  e757              B        |L26.112|
;;;2619   
                          ENDP

                  |L26.448|
                          DCD      OSTCBCurPtr

                          AREA ||i.OS_TaskSuspend||, CODE, READONLY, ALIGN=2

                  OS_TaskSuspend PROC
;;;2650   #if OS_CFG_TASK_SUSPEND_EN > 0u
;;;2651   void  OS_TaskSuspend (OS_TCB  *p_tcb,
000000  b570              PUSH     {r4-r6,lr}
;;;2652                         OS_ERR  *p_err)
;;;2653   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;2654       CPU_SR_ALLOC();
000006  2600              MOVS     r6,#0
;;;2655   
;;;2656   
;;;2657       CPU_CRITICAL_ENTER();
000008  bf00              NOP      
00000a  bf00              NOP      
00000c  f7fffffe          BL       CPU_SR_Save
000010  4606              MOV      r6,r0
000012  bf00              NOP      
000014  bf00              NOP      
;;;2658       if (p_tcb == (OS_TCB *)0) {                             /* See if specified to suspend self                       */
000016  b90c              CBNZ     r4,|L27.28|
;;;2659           p_tcb = OSTCBCurPtr;
000018  483d              LDR      r0,|L27.272|
00001a  6804              LDR      r4,[r0,#0]  ; OSTCBCurPtr
                  |L27.28|
;;;2660       }
;;;2661   
;;;2662       if (p_tcb == OSTCBCurPtr) {
00001c  483c              LDR      r0,|L27.272|
00001e  6800              LDR      r0,[r0,#0]  ; OSTCBCurPtr
000020  4284              CMP      r4,r0
000022  d10e              BNE      |L27.66|
;;;2663           if (OSSchedLockNestingCtr > (OS_NESTING_CTR)0) {    /* Can't suspend when the scheduler is locked             */
000024  483b              LDR      r0,|L27.276|
000026  7800              LDRB     r0,[r0,#0]  ; OSSchedLockNestingCtr
000028  2800              CMP      r0,#0
00002a  dd0a              BLE      |L27.66|
;;;2664               CPU_CRITICAL_EXIT();
00002c  bf00              NOP      
00002e  bf00              NOP      
000030  4630              MOV      r0,r6
000032  f7fffffe          BL       CPU_SR_Restore
000036  bf00              NOP      
000038  bf00              NOP      
;;;2665              *p_err = OS_ERR_SCHED_LOCKED;
00003a  f6465063          MOV      r0,#0x6d63
00003e  8028              STRH     r0,[r5,#0]
                  |L27.64|
;;;2666               return;
;;;2667           }
;;;2668       }
;;;2669   
;;;2670      *p_err = OS_ERR_NONE;
;;;2671       switch (p_tcb->TaskState) {
;;;2672           case OS_TASK_STATE_RDY:
;;;2673                OS_CRITICAL_ENTER_CPU_EXIT();
;;;2674                p_tcb->TaskState  =  OS_TASK_STATE_SUSPENDED;
;;;2675                p_tcb->SuspendCtr = (OS_NESTING_CTR)1;
;;;2676                OS_RdyListRemove(p_tcb);
;;;2677                OS_CRITICAL_EXIT_NO_SCHED();
;;;2678                break;
;;;2679   
;;;2680           case OS_TASK_STATE_DLY:
;;;2681                p_tcb->TaskState  = OS_TASK_STATE_DLY_SUSPENDED;
;;;2682                p_tcb->SuspendCtr = (OS_NESTING_CTR)1;
;;;2683                CPU_CRITICAL_EXIT();
;;;2684                break;
;;;2685   
;;;2686           case OS_TASK_STATE_PEND:
;;;2687                p_tcb->TaskState  = OS_TASK_STATE_PEND_SUSPENDED;
;;;2688                p_tcb->SuspendCtr = (OS_NESTING_CTR)1;
;;;2689                CPU_CRITICAL_EXIT();
;;;2690                break;
;;;2691   
;;;2692           case OS_TASK_STATE_PEND_TIMEOUT:
;;;2693                p_tcb->TaskState  = OS_TASK_STATE_PEND_TIMEOUT_SUSPENDED;
;;;2694                p_tcb->SuspendCtr = (OS_NESTING_CTR)1;
;;;2695                CPU_CRITICAL_EXIT();
;;;2696                break;
;;;2697   
;;;2698           case OS_TASK_STATE_SUSPENDED:
;;;2699           case OS_TASK_STATE_DLY_SUSPENDED:
;;;2700           case OS_TASK_STATE_PEND_SUSPENDED:
;;;2701           case OS_TASK_STATE_PEND_TIMEOUT_SUSPENDED:
;;;2702                p_tcb->SuspendCtr++;
;;;2703                CPU_CRITICAL_EXIT();
;;;2704                break;
;;;2705   
;;;2706           default:
;;;2707                CPU_CRITICAL_EXIT();
;;;2708               *p_err = OS_ERR_STATE_INVALID;
;;;2709                return;
;;;2710       }
;;;2711   
;;;2712       OSSched();
;;;2713   }
000040  bd70              POP      {r4-r6,pc}
                  |L27.66|
000042  2000              MOVS     r0,#0                 ;2670
000044  8028              STRH     r0,[r5,#0]            ;2670
000046  f8940036          LDRB     r0,[r4,#0x36]         ;2671
00004a  2808              CMP      r0,#8                 ;2671
00004c  d250              BCS      |L27.240|
00004e  e8dff000          TBB      [pc,r0]               ;2671
000052  0415              DCB      0x04,0x15
000054  23313f40          DCB      0x23,0x31,0x3f,0x40
000058  4142              DCB      0x41,0x42
00005a  2004              MOVS     r0,#4                 ;2674
00005c  f8840036          STRB     r0,[r4,#0x36]         ;2674
000060  2001              MOVS     r0,#1                 ;2675
000062  f8840086          STRB     r0,[r4,#0x86]         ;2675
000066  4620              MOV      r0,r4                 ;2676
000068  f7fffffe          BL       OS_RdyListRemove
00006c  bf00              NOP                            ;2677
00006e  bf00              NOP                            ;2677
000070  4630              MOV      r0,r6                 ;2677
000072  f7fffffe          BL       CPU_SR_Restore
000076  bf00              NOP                            ;2677
000078  bf00              NOP                            ;2677
00007a  e044              B        |L27.262|
00007c  2005              MOVS     r0,#5                 ;2681
00007e  f8840036          STRB     r0,[r4,#0x36]         ;2681
000082  2001              MOVS     r0,#1                 ;2682
000084  f8840086          STRB     r0,[r4,#0x86]         ;2682
000088  bf00              NOP                            ;2683
00008a  bf00              NOP                            ;2683
00008c  4630              MOV      r0,r6                 ;2683
00008e  f7fffffe          BL       CPU_SR_Restore
000092  bf00              NOP                            ;2683
000094  bf00              NOP                            ;2683
000096  e036              B        |L27.262|
000098  2006              MOVS     r0,#6                 ;2687
00009a  f8840036          STRB     r0,[r4,#0x36]         ;2687
00009e  2001              MOVS     r0,#1                 ;2688
0000a0  f8840086          STRB     r0,[r4,#0x86]         ;2688
0000a4  bf00              NOP                            ;2689
0000a6  bf00              NOP                            ;2689
0000a8  4630              MOV      r0,r6                 ;2689
0000aa  f7fffffe          BL       CPU_SR_Restore
0000ae  bf00              NOP                            ;2689
0000b0  bf00              NOP                            ;2689
0000b2  e028              B        |L27.262|
0000b4  2007              MOVS     r0,#7                 ;2693
0000b6  f8840036          STRB     r0,[r4,#0x36]         ;2693
0000ba  2001              MOVS     r0,#1                 ;2694
0000bc  f8840086          STRB     r0,[r4,#0x86]         ;2694
0000c0  bf00              NOP                            ;2695
0000c2  bf00              NOP                            ;2695
0000c4  4630              MOV      r0,r6                 ;2695
0000c6  f7fffffe          BL       CPU_SR_Restore
0000ca  bf00              NOP                            ;2695
0000cc  bf00              NOP                            ;2695
0000ce  e01a              B        |L27.262|
0000d0  bf00              NOP                            ;2699
0000d2  bf00              NOP                            ;2700
0000d4  bf00              NOP                            ;2701
0000d6  f8940086          LDRB     r0,[r4,#0x86]         ;2702
0000da  1c40              ADDS     r0,r0,#1              ;2702
0000dc  f8840086          STRB     r0,[r4,#0x86]         ;2702
0000e0  bf00              NOP                            ;2703
0000e2  bf00              NOP                            ;2703
0000e4  4630              MOV      r0,r6                 ;2703
0000e6  f7fffffe          BL       CPU_SR_Restore
0000ea  bf00              NOP                            ;2703
0000ec  bf00              NOP                            ;2703
0000ee  e00a              B        |L27.262|
                  |L27.240|
0000f0  bf00              NOP                            ;2707
0000f2  bf00              NOP                            ;2707
0000f4  4630              MOV      r0,r6                 ;2707
0000f6  f7fffffe          BL       CPU_SR_Restore
0000fa  bf00              NOP                            ;2707
0000fc  bf00              NOP                            ;2707
0000fe  f646602d          MOV      r0,#0x6e2d            ;2708
000102  8028              STRH     r0,[r5,#0]            ;2708
000104  e79c              B        |L27.64|
                  |L27.262|
000106  bf00              NOP                            ;2678
000108  f7fffffe          BL       OSSched
00010c  bf00              NOP      
00010e  e797              B        |L27.64|
;;;2714   #endif
                          ENDP

                  |L27.272|
                          DCD      OSTCBCurPtr
                  |L27.276|
                          DCD      OSSchedLockNestingCtr
