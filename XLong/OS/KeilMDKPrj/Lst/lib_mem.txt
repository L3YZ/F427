; generated by Component: ARM Compiler 5.05 (build 41) Tool: ArmCC [4d0eb9]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\lib_mem.o --asm_dir=.\Lst\ --list_dir=.\Lst\ --depend=.\obj\lib_mem.d --cpu=Cortex-M4.fp --apcs=interwork -O0 -I..\..\..\CMSIS\4.5.0\CMSIS\Include -I..\APP -I..\APP\ST -I..\APP\uCOS -I..\..\BSP\KeilMDK -I..\..\BSP\Board\inc -I..\..\BSP\STM32F4xx\inc -I..\..\BSP\Xlong\inc -I..\..\..\uCOS\uC-CPU -I..\..\..\uCOS\uC-CPU\Ports\ARM-Cortex-M4 -I..\..\..\uCOS\uC-LIB -I..\..\..\uCOS\uC-LIB\Ports\ARM-Cortex-M4 -I..\..\..\uCOS\uCOS-III\Source -I..\..\..\uCOS\uCOS-III\Ports\ARM-Cortex-M4 -IC:\Users\V200\Desktop\XLong\XLong\OS\KeilMDKPrj\RTE -Id:\Keil_v5\ARM\PACK\Keil\STM32F4xx_DFP\1.0.8\Device\Include -Id:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -DSTM32F427_437xx -DSTM32F427_437xx -DUSE_STDPERIPH_DRIVER --omf_browse=.\obj\lib_mem.crf ..\..\..\uCOS\uC-LIB\lib_mem.c]
                          THUMB

                          AREA ||i.Mem_Clr||, CODE, READONLY, ALIGN=1

                  Mem_Clr PROC
;;;261    
;;;262    void  Mem_Clr (void        *pmem,
000000  b530              PUSH     {r4,r5,lr}
;;;263                   CPU_SIZE_T   size)
;;;264    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;265        Mem_Set(pmem,
000006  4622              MOV      r2,r4
000008  2100              MOVS     r1,#0
00000a  4628              MOV      r0,r5
00000c  f7fffffe          BL       Mem_Set
;;;266                0u,                                                 /* See Note #2.                                         */
;;;267                size);
;;;268    }
000010  bd30              POP      {r4,r5,pc}
;;;269    
                          ENDP


                          AREA ||i.Mem_Cmp||, CODE, READONLY, ALIGN=1

                  Mem_Cmp PROC
;;;645    
;;;646    CPU_BOOLEAN  Mem_Cmp (const  void        *p1_mem,
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;647                          const  void        *p2_mem,
;;;648                                 CPU_SIZE_T   size)
;;;649    {
000004  4680              MOV      r8,r0
000006  4689              MOV      r9,r1
000008  4615              MOV      r5,r2
;;;650               CPU_SIZE_T    size_rem;
;;;651               CPU_ALIGN    *p1_mem_align;
;;;652               CPU_ALIGN    *p2_mem_align;
;;;653        const  CPU_INT08U   *p1_mem_08;
;;;654        const  CPU_INT08U   *p2_mem_08;
;;;655               CPU_DATA      i;
;;;656               CPU_DATA      mem_align_mod_1;
;;;657               CPU_DATA      mem_align_mod_2;
;;;658               CPU_BOOLEAN   mem_aligned;
;;;659               CPU_BOOLEAN   mem_cmp;
;;;660    
;;;661    
;;;662        if (size < 1) {                                             /* See Note #1.                                         */
00000a  b915              CBNZ     r5,|L2.18|
;;;663            return (DEF_YES);
00000c  2001              MOVS     r0,#1
                  |L2.14|
;;;664        }
;;;665        if (p1_mem == (void *)0) {
;;;666            return (DEF_NO);
;;;667        }
;;;668        if (p2_mem == (void *)0) {
;;;669            return (DEF_NO);
;;;670        }
;;;671    
;;;672    
;;;673        mem_cmp         =  DEF_YES;                                 /* Assume mem bufs are identical until cmp fails.       */
;;;674        size_rem        =  size;
;;;675                                                                    /* Start @ end of mem bufs (see Note #2).               */
;;;676        p1_mem_08       = (const CPU_INT08U *)p1_mem + size;
;;;677        p2_mem_08       = (const CPU_INT08U *)p2_mem + size;
;;;678                                                                    /* See Note #4.                                         */
;;;679        mem_align_mod_1 = (CPU_INT08U)((CPU_ADDR)p1_mem_08 % sizeof(CPU_ALIGN));
;;;680        mem_align_mod_2 = (CPU_INT08U)((CPU_ADDR)p2_mem_08 % sizeof(CPU_ALIGN));
;;;681    
;;;682        mem_aligned     = (mem_align_mod_1 == mem_align_mod_2) ? DEF_YES : DEF_NO;
;;;683    
;;;684        if (mem_aligned == DEF_YES) {                               /* If mem bufs' alignment offset equal, ...             */
;;;685                                                                    /* ... optimize cmp for mem buf alignment.              */
;;;686            if (mem_align_mod_1 != 0u) {                            /* If trailing octets avail,                  ...       */
;;;687                i = mem_align_mod_1;
;;;688                while ((mem_cmp == DEF_YES) &&                      /* ... cmp mem bufs while identical &         ...       */
;;;689                       (size_rem > 0)       &&                      /* ... start mem buf cmp with trailing octets ...       */
;;;690                       (i        > 0)) {                            /* ... until next CPU_ALIGN word boundary.              */
;;;691                    p1_mem_08--;
;;;692                    p2_mem_08--;
;;;693                    if (*p1_mem_08 != *p2_mem_08) {                 /* If ANY data octet(s) NOT identical, cmp fails.       */
;;;694                         mem_cmp = DEF_NO;
;;;695                    }
;;;696                    size_rem -= sizeof(CPU_INT08U);
;;;697                    i--;
;;;698                }
;;;699            }
;;;700    
;;;701            if (mem_cmp == DEF_YES) {                               /* If cmp still identical, cmp aligned mem bufs.        */
;;;702                p1_mem_align = (CPU_ALIGN *)p1_mem_08;              /* See Note #3.                                         */
;;;703                p2_mem_align = (CPU_ALIGN *)p2_mem_08;
;;;704    
;;;705                while ((mem_cmp  == DEF_YES) &&                     /* Cmp mem bufs while identical & ...                   */
;;;706                       (size_rem >= sizeof(CPU_ALIGN))) {           /* ... mem bufs aligned on CPU_ALIGN word boundaries.   */
;;;707                    p1_mem_align--;
;;;708                    p2_mem_align--;
;;;709                    if (*p1_mem_align != *p2_mem_align) {           /* If ANY data octet(s) NOT identical, cmp fails.       */
;;;710                         mem_cmp = DEF_NO;
;;;711                    }
;;;712                    size_rem -= sizeof(CPU_ALIGN);
;;;713                }
;;;714    
;;;715                p1_mem_08 = (CPU_INT08U *)p1_mem_align;
;;;716                p2_mem_08 = (CPU_INT08U *)p2_mem_align;
;;;717            }
;;;718        }
;;;719    
;;;720        while ((mem_cmp == DEF_YES) &&                              /* Cmp mem bufs while identical ...                     */
;;;721               (size_rem > 0)) {                                    /* ... for unaligned mem bufs or trailing octets.       */
;;;722            p1_mem_08--;
;;;723            p2_mem_08--;
;;;724            if (*p1_mem_08 != *p2_mem_08) {                         /* If ANY data octet(s) NOT identical, cmp fails.       */
;;;725                 mem_cmp = DEF_NO;
;;;726            }
;;;727            size_rem -= sizeof(CPU_INT08U);
;;;728        }
;;;729    
;;;730        return (mem_cmp);
;;;731    }
00000e  e8bd8ff8          POP      {r3-r11,pc}
                  |L2.18|
000012  f1b80f00          CMP      r8,#0                 ;665
000016  d101              BNE      |L2.28|
000018  2000              MOVS     r0,#0                 ;666
00001a  e7f8              B        |L2.14|
                  |L2.28|
00001c  f1b90f00          CMP      r9,#0                 ;668
000020  d101              BNE      |L2.38|
000022  2000              MOVS     r0,#0                 ;669
000024  e7f3              B        |L2.14|
                  |L2.38|
000026  2401              MOVS     r4,#1                 ;673
000028  4629              MOV      r1,r5                 ;674
00002a  eb080205          ADD      r2,r8,r5              ;676
00002e  eb090305          ADD      r3,r9,r5              ;677
000032  f0020c03          AND      r12,r2,#3             ;679
000036  f0030b03          AND      r11,r3,#3             ;680
00003a  45dc              CMP      r12,r11               ;682
00003c  d101              BNE      |L2.66|
00003e  2001              MOVS     r0,#1                 ;682
000040  e000              B        |L2.68|
                  |L2.66|
000042  2000              MOVS     r0,#0                 ;682
                  |L2.68|
000044  9000              STR      r0,[sp,#0]            ;682
000046  9800              LDR      r0,[sp,#0]            ;684
000048  2801              CMP      r0,#1                 ;684
00004a  d129              BNE      |L2.160|
00004c  f1bc0f00          CMP      r12,#0                ;686
000050  d012              BEQ      |L2.120|
000052  46e2              MOV      r10,r12               ;687
000054  e00a              B        |L2.108|
                  |L2.86|
000056  1e52              SUBS     r2,r2,#1              ;691
000058  1e5b              SUBS     r3,r3,#1              ;692
00005a  7810              LDRB     r0,[r2,#0]            ;693
00005c  f893e000          LDRB     lr,[r3,#0]            ;693
000060  4570              CMP      r0,lr                 ;693
000062  d000              BEQ      |L2.102|
000064  2400              MOVS     r4,#0                 ;694
                  |L2.102|
000066  1e49              SUBS     r1,r1,#1              ;696
000068  f1aa0a01          SUB      r10,r10,#1            ;697
                  |L2.108|
00006c  2c01              CMP      r4,#1                 ;688
00006e  d103              BNE      |L2.120|
000070  b111              CBZ      r1,|L2.120|
000072  f1ba0f00          CMP      r10,#0                ;690
000076  d1ee              BNE      |L2.86|
                  |L2.120|
000078  2c01              CMP      r4,#1                 ;701
00007a  d111              BNE      |L2.160|
00007c  4616              MOV      r6,r2                 ;702
00007e  461f              MOV      r7,r3                 ;703
000080  e008              B        |L2.148|
                  |L2.130|
000082  1f36              SUBS     r6,r6,#4              ;707
000084  1f3f              SUBS     r7,r7,#4              ;708
000086  6830              LDR      r0,[r6,#0]            ;709
000088  f8d7e000          LDR      lr,[r7,#0]            ;709
00008c  4570              CMP      r0,lr                 ;709
00008e  d000              BEQ      |L2.146|
000090  2400              MOVS     r4,#0                 ;710
                  |L2.146|
000092  1f09              SUBS     r1,r1,#4              ;712
                  |L2.148|
000094  2c01              CMP      r4,#1                 ;705
000096  d101              BNE      |L2.156|
000098  2904              CMP      r1,#4                 ;706
00009a  d2f2              BCS      |L2.130|
                  |L2.156|
00009c  4632              MOV      r2,r6                 ;715
00009e  463b              MOV      r3,r7                 ;716
                  |L2.160|
0000a0  e008              B        |L2.180|
                  |L2.162|
0000a2  1e52              SUBS     r2,r2,#1              ;722
0000a4  1e5b              SUBS     r3,r3,#1              ;723
0000a6  7810              LDRB     r0,[r2,#0]            ;724
0000a8  f893e000          LDRB     lr,[r3,#0]            ;724
0000ac  4570              CMP      r0,lr                 ;724
0000ae  d000              BEQ      |L2.178|
0000b0  2400              MOVS     r4,#0                 ;725
                  |L2.178|
0000b2  1e49              SUBS     r1,r1,#1              ;727
                  |L2.180|
0000b4  2c01              CMP      r4,#1                 ;720
0000b6  d101              BNE      |L2.188|
0000b8  2900              CMP      r1,#0                 ;721
0000ba  d1f2              BNE      |L2.162|
                  |L2.188|
0000bc  4620              MOV      r0,r4                 ;730
0000be  e7a6              B        |L2.14|
;;;732    
                          ENDP


                          AREA ||i.Mem_DynPoolBlkFree||, CODE, READONLY, ALIGN=1

                  Mem_DynPoolBlkFree PROC
;;;2062   
;;;2063   void  Mem_DynPoolBlkFree (MEM_DYN_POOL  *p_pool,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;2064                             void          *p_blk,
;;;2065                             LIB_ERR       *p_err)
;;;2066   {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
;;;2067       CPU_SR_ALLOC();
00000a  2700              MOVS     r7,#0
;;;2068   
;;;2069   
;;;2070   #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
;;;2071       if (p_err == DEF_NULL) {                                    /* Chk for NULL err ptr.                                */
;;;2072           CPU_SW_EXCEPTION(;);
;;;2073       }
;;;2074   
;;;2075       if (p_pool == DEF_NULL) {                                   /* Chk for NULL pool data ptr.                          */
;;;2076          *p_err = LIB_MEM_ERR_NULL_PTR;
;;;2077           return;
;;;2078       }
;;;2079   
;;;2080       if (p_blk == DEF_NULL) {
;;;2081          *p_err = LIB_MEM_ERR_NULL_PTR;
;;;2082           return;
;;;2083       }
;;;2084   #endif
;;;2085   
;;;2086       if (p_pool->BlkQtyMax != LIB_MEM_BLK_QTY_UNLIMITED) {       /* Ensure pool is not full.                             */
00000c  6960              LDR      r0,[r4,#0x14]
00000e  b1f0              CBZ      r0,|L3.78|
;;;2087           CPU_CRITICAL_ENTER();
000010  bf00              NOP      
000012  bf00              NOP      
000014  f7fffffe          BL       CPU_SR_Save
000018  4607              MOV      r7,r0
00001a  bf00              NOP      
00001c  bf00              NOP      
;;;2088           if (p_pool->BlkAllocCnt == 0u) {
00001e  69a0              LDR      r0,[r4,#0x18]
000020  b958              CBNZ     r0,|L3.58|
;;;2089               CPU_CRITICAL_EXIT();
000022  bf00              NOP      
000024  bf00              NOP      
000026  4638              MOV      r0,r7
000028  f7fffffe          BL       CPU_SR_Restore
00002c  bf00              NOP      
00002e  bf00              NOP      
;;;2090   
;;;2091              *p_err = LIB_MEM_ERR_POOL_FULL;
000030  f24270dd          MOV      r0,#0x27dd
000034  8030              STRH     r0,[r6,#0]
                  |L3.54|
;;;2092               return;
;;;2093           }
;;;2094   
;;;2095           p_pool->BlkAllocCnt--;
;;;2096           CPU_CRITICAL_EXIT();
;;;2097       }
;;;2098   
;;;2099       CPU_CRITICAL_ENTER();
;;;2100      *((void **)p_blk)   = p_pool->BlkFreePtr;
;;;2101       p_pool->BlkFreePtr = p_blk;
;;;2102       CPU_CRITICAL_EXIT();
;;;2103   
;;;2104      *p_err = LIB_MEM_ERR_NONE;
;;;2105   }
000036  e8bd81f0          POP      {r4-r8,pc}
                  |L3.58|
00003a  69a0              LDR      r0,[r4,#0x18]         ;2095
00003c  1e40              SUBS     r0,r0,#1              ;2095
00003e  61a0              STR      r0,[r4,#0x18]         ;2095
000040  bf00              NOP                            ;2096
000042  bf00              NOP                            ;2096
000044  4638              MOV      r0,r7                 ;2096
000046  f7fffffe          BL       CPU_SR_Restore
00004a  bf00              NOP                            ;2096
00004c  bf00              NOP                            ;2096
                  |L3.78|
00004e  bf00              NOP                            ;2099
000050  bf00              NOP                            ;2099
000052  f7fffffe          BL       CPU_SR_Save
000056  4607              MOV      r7,r0                 ;2099
000058  bf00              NOP                            ;2099
00005a  bf00              NOP                            ;2099
00005c  6920              LDR      r0,[r4,#0x10]         ;2100
00005e  6028              STR      r0,[r5,#0]            ;2100
000060  6125              STR      r5,[r4,#0x10]         ;2101
000062  bf00              NOP                            ;2102
000064  bf00              NOP                            ;2102
000066  4638              MOV      r0,r7                 ;2102
000068  f7fffffe          BL       CPU_SR_Restore
00006c  bf00              NOP                            ;2102
00006e  bf00              NOP                            ;2102
000070  f2427010          MOV      r0,#0x2710            ;2104
000074  8030              STRH     r0,[r6,#0]            ;2104
000076  bf00              NOP      
000078  e7dd              B        |L3.54|
;;;2106   
                          ENDP


                          AREA ||i.Mem_DynPoolBlkGet||, CODE, READONLY, ALIGN=1

                  Mem_DynPoolBlkGet PROC
;;;1971   
;;;1972   void  *Mem_DynPoolBlkGet (MEM_DYN_POOL  *p_pool,
000000  e92d43fe          PUSH     {r1-r9,lr}
;;;1973                             LIB_ERR       *p_err)
;;;1974   {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;1975              void      *p_blk;
;;;1976       const  CPU_CHAR  *p_pool_name;
;;;1977       CPU_SR_ALLOC();
000008  f04f0800          MOV      r8,#0
;;;1978   
;;;1979   
;;;1980   #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
;;;1981       if (p_err == DEF_NULL) {                                    /* Chk for NULL err ptr.                                */
;;;1982           CPU_SW_EXCEPTION(DEF_NULL);
;;;1983       }
;;;1984   
;;;1985       if (p_pool == DEF_NULL) {                                   /* Chk for NULL pool data ptr.                          */
;;;1986          *p_err = LIB_MEM_ERR_NULL_PTR;
;;;1987           return (DEF_NULL);
;;;1988       }
;;;1989   #endif
;;;1990   
;;;1991                                                                   /* Ensure pool is not empty if qty is limited.          */
;;;1992       if (p_pool->BlkQtyMax != LIB_MEM_BLK_QTY_UNLIMITED) {
00000c  6960              LDR      r0,[r4,#0x14]
00000e  b308              CBZ      r0,|L4.84|
;;;1993           CPU_CRITICAL_ENTER();
000010  bf00              NOP      
000012  bf00              NOP      
000014  f7fffffe          BL       CPU_SR_Save
000018  4680              MOV      r8,r0
00001a  bf00              NOP      
00001c  bf00              NOP      
;;;1994           if (p_pool->BlkAllocCnt >= p_pool->BlkQtyMax) {
00001e  e9d41005          LDRD     r1,r0,[r4,#0x14]
000022  4288              CMP      r0,r1
000024  d30c              BCC      |L4.64|
;;;1995               CPU_CRITICAL_EXIT();
000026  bf00              NOP      
000028  bf00              NOP      
00002a  4640              MOV      r0,r8
00002c  f7fffffe          BL       CPU_SR_Restore
000030  bf00              NOP      
000032  bf00              NOP      
;;;1996   
;;;1997              *p_err = LIB_MEM_ERR_POOL_EMPTY;
000034  f24270de          MOV      r0,#0x27de
000038  8028              STRH     r0,[r5,#0]
;;;1998               return (DEF_NULL);
00003a  2000              MOVS     r0,#0
                  |L4.60|
;;;1999           }
;;;2000   
;;;2001           p_pool->BlkAllocCnt++;
;;;2002           CPU_CRITICAL_EXIT();
;;;2003       }
;;;2004   
;;;2005                                                                   /* --------------- ALLOC FROM FREE LIST --------------- */
;;;2006       CPU_CRITICAL_ENTER();
;;;2007       if (p_pool->BlkFreePtr != DEF_NULL) {
;;;2008           p_blk              = p_pool->BlkFreePtr;
;;;2009           p_pool->BlkFreePtr = *((void **)p_blk);
;;;2010           CPU_CRITICAL_EXIT();
;;;2011   
;;;2012          *p_err = LIB_MEM_ERR_NONE;
;;;2013   
;;;2014           return (p_blk);
;;;2015       }
;;;2016       CPU_CRITICAL_EXIT();
;;;2017   
;;;2018                                                                   /* ------------------ ALLOC NEW BLK ------------------- */
;;;2019   #if (LIB_MEM_CFG_DBG_INFO_EN == DEF_ENABLED)
;;;2020       p_pool_name = p_pool->NamePtr;
;;;2021   #else
;;;2022       p_pool_name = DEF_NULL;
;;;2023   #endif
;;;2024       p_blk = Mem_SegAllocInternal(p_pool_name,
;;;2025                                    p_pool->PoolSegPtr,
;;;2026                                    p_pool->BlkSize,
;;;2027                                    p_pool->BlkAlign,
;;;2028                                    p_pool->BlkPaddingAlign,
;;;2029                                    DEF_NULL,
;;;2030                                    p_err);
;;;2031       if (*p_err != LIB_MEM_ERR_NONE) {
;;;2032           return (DEF_NULL);
;;;2033       }
;;;2034   
;;;2035       return (p_blk);
;;;2036   }
00003c  e8bd83fe          POP      {r1-r9,pc}
                  |L4.64|
000040  69a0              LDR      r0,[r4,#0x18]         ;2001
000042  1c40              ADDS     r0,r0,#1              ;2001
000044  61a0              STR      r0,[r4,#0x18]         ;2001
000046  bf00              NOP                            ;2002
000048  bf00              NOP                            ;2002
00004a  4640              MOV      r0,r8                 ;2002
00004c  f7fffffe          BL       CPU_SR_Restore
000050  bf00              NOP                            ;2002
000052  bf00              NOP                            ;2002
                  |L4.84|
000054  bf00              NOP                            ;2006
000056  bf00              NOP                            ;2006
000058  f7fffffe          BL       CPU_SR_Save
00005c  4680              MOV      r8,r0                 ;2006
00005e  bf00              NOP                            ;2006
000060  bf00              NOP                            ;2006
000062  6920              LDR      r0,[r4,#0x10]         ;2007
000064  b170              CBZ      r0,|L4.132|
000066  6926              LDR      r6,[r4,#0x10]         ;2008
000068  6830              LDR      r0,[r6,#0]            ;2009
00006a  6120              STR      r0,[r4,#0x10]         ;2009
00006c  bf00              NOP                            ;2010
00006e  bf00              NOP                            ;2010
000070  4640              MOV      r0,r8                 ;2010
000072  f7fffffe          BL       CPU_SR_Restore
000076  bf00              NOP                            ;2010
000078  bf00              NOP                            ;2010
00007a  f2427010          MOV      r0,#0x2710            ;2012
00007e  8028              STRH     r0,[r5,#0]            ;2012
000080  4630              MOV      r0,r6                 ;2014
000082  e7db              B        |L4.60|
                  |L4.132|
000084  bf00              NOP                            ;2016
000086  bf00              NOP                            ;2016
000088  4640              MOV      r0,r8                 ;2016
00008a  f7fffffe          BL       CPU_SR_Restore
00008e  bf00              NOP                            ;2016
000090  bf00              NOP                            ;2016
000092  2700              MOVS     r7,#0                 ;2022
000094  2100              MOVS     r1,#0                 ;2024
000096  68e0              LDR      r0,[r4,#0xc]          ;2024
000098  e88d0023          STM      sp,{r0,r1,r5}         ;2024
00009c  4638              MOV      r0,r7                 ;2024
00009e  e894000e          LDM      r4,{r1-r3}            ;2024
0000a2  f7fffffe          BL       Mem_SegAllocInternal
0000a6  4606              MOV      r6,r0                 ;2024
0000a8  8828              LDRH     r0,[r5,#0]            ;2031
0000aa  f2427110          MOV      r1,#0x2710            ;2031
0000ae  4288              CMP      r0,r1                 ;2031
0000b0  d001              BEQ      |L4.182|
0000b2  2000              MOVS     r0,#0                 ;2032
0000b4  e7c2              B        |L4.60|
                  |L4.182|
0000b6  4630              MOV      r0,r6                 ;2035
0000b8  e7c0              B        |L4.60|
;;;2037   
                          ENDP


                          AREA ||i.Mem_DynPoolBlkNbrAvailGet||, CODE, READONLY, ALIGN=1

                  Mem_DynPoolBlkNbrAvailGet PROC
;;;2132   
;;;2133   CPU_SIZE_T  Mem_DynPoolBlkNbrAvailGet (MEM_DYN_POOL  *p_pool,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;2134                                          LIB_ERR       *p_err)
;;;2135   {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;2136       CPU_SIZE_T  blk_nbr_avail;
;;;2137       CPU_SR_ALLOC();
000008  2700              MOVS     r7,#0
;;;2138   
;;;2139   
;;;2140   #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
;;;2141       if (p_err == DEF_NULL) {                                    /* Chk for NULL err ptr.                                */
;;;2142           CPU_SW_EXCEPTION(;);
;;;2143       }
;;;2144   
;;;2145       if (p_pool == DEF_NULL) {                                   /* Chk for NULL pool data ptr.                          */
;;;2146          *p_err = LIB_MEM_ERR_NULL_PTR;
;;;2147           return (0u);
;;;2148       }
;;;2149   #endif
;;;2150   
;;;2151       if (p_pool->BlkQtyMax != LIB_MEM_BLK_QTY_UNLIMITED) {
00000a  6960              LDR      r0,[r4,#0x14]
00000c  b1a0              CBZ      r0,|L5.56|
;;;2152           CPU_CRITICAL_ENTER();
00000e  bf00              NOP      
000010  bf00              NOP      
000012  f7fffffe          BL       CPU_SR_Save
000016  4607              MOV      r7,r0
000018  bf00              NOP      
00001a  bf00              NOP      
;;;2153           blk_nbr_avail = p_pool->BlkQtyMax - p_pool->BlkAllocCnt;
00001c  e9d40105          LDRD     r0,r1,[r4,#0x14]
000020  1a46              SUBS     r6,r0,r1
;;;2154           CPU_CRITICAL_EXIT();
000022  bf00              NOP      
000024  bf00              NOP      
000026  4638              MOV      r0,r7
000028  f7fffffe          BL       CPU_SR_Restore
00002c  bf00              NOP      
00002e  bf00              NOP      
;;;2155   
;;;2156          *p_err = LIB_MEM_ERR_NONE;
000030  f2427010          MOV      r0,#0x2710
000034  8028              STRH     r0,[r5,#0]
000036  e003              B        |L5.64|
                  |L5.56|
;;;2157       } else {
;;;2158           blk_nbr_avail = 0u;
000038  2600              MOVS     r6,#0
;;;2159          *p_err         = LIB_MEM_ERR_POOL_UNLIMITED;
00003a  f24270df          MOV      r0,#0x27df
00003e  8028              STRH     r0,[r5,#0]
                  |L5.64|
;;;2160       }
;;;2161   
;;;2162       return (blk_nbr_avail);
000040  4630              MOV      r0,r6
;;;2163   }
000042  e8bd81f0          POP      {r4-r8,pc}
;;;2164   
                          ENDP


                          AREA ||i.Mem_DynPoolCreate||, CODE, READONLY, ALIGN=2

                  Mem_DynPoolCreate PROC
;;;1839   
;;;1840   void  Mem_DynPoolCreate (const  CPU_CHAR      *p_name,
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;1841                                   MEM_DYN_POOL  *p_pool,
;;;1842                                   MEM_SEG       *p_seg,
;;;1843                                   CPU_SIZE_T     blk_size,
;;;1844                                   CPU_SIZE_T     blk_align,
;;;1845                                   CPU_SIZE_T     blk_qty_init,
;;;1846                                   CPU_SIZE_T     blk_qty_max,
;;;1847                                   LIB_ERR       *p_err)
;;;1848   {
000004  b085              SUB      sp,sp,#0x14
000006  4605              MOV      r5,r0
000008  460e              MOV      r6,r1
00000a  4614              MOV      r4,r2
00000c  461f              MOV      r7,r3
00000e  e9ddab10          LDRD     r10,r11,[sp,#0x40]
000012  e9dd890e          LDRD     r8,r9,[sp,#0x38]
;;;1849       if (p_seg == DEF_NULL) {                                    /* Alloc from heap if p_seg is null.                    */
000016  b904              CBNZ     r4,|L6.26|
;;;1850   #if (LIB_MEM_CFG_HEAP_SIZE > 0u)
;;;1851           p_seg = &Mem_SegHeap;
000018  4c08              LDR      r4,|L6.60|
                  |L6.26|
;;;1852   #else
;;;1853          *p_err = LIB_MEM_ERR_NULL_PTR;
;;;1854           return (DEF_NULL);
;;;1855   #endif
;;;1856       }
;;;1857   
;;;1858       Mem_DynPoolCreateInternal(p_name,
00001a  2001              MOVS     r0,#1
00001c  463b              MOV      r3,r7
00001e  4622              MOV      r2,r4
000020  4631              MOV      r1,r6
000022  e9cdab03          STRD     r10,r11,[sp,#0xc]
000026  e9cd0901          STRD     r0,r9,[sp,#4]
00002a  f8cd8000          STR      r8,[sp,#0]
00002e  4628              MOV      r0,r5
000030  f7fffffe          BL       Mem_DynPoolCreateInternal
;;;1859                                 p_pool,
;;;1860                                 p_seg,
;;;1861                                 blk_size,
;;;1862                                 blk_align,
;;;1863                                 LIB_MEM_PADDING_ALIGN_NONE,
;;;1864                                 blk_qty_init,
;;;1865                                 blk_qty_max,
;;;1866                                 p_err);
;;;1867   }
000034  b005              ADD      sp,sp,#0x14
000036  e8bd8ff0          POP      {r4-r11,pc}
;;;1868   
                          ENDP

00003a  0000              DCW      0x0000
                  |L6.60|
                          DCD      Mem_SegHeap

                          AREA ||i.Mem_DynPoolCreateHW||, CODE, READONLY, ALIGN=2

                  Mem_DynPoolCreateHW PROC
;;;1911   
;;;1912   void  Mem_DynPoolCreateHW (const  CPU_CHAR      *p_name,
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;1913                                     MEM_DYN_POOL  *p_pool,
;;;1914                                     MEM_SEG       *p_seg,
;;;1915                                     CPU_SIZE_T     blk_size,
;;;1916                                     CPU_SIZE_T     blk_align,
;;;1917                                     CPU_SIZE_T     blk_qty_init,
;;;1918                                     CPU_SIZE_T     blk_qty_max,
;;;1919                                     LIB_ERR       *p_err)
;;;1920   {
000004  b085              SUB      sp,sp,#0x14
000006  4605              MOV      r5,r0
000008  460e              MOV      r6,r1
00000a  4614              MOV      r4,r2
00000c  461f              MOV      r7,r3
00000e  e9ddab10          LDRD     r10,r11,[sp,#0x40]
000012  e9dd890e          LDRD     r8,r9,[sp,#0x38]
;;;1921       if (p_seg == DEF_NULL) {                                    /* Alloc from heap if p_seg is null.                    */
000016  b904              CBNZ     r4,|L7.26|
;;;1922   #if (LIB_MEM_CFG_HEAP_SIZE > 0u)
;;;1923           p_seg = &Mem_SegHeap;
000018  4c08              LDR      r4,|L7.60|
                  |L7.26|
;;;1924   #else
;;;1925          *p_err = LIB_MEM_ERR_NULL_PTR;
;;;1926           return (DEF_NULL);
;;;1927   #endif
;;;1928       }
;;;1929   
;;;1930       Mem_DynPoolCreateInternal(p_name,
00001a  6920              LDR      r0,[r4,#0x10]
00001c  463b              MOV      r3,r7
00001e  4622              MOV      r2,r4
000020  4631              MOV      r1,r6
000022  e9cdab03          STRD     r10,r11,[sp,#0xc]
000026  e9cd0901          STRD     r0,r9,[sp,#4]
00002a  f8cd8000          STR      r8,[sp,#0]
00002e  4628              MOV      r0,r5
000030  f7fffffe          BL       Mem_DynPoolCreateInternal
;;;1931                                 p_pool,
;;;1932                                 p_seg,
;;;1933                                 blk_size,
;;;1934                                 blk_align,
;;;1935                                 p_seg->PaddingAlign,
;;;1936                                 blk_qty_init,
;;;1937                                 blk_qty_max,
;;;1938                                 p_err);
;;;1939   }
000034  b005              ADD      sp,sp,#0x14
000036  e8bd8ff0          POP      {r4-r11,pc}
;;;1940   
                          ENDP

00003a  0000              DCW      0x0000
                  |L7.60|
                          DCD      Mem_SegHeap

                          AREA ||i.Mem_DynPoolCreateInternal||, CODE, READONLY, ALIGN=1

                  Mem_DynPoolCreateInternal PROC
;;;2705   
;;;2706   static  void  Mem_DynPoolCreateInternal (const  CPU_CHAR      *p_name,
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;2707                                                   MEM_DYN_POOL  *p_pool,
;;;2708                                                   MEM_SEG       *p_seg,
;;;2709                                                   CPU_SIZE_T     blk_size,
;;;2710                                                   CPU_SIZE_T     blk_align,
;;;2711                                                   CPU_SIZE_T     blk_padding_align,
;;;2712                                                   CPU_SIZE_T     blk_qty_init,
;;;2713                                                   CPU_SIZE_T     blk_qty_max,
;;;2714                                                   LIB_ERR       *p_err)
;;;2715   {
000004  b083              SUB      sp,sp,#0xc
000006  460c              MOV      r4,r1
000008  4692              MOV      r10,r2
00000a  461f              MOV      r7,r3
00000c  f8ddb050          LDR      r11,[sp,#0x50]
000010  f8dd9048          LDR      r9,[sp,#0x48]
;;;2716       CPU_INT08U  *p_blks;
;;;2717       CPU_SIZE_T   blk_size_align;
;;;2718       CPU_SIZE_T   blk_align_worst = DEF_MAX(blk_align, blk_padding_align);
000014  e9dd0110          LDRD     r0,r1,[sp,#0x40]
000018  4288              CMP      r0,r1
00001a  d901              BLS      |L8.32|
00001c  9810              LDR      r0,[sp,#0x40]
00001e  e000              B        |L8.34|
                  |L8.32|
000020  9811              LDR      r0,[sp,#0x44]
                  |L8.34|
000022  4606              MOV      r6,r0
;;;2719   
;;;2720   
;;;2721   #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
;;;2722       if (p_err == DEF_NULL) {                                    /* Chk for NULL err ptr.                                */
;;;2723           CPU_SW_EXCEPTION(DEF_NULL);
;;;2724       }
;;;2725   
;;;2726       if (p_pool == DEF_NULL) {                                   /* Chk for NULL pool data ptr.                          */
;;;2727          *p_err = LIB_MEM_ERR_NULL_PTR;
;;;2728           return;
;;;2729       }
;;;2730   
;;;2731       if (blk_size < 1u) {                                        /* Chk for inv blk size.                                */
;;;2732          *p_err = LIB_MEM_ERR_INVALID_BLK_SIZE;
;;;2733           return;
;;;2734       }
;;;2735   
;;;2736       if ((blk_qty_max  != LIB_MEM_BLK_QTY_UNLIMITED) &&          /* Chk for invalid blk qty.                             */
;;;2737           (blk_qty_init >  blk_qty_max)) {
;;;2738          *p_err = LIB_MEM_ERR_INVALID_BLK_NBR;
;;;2739           return;
;;;2740       }
;;;2741   
;;;2742       if (MATH_IS_PWR2(blk_align) != DEF_YES) {                   /* Chk for illegal align spec.                          */
;;;2743          *p_err = LIB_MEM_ERR_INVALID_BLK_ALIGN;
;;;2744           return;
;;;2745       }
;;;2746   #endif
;;;2747   
;;;2748                                                                   /* Calc blk size with align.                            */
;;;2749       if (blk_size < sizeof(void *)) {                            /* If size if smaller than ptr ...                      */
000024  2f04              CMP      r7,#4
000026  d20d              BCS      |L8.68|
;;;2750                                                                   /* ... inc size to ptr size.                            */
;;;2751           blk_size_align = MATH_ROUND_INC_UP_PWR2(sizeof(void *), blk_align_worst);
000028  1e70              SUBS     r0,r6,#1
00002a  2104              MOVS     r1,#4
00002c  ea210000          BIC      r0,r1,r0
000030  1e71              SUBS     r1,r6,#1
000032  f0010104          AND      r1,r1,#4
000036  b909              CBNZ     r1,|L8.60|
000038  2100              MOVS     r1,#0
00003a  e000              B        |L8.62|
                  |L8.60|
00003c  4631              MOV      r1,r6
                  |L8.62|
00003e  eb000801          ADD      r8,r0,r1
000042  e009              B        |L8.88|
                  |L8.68|
;;;2752       } else {
;;;2753           blk_size_align = MATH_ROUND_INC_UP_PWR2(blk_size, blk_align_worst);
000044  1e70              SUBS     r0,r6,#1
000046  ea270100          BIC      r1,r7,r0
00004a  4038              ANDS     r0,r0,r7
00004c  b908              CBNZ     r0,|L8.82|
00004e  2000              MOVS     r0,#0
000050  e000              B        |L8.84|
                  |L8.82|
000052  4630              MOV      r0,r6
                  |L8.84|
000054  eb010800          ADD      r8,r1,r0
                  |L8.88|
;;;2754       }
;;;2755   
;;;2756       if (blk_qty_init != 0u) {                                   /* Alloc init blks.                                     */
000058  f1b90f00          CMP      r9,#0
00005c  d015              BEQ      |L8.138|
;;;2757           p_blks = (CPU_INT08U *)Mem_SegAllocInternal(p_name,
00005e  2000              MOVS     r0,#0
000060  2101              MOVS     r1,#1
000062  fb08f209          MUL      r2,r8,r9
000066  4633              MOV      r3,r6
000068  e9cd0b01          STRD     r0,r11,[sp,#4]
00006c  9100              STR      r1,[sp,#0]
00006e  4651              MOV      r1,r10
000070  9803              LDR      r0,[sp,#0xc]
000072  f7fffffe          BL       Mem_SegAllocInternal
000076  4605              MOV      r5,r0
;;;2758                                                       p_seg,
;;;2759                                                       blk_size_align * blk_qty_init,
;;;2760                                                       blk_align_worst,
;;;2761                                                       LIB_MEM_PADDING_ALIGN_NONE,
;;;2762                                                       DEF_NULL,
;;;2763                                                       p_err);
;;;2764           if (*p_err != LIB_MEM_ERR_NONE) {
000078  f8bb0000          LDRH     r0,[r11,#0]
00007c  f2427110          MOV      r1,#0x2710
000080  4288              CMP      r0,r1
000082  d002              BEQ      |L8.138|
                  |L8.132|
;;;2765               return;
;;;2766           }
;;;2767       }
;;;2768   
;;;2769   
;;;2770                                                                   /* ----------------- CREATE POOL DATA ----------------- */
;;;2771       p_pool->PoolSegPtr      = p_seg;
;;;2772       p_pool->BlkSize         = blk_size;
;;;2773       p_pool->BlkAlign        = blk_align_worst;
;;;2774       p_pool->BlkPaddingAlign = blk_padding_align;
;;;2775       p_pool->BlkQtyMax       = blk_qty_max;
;;;2776       p_pool->BlkAllocCnt     = 0u;
;;;2777   
;;;2778       if (blk_qty_init != 0u) {                                   /* Init free list.                                      */
;;;2779           CPU_SIZE_T  i;
;;;2780   
;;;2781   
;;;2782           p_pool->BlkFreePtr = (void *)p_blks;
;;;2783           for (i = 0u; i < blk_qty_init - 1u; i++) {
;;;2784              *((void **)p_blks)  = p_blks + blk_size_align;
;;;2785               p_blks            += blk_size_align;
;;;2786           }
;;;2787          *((void **)p_blks) = DEF_NULL;
;;;2788       } else {
;;;2789           p_pool->BlkFreePtr = DEF_NULL;
;;;2790       }
;;;2791   
;;;2792   #if (LIB_MEM_CFG_DBG_INFO_EN == DEF_ENABLED)
;;;2793       p_pool->NamePtr = p_name;
;;;2794   #endif
;;;2795   
;;;2796      *p_err = LIB_MEM_ERR_NONE;
;;;2797   }
000084  b007              ADD      sp,sp,#0x1c
000086  e8bd8ff0          POP      {r4-r11,pc}
                  |L8.138|
00008a  f8c4a000          STR      r10,[r4,#0]           ;2771
00008e  6067              STR      r7,[r4,#4]            ;2772
000090  60a6              STR      r6,[r4,#8]            ;2773
000092  9811              LDR      r0,[sp,#0x44]         ;2774
000094  60e0              STR      r0,[r4,#0xc]          ;2774
000096  9813              LDR      r0,[sp,#0x4c]         ;2775
000098  6160              STR      r0,[r4,#0x14]         ;2775
00009a  2000              MOVS     r0,#0                 ;2776
00009c  61a0              STR      r0,[r4,#0x18]         ;2776
00009e  f1b90f00          CMP      r9,#0                 ;2778
0000a2  d00e              BEQ      |L8.194|
0000a4  6125              STR      r5,[r4,#0x10]         ;2782
0000a6  bf00              NOP                            ;2783
0000a8  e004              B        |L8.180|
                  |L8.170|
0000aa  eb050108          ADD      r1,r5,r8              ;2784
0000ae  6029              STR      r1,[r5,#0]            ;2784
0000b0  4445              ADD      r5,r5,r8              ;2785
0000b2  1c40              ADDS     r0,r0,#1              ;2783
                  |L8.180|
0000b4  f1a90101          SUB      r1,r9,#1              ;2783
0000b8  4281              CMP      r1,r0                 ;2783
0000ba  d8f6              BHI      |L8.170|
0000bc  2100              MOVS     r1,#0                 ;2787
0000be  6029              STR      r1,[r5,#0]            ;2787
0000c0  e001              B        |L8.198|
                  |L8.194|
0000c2  2000              MOVS     r0,#0                 ;2789
0000c4  6120              STR      r0,[r4,#0x10]         ;2789
                  |L8.198|
0000c6  f2427010          MOV      r0,#0x2710            ;2796
0000ca  f8ab0000          STRH     r0,[r11,#0]           ;2796
0000ce  bf00              NOP      
0000d0  e7d8              B        |L8.132|
;;;2798   
                          ENDP


                          AREA ||i.Mem_HeapAlloc||, CODE, READONLY, ALIGN=2

                  Mem_HeapAlloc PROC
;;;774    #if (LIB_MEM_CFG_HEAP_SIZE > 0u)
;;;775    void  *Mem_HeapAlloc (CPU_SIZE_T   size,
000000  e92d43fe          PUSH     {r1-r9,lr}
;;;776                          CPU_SIZE_T   align,
;;;777                          CPU_SIZE_T  *p_bytes_reqd,
;;;778                          LIB_ERR     *p_err)
;;;779    {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
00000a  461c              MOV      r4,r3
;;;780        void  *p_mem;
;;;781    
;;;782    
;;;783        p_mem = Mem_SegAllocInternal(DEF_NULL,
00000c  2001              MOVS     r0,#1
00000e  4633              MOV      r3,r6
000010  462a              MOV      r2,r5
000012  4909              LDR      r1,|L9.56|
000014  e9cd7401          STRD     r7,r4,[sp,#4]
000018  9000              STR      r0,[sp,#0]
00001a  2000              MOVS     r0,#0
00001c  f7fffffe          BL       Mem_SegAllocInternal
000020  4680              MOV      r8,r0
;;;784                                    &Mem_SegHeap,
;;;785                                     size,
;;;786                                     align,
;;;787                                     LIB_MEM_CFG_HEAP_PADDING_ALIGN,
;;;788                                     p_bytes_reqd,
;;;789                                     p_err);
;;;790        if (*p_err == LIB_MEM_ERR_SEG_OVF) {
000022  8820              LDRH     r0,[r4,#0]
000024  f24271d9          MOV      r1,#0x27d9
000028  4288              CMP      r0,r1
00002a  d102              BNE      |L9.50|
;;;791           *p_err = LIB_MEM_ERR_HEAP_OVF;
00002c  f24270e3          MOV      r0,#0x27e3
000030  8020              STRH     r0,[r4,#0]
                  |L9.50|
;;;792        }
;;;793    
;;;794        return (p_mem);
000032  4640              MOV      r0,r8
;;;795    }
000034  e8bd83fe          POP      {r1-r9,pc}
;;;796    #endif
                          ENDP

                  |L9.56|
                          DCD      Mem_SegHeap

                          AREA ||i.Mem_HeapGetSizeRem||, CODE, READONLY, ALIGN=2

                  Mem_HeapGetSizeRem PROC
;;;826    #if (LIB_MEM_CFG_HEAP_SIZE > 0u)
;;;827    CPU_SIZE_T  Mem_HeapGetSizeRem (CPU_SIZE_T   align,
000000  b570              PUSH     {r4-r6,lr}
;;;828                                    LIB_ERR     *p_err)
;;;829    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;830        CPU_SIZE_T  rem_size;
;;;831    
;;;832    
;;;833        rem_size = Mem_SegRemSizeGet(&Mem_SegHeap,
000006  4623              MOV      r3,r4
000008  2200              MOVS     r2,#0
00000a  4629              MOV      r1,r5
00000c  4806              LDR      r0,|L10.40|
00000e  f7fffffe          BL       Mem_SegRemSizeGet
000012  4606              MOV      r6,r0
;;;834                                      align,
;;;835                                      DEF_NULL,
;;;836                                      p_err);
;;;837        if (*p_err != LIB_MEM_ERR_NONE) {
000014  8820              LDRH     r0,[r4,#0]
000016  f2427110          MOV      r1,#0x2710
00001a  4288              CMP      r0,r1
00001c  d001              BEQ      |L10.34|
;;;838            return (0u);
00001e  2000              MOVS     r0,#0
                  |L10.32|
;;;839        }
;;;840    
;;;841        return (rem_size);
;;;842    }
000020  bd70              POP      {r4-r6,pc}
                  |L10.34|
000022  4630              MOV      r0,r6                 ;841
000024  e7fc              B        |L10.32|
;;;843    #endif
                          ENDP

000026  0000              DCW      0x0000
                  |L10.40|
                          DCD      Mem_SegHeap

                          AREA ||i.Mem_Init||, CODE, READONLY, ALIGN=2

                  Mem_Init PROC
;;;206    
;;;207    void  Mem_Init (void)
000000  b53e              PUSH     {r1-r5,lr}
;;;208    {
;;;209    
;;;210                                                                    /* ------------------ INIT SEG LIST ------------------- */
;;;211        Mem_SegHeadPtr = DEF_NULL;
000002  2000              MOVS     r0,#0
000004  490c              LDR      r1,|L11.56|
000006  6008              STR      r0,[r1,#0]  ; Mem_SegHeadPtr
;;;212    
;;;213    #if (LIB_MEM_CFG_HEAP_SIZE > 0u)
;;;214        {
;;;215            LIB_ERR   err;
;;;216            CPU_ADDR  heap_base_addr;
;;;217    
;;;218    
;;;219                                                                    /* ------------------ INIT HEAP SEG ------------------- */
;;;220    #ifdef  LIB_MEM_CFG_HEAP_BASE_ADDR
;;;221            heap_base_addr = LIB_MEM_CFG_HEAP_BASE_ADDR;
;;;222    #else
;;;223            heap_base_addr = (CPU_ADDR)&Mem_Heap[0u];
000008  4c0c              LDR      r4,|L11.60|
;;;224    #endif
;;;225    
;;;226            Mem_SegCreate("Heap",
00000a  a802              ADD      r0,sp,#8
00000c  2101              MOVS     r1,#1
00000e  f44f6340          MOV      r3,#0xc00
000012  4622              MOV      r2,r4
000014  e9cd1000          STRD     r1,r0,[sp,#0]
000018  4909              LDR      r1,|L11.64|
00001a  a00a              ADR      r0,|L11.68|
00001c  f7fffffe          BL       Mem_SegCreate
;;;227                          &Mem_SegHeap,                             /* Create heap seg.                                     */
;;;228                           heap_base_addr,
;;;229                           LIB_MEM_CFG_HEAP_SIZE,
;;;230                           LIB_MEM_PADDING_ALIGN_NONE,
;;;231                          &err);
;;;232            if (err != LIB_MEM_ERR_NONE) {
000020  f8bd0008          LDRH     r0,[sp,#8]
000024  f2427110          MOV      r1,#0x2710
000028  4288              CMP      r0,r1
00002a  d003              BEQ      |L11.52|
;;;233                CPU_SW_EXCEPTION(;);
00002c  bf00              NOP      
00002e  f7fffffe          BL       CPU_SW_Exception
000032  bf00              NOP      
                  |L11.52|
;;;234            }
;;;235        }
;;;236    #endif
;;;237    }
000034  bd3e              POP      {r1-r5,pc}
;;;238    
                          ENDP

000036  0000              DCW      0x0000
                  |L11.56|
                          DCD      Mem_SegHeadPtr
                  |L11.60|
                          DCD      Mem_Heap
                  |L11.64|
                          DCD      Mem_SegHeap
                  |L11.68|
000044  48656170          DCB      "Heap",0
000048  00      
000049  00                DCB      0
00004a  00                DCB      0
00004b  00                DCB      0

                          AREA ||i.Mem_Move||, CODE, READONLY, ALIGN=1

                  Mem_Move PROC
;;;521    
;;;522    void  Mem_Move (       void        *pdest,
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;523                    const  void        *psrc,
;;;524                           CPU_SIZE_T   size)
;;;525    {
000004  b085              SUB      sp,sp,#0x14
000006  4607              MOV      r7,r0
000008  4688              MOV      r8,r1
00000a  4691              MOV      r9,r2
;;;526               CPU_SIZE_T    size_rem;
;;;527               CPU_SIZE_T    mem_gap_octets;
;;;528               CPU_ALIGN    *pmem_align_dest;
;;;529        const  CPU_ALIGN    *pmem_align_src;
;;;530               CPU_INT08U   *pmem_08_dest;
;;;531        const  CPU_INT08U   *pmem_08_src;
;;;532               CPU_INT08S    i;
;;;533               CPU_DATA      mem_align_mod_dest;
;;;534               CPU_DATA      mem_align_mod_src;
;;;535               CPU_BOOLEAN   mem_aligned;
;;;536    
;;;537    
;;;538    #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
;;;539        if (size < 1) {
;;;540            return;
;;;541        }
;;;542        if (pdest == (void *)0) {
;;;543            return;
;;;544        }
;;;545        if (psrc  == (void *)0) {
;;;546            return;
;;;547        }
;;;548    #endif
;;;549    
;;;550        pmem_08_src  = (const CPU_INT08U *)psrc;
00000c  4646              MOV      r6,r8
;;;551        pmem_08_dest = (      CPU_INT08U *)pdest;
00000e  463d              MOV      r5,r7
;;;552        if (pmem_08_src > pmem_08_dest) {
000010  42ae              CMP      r6,r5
000012  d907              BLS      |L12.36|
;;;553            Mem_Copy(pdest, psrc, size);
000014  464a              MOV      r2,r9
000016  4641              MOV      r1,r8
000018  4638              MOV      r0,r7
00001a  f7fffffe          BL       Mem_Copy
                  |L12.30|
;;;554            return;
;;;555        }
;;;556    
;;;557        size_rem           =  size;
;;;558    
;;;559        pmem_08_dest       = (      CPU_INT08U *)pdest + size - 1;
;;;560        pmem_08_src        = (const CPU_INT08U *)psrc  + size - 1;
;;;561    
;;;562        mem_gap_octets     = pmem_08_dest - pmem_08_src;
;;;563    
;;;564    
;;;565        if (mem_gap_octets >= sizeof(CPU_ALIGN)) {                  /* Avoid bufs overlap.                                  */
;;;566    
;;;567                                                                    /* See Note #4.                                         */
;;;568            mem_align_mod_dest = (CPU_INT08U)((CPU_ADDR)pmem_08_dest % sizeof(CPU_ALIGN));
;;;569            mem_align_mod_src  = (CPU_INT08U)((CPU_ADDR)pmem_08_src  % sizeof(CPU_ALIGN));
;;;570    
;;;571            mem_aligned        = (mem_align_mod_dest == mem_align_mod_src) ? DEF_YES : DEF_NO;
;;;572    
;;;573            if (mem_aligned == DEF_YES) {                           /* If mem bufs' alignment offset equal, ...             */
;;;574                                                                    /* ... optimize copy for mem buf alignment.             */
;;;575                if (mem_align_mod_dest != (sizeof(CPU_ALIGN) - 1)) {/* If leading octets avail,                   ...       */
;;;576                    i = mem_align_mod_dest;
;;;577                    while ((size_rem   >  0) &&                     /* ... start mem buf copy with leading octets ...       */
;;;578                           (i          >= 0)) {                     /* ... until next CPU_ALIGN word boundary.              */
;;;579                       *pmem_08_dest-- = *pmem_08_src--;
;;;580                        size_rem      -=  sizeof(CPU_INT08U);
;;;581                        i--;
;;;582                    }
;;;583                }
;;;584    
;;;585                                                                    /* See Note #3.                                         */
;;;586                pmem_align_dest = (      CPU_ALIGN *)((CPU_INT08U *)pmem_08_dest - sizeof(CPU_ALIGN) + 1);
;;;587                pmem_align_src  = (const CPU_ALIGN *)((CPU_INT08U *)pmem_08_src  - sizeof(CPU_ALIGN) + 1);
;;;588                while (size_rem      >=  sizeof(CPU_ALIGN)) {       /* While mem bufs aligned on CPU_ALIGN word boundaries, */
;;;589                   *pmem_align_dest-- = *pmem_align_src--;          /* ... copy psrc to pdest with CPU_ALIGN-sized words.   */
;;;590                    size_rem         -=  sizeof(CPU_ALIGN);
;;;591                }
;;;592    
;;;593                pmem_08_dest = (      CPU_INT08U *)pmem_align_dest + sizeof(CPU_ALIGN) - 1;
;;;594                pmem_08_src  = (const CPU_INT08U *)pmem_align_src  + sizeof(CPU_ALIGN) - 1;
;;;595    
;;;596            }
;;;597        }
;;;598    
;;;599        while (size_rem > 0) {                                      /* For unaligned mem bufs or trailing octets, ...       */
;;;600           *pmem_08_dest-- = *pmem_08_src--;                        /* ... copy psrc to pdest by octets.                    */
;;;601            size_rem      -=  sizeof(CPU_INT08U);
;;;602        }
;;;603    }
00001e  b005              ADD      sp,sp,#0x14
000020  e8bd8ff0          POP      {r4-r11,pc}
                  |L12.36|
000024  464c              MOV      r4,r9                 ;557
000026  eb070009          ADD      r0,r7,r9              ;559
00002a  1e45              SUBS     r5,r0,#1              ;559
00002c  eb080009          ADD      r0,r8,r9              ;560
000030  1e46              SUBS     r6,r0,#1              ;560
000032  1ba8              SUBS     r0,r5,r6              ;562
000034  9004              STR      r0,[sp,#0x10]         ;562
000036  9804              LDR      r0,[sp,#0x10]         ;565
000038  2804              CMP      r0,#4                 ;565
00003a  d334              BCC      |L12.166|
00003c  f0050003          AND      r0,r5,#3              ;568
000040  9002              STR      r0,[sp,#8]            ;568
000042  f0060103          AND      r1,r6,#3              ;569
000046  9101              STR      r1,[sp,#4]            ;569
000048  e9dd1001          LDRD     r1,r0,[sp,#4]         ;571
00004c  4288              CMP      r0,r1                 ;571
00004e  d101              BNE      |L12.84|
000050  2001              MOVS     r0,#1                 ;571
000052  e000              B        |L12.86|
                  |L12.84|
000054  2000              MOVS     r0,#0                 ;571
                  |L12.86|
000056  9000              STR      r0,[sp,#0]            ;571
000058  9800              LDR      r0,[sp,#0]            ;573
00005a  2801              CMP      r0,#1                 ;573
00005c  d123              BNE      |L12.166|
00005e  9802              LDR      r0,[sp,#8]            ;575
000060  2803              CMP      r0,#3                 ;575
000062  d010              BEQ      |L12.134|
000064  9802              LDR      r0,[sp,#8]            ;576
000066  b240              SXTB     r0,r0                 ;576
000068  9003              STR      r0,[sp,#0xc]          ;576
00006a  e008              B        |L12.126|
                  |L12.108|
00006c  f8160901          LDRB     r0,[r6],#-1           ;579
000070  f8050901          STRB     r0,[r5],#-1           ;579
000074  1e64              SUBS     r4,r4,#1              ;580
000076  9803              LDR      r0,[sp,#0xc]          ;581
000078  1e40              SUBS     r0,r0,#1              ;581
00007a  b240              SXTB     r0,r0                 ;581
00007c  9003              STR      r0,[sp,#0xc]          ;581
                  |L12.126|
00007e  b114              CBZ      r4,|L12.134|
000080  9803              LDR      r0,[sp,#0xc]          ;578
000082  2800              CMP      r0,#0                 ;578
000084  daf2              BGE      |L12.108|
                  |L12.134|
000086  f1a50a03          SUB      r10,r5,#3             ;586
00008a  f1a60b03          SUB      r11,r6,#3             ;587
00008e  e004              B        |L12.154|
                  |L12.144|
000090  f85b0904          LDR      r0,[r11],#-4          ;589
000094  f84a0904          STR      r0,[r10],#-4          ;589
000098  1f24              SUBS     r4,r4,#4              ;590
                  |L12.154|
00009a  2c04              CMP      r4,#4                 ;588
00009c  d2f8              BCS      |L12.144|
00009e  f10a0503          ADD      r5,r10,#3             ;593
0000a2  f10b0603          ADD      r6,r11,#3             ;594
                  |L12.166|
0000a6  e004              B        |L12.178|
                  |L12.168|
0000a8  f8160901          LDRB     r0,[r6],#-1           ;600
0000ac  f8050901          STRB     r0,[r5],#-1           ;600
0000b0  1e64              SUBS     r4,r4,#1              ;601
                  |L12.178|
0000b2  2c00              CMP      r4,#0                 ;599
0000b4  d1f8              BNE      |L12.168|
0000b6  bf00              NOP      
0000b8  e7b1              B        |L12.30|
;;;604    
                          ENDP


                          AREA ||i.Mem_PoolBlkFree||, CODE, READONLY, ALIGN=1

                  Mem_PoolBlkFree PROC
;;;1680   #if (LIB_MEM_CFG_HEAP_SIZE > 0u)
;;;1681   void  Mem_PoolBlkFree (MEM_POOL  *p_pool,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1682                          void      *p_blk,
;;;1683                          LIB_ERR   *p_err)
;;;1684   {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4615              MOV      r5,r2
;;;1685   #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
;;;1686       CPU_SIZE_T   tbl_ix;
;;;1687       CPU_BOOLEAN  addr_valid;
;;;1688   #endif
;;;1689       CPU_SR_ALLOC();
00000a  2700              MOVS     r7,#0
;;;1690   
;;;1691   
;;;1692   #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)                 /* -------------- VALIDATE MEM POOL FREE -------------- */
;;;1693       if (p_err == DEF_NULL) {
;;;1694           CPU_SW_EXCEPTION(;);
;;;1695       }
;;;1696   
;;;1697       if (p_pool == DEF_NULL) {                                   /* Validate mem ptrs.                                   */
;;;1698          *p_err = LIB_MEM_ERR_NULL_PTR;
;;;1699           return;
;;;1700       }
;;;1701   
;;;1702       if (p_blk == DEF_NULL) {
;;;1703          *p_err = LIB_MEM_ERR_NULL_PTR;
;;;1704           return;
;;;1705       }
;;;1706   
;;;1707       addr_valid = Mem_PoolBlkIsValidAddr(p_pool, p_blk);         /* Validate mem blk as valid pool blk addr.             */
;;;1708       if (addr_valid != DEF_OK) {
;;;1709          *p_err = LIB_MEM_ERR_INVALID_BLK_ADDR;
;;;1710           return;
;;;1711       }
;;;1712   
;;;1713       CPU_CRITICAL_ENTER();                                       /* Make sure blk isn't already in free list.            */
;;;1714       for (tbl_ix = 0u; tbl_ix < p_pool->BlkNbr; tbl_ix++) {
;;;1715           if (p_pool->BlkFreeTbl[tbl_ix] == p_blk) {
;;;1716               CPU_CRITICAL_EXIT();
;;;1717              *p_err = LIB_MEM_ERR_INVALID_BLK_ADDR_IN_POOL;
;;;1718               return;
;;;1719           }
;;;1720       }
;;;1721   #else                                                           /* Double-free possibility if not in critical section.  */
;;;1722       CPU_CRITICAL_ENTER();
00000c  bf00              NOP      
00000e  bf00              NOP      
000010  f7fffffe          BL       CPU_SR_Save
000014  4607              MOV      r7,r0
000016  bf00              NOP      
000018  bf00              NOP      
;;;1723   #endif
;;;1724                                                                   /* --------------- FREE MEM BLK TO POOL --------------- */
;;;1725       if (p_pool->BlkFreeTblIx >= p_pool->BlkNbr) {
00001a  68a1              LDR      r1,[r4,#8]
00001c  6960              LDR      r0,[r4,#0x14]
00001e  4288              CMP      r0,r1
000020  d30b              BCC      |L13.58|
;;;1726           CPU_CRITICAL_EXIT();
000022  bf00              NOP      
000024  bf00              NOP      
000026  4638              MOV      r0,r7
000028  f7fffffe          BL       CPU_SR_Restore
00002c  bf00              NOP      
00002e  bf00              NOP      
;;;1727          *p_err = LIB_MEM_ERR_POOL_FULL;
000030  f24270dd          MOV      r0,#0x27dd
000034  8028              STRH     r0,[r5,#0]
                  |L13.54|
;;;1728           return;
;;;1729       }
;;;1730   
;;;1731       p_pool->BlkFreeTbl[p_pool->BlkFreeTblIx]  = p_blk;
;;;1732       p_pool->BlkFreeTblIx                     += 1u;
;;;1733       CPU_CRITICAL_EXIT();
;;;1734   
;;;1735      *p_err = LIB_MEM_ERR_NONE;
;;;1736   }
000036  e8bd81f0          POP      {r4-r8,pc}
                  |L13.58|
00003a  e9d40104          LDRD     r0,r1,[r4,#0x10]      ;1731
00003e  f8406021          STR      r6,[r0,r1,LSL #2]     ;1731
000042  6960              LDR      r0,[r4,#0x14]         ;1732
000044  1c40              ADDS     r0,r0,#1              ;1732
000046  6160              STR      r0,[r4,#0x14]         ;1732
000048  bf00              NOP                            ;1733
00004a  bf00              NOP                            ;1733
00004c  4638              MOV      r0,r7                 ;1733
00004e  f7fffffe          BL       CPU_SR_Restore
000052  bf00              NOP                            ;1733
000054  bf00              NOP                            ;1733
000056  f2427010          MOV      r0,#0x2710            ;1735
00005a  8028              STRH     r0,[r5,#0]            ;1735
00005c  bf00              NOP      
00005e  e7ea              B        |L13.54|
;;;1737   #endif
                          ENDP


                          AREA ||i.Mem_PoolBlkGet||, CODE, READONLY, ALIGN=1

                  Mem_PoolBlkGet PROC
;;;1597   #if (LIB_MEM_CFG_HEAP_SIZE > 0u)
;;;1598   void  *Mem_PoolBlkGet (MEM_POOL    *p_pool,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1599                          CPU_SIZE_T   size,
;;;1600                          LIB_ERR     *p_err)
;;;1601   {
000004  4604              MOV      r4,r0
000006  4688              MOV      r8,r1
000008  4615              MOV      r5,r2
;;;1602       CPU_INT08U  *p_blk;
;;;1603       CPU_SR_ALLOC();
00000a  2700              MOVS     r7,#0
;;;1604   
;;;1605   
;;;1606      (void)&size;                                                 /* Prevent possible 'variable unused' warning.          */
;;;1607   
;;;1608   #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)                 /* -------------- VALIDATE MEM POOL GET --------------- */
;;;1609       if (p_err == DEF_NULL) {                                    /* Validate err ptr.                                    */
;;;1610           CPU_SW_EXCEPTION(DEF_NULL);
;;;1611       }
;;;1612   
;;;1613       if (p_pool == DEF_NULL) {                                   /* Validate pool ptr.                                   */
;;;1614          *p_err = LIB_MEM_ERR_NULL_PTR;
;;;1615           return (DEF_NULL);
;;;1616       }
;;;1617   
;;;1618       if (size < 1u) {                                            /* Validate req'd size as non-NULL.                     */
;;;1619          *p_err = LIB_MEM_ERR_INVALID_BLK_SIZE;
;;;1620           return (DEF_NULL);
;;;1621       }
;;;1622   
;;;1623       if (size > p_pool->BlkSize) {                               /* Validate req'd size <= mem pool blk size.            */
;;;1624          *p_err = LIB_MEM_ERR_INVALID_BLK_SIZE;
;;;1625           return (DEF_NULL);
;;;1626       }
;;;1627   #endif
;;;1628   
;;;1629   
;;;1630                                                                   /* -------------- GET MEM BLK FROM POOL --------------- */
;;;1631       p_blk = DEF_NULL;
00000c  2600              MOVS     r6,#0
;;;1632       CPU_CRITICAL_ENTER();
00000e  bf00              NOP      
000010  bf00              NOP      
000012  f7fffffe          BL       CPU_SR_Save
000016  4607              MOV      r7,r0
000018  bf00              NOP      
00001a  bf00              NOP      
;;;1633       if (p_pool->BlkFreeTblIx > 0u) {
00001c  6960              LDR      r0,[r4,#0x14]
00001e  b158              CBZ      r0,|L14.56|
;;;1634           p_pool->BlkFreeTblIx                     -= 1u;
000020  6960              LDR      r0,[r4,#0x14]
000022  1e40              SUBS     r0,r0,#1
000024  6160              STR      r0,[r4,#0x14]
;;;1635           p_blk                                     = p_pool->BlkFreeTbl[p_pool->BlkFreeTblIx];
000026  e9d40104          LDRD     r0,r1,[r4,#0x10]
00002a  f8506021          LDR      r6,[r0,r1,LSL #2]
;;;1636           p_pool->BlkFreeTbl[p_pool->BlkFreeTblIx]  = DEF_NULL;
00002e  2000              MOVS     r0,#0
000030  e9d41204          LDRD     r1,r2,[r4,#0x10]
000034  f8410022          STR      r0,[r1,r2,LSL #2]
                  |L14.56|
;;;1637       }
;;;1638       CPU_CRITICAL_EXIT();
000038  bf00              NOP      
00003a  bf00              NOP      
00003c  4638              MOV      r0,r7
00003e  f7fffffe          BL       CPU_SR_Restore
000042  bf00              NOP      
000044  bf00              NOP      
;;;1639   
;;;1640       if (p_blk == DEF_NULL) {
000046  b91e              CBNZ     r6,|L14.80|
;;;1641          *p_err = LIB_MEM_ERR_POOL_EMPTY;
000048  f24270de          MOV      r0,#0x27de
00004c  8028              STRH     r0,[r5,#0]
00004e  e002              B        |L14.86|
                  |L14.80|
;;;1642       } else {
;;;1643          *p_err = LIB_MEM_ERR_NONE;
000050  f2427010          MOV      r0,#0x2710
000054  8028              STRH     r0,[r5,#0]
                  |L14.86|
;;;1644       }
;;;1645   
;;;1646       return (p_blk);
000056  4630              MOV      r0,r6
;;;1647   }
000058  e8bd81f0          POP      {r4-r8,pc}
;;;1648   #endif
                          ENDP


                          AREA ||i.Mem_PoolBlkGetNbrAvail||, CODE, READONLY, ALIGN=1

                  Mem_PoolBlkGetNbrAvail PROC
;;;1764   #if (LIB_MEM_CFG_HEAP_SIZE > 0u)
;;;1765   MEM_POOL_BLK_QTY  Mem_PoolBlkGetNbrAvail (MEM_POOL  *p_pool,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1766                                             LIB_ERR   *p_err)
;;;1767   {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;1768       CPU_SIZE_T  nbr_avail;
;;;1769       CPU_SR_ALLOC();
000008  2700              MOVS     r7,#0
;;;1770   
;;;1771   
;;;1772   #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
;;;1773                                                                   /* --------------- VALIDATE RTN ERR PTR --------------- */
;;;1774       if (p_err == DEF_NULL) {
;;;1775           CPU_SW_EXCEPTION(0u);
;;;1776       }
;;;1777                                                                   /* ---------------- VALIDATE MEM POOL ----------------- */
;;;1778       if (p_pool == DEF_NULL) {                                   /* Validate mem ptr.                                    */
;;;1779          *p_err =  LIB_MEM_ERR_NULL_PTR;
;;;1780           return (0u);
;;;1781       }
;;;1782   #endif
;;;1783   
;;;1784       CPU_CRITICAL_ENTER();
00000a  bf00              NOP      
00000c  bf00              NOP      
00000e  f7fffffe          BL       CPU_SR_Save
000012  4607              MOV      r7,r0
000014  bf00              NOP      
000016  bf00              NOP      
;;;1785       nbr_avail = p_pool->BlkFreeTblIx;
000018  6966              LDR      r6,[r4,#0x14]
;;;1786       CPU_CRITICAL_EXIT();
00001a  bf00              NOP      
00001c  bf00              NOP      
00001e  4638              MOV      r0,r7
000020  f7fffffe          BL       CPU_SR_Restore
000024  bf00              NOP      
000026  bf00              NOP      
;;;1787   
;;;1788      *p_err = LIB_MEM_ERR_NONE;
000028  f2427010          MOV      r0,#0x2710
00002c  8028              STRH     r0,[r5,#0]
;;;1789   
;;;1790       return (nbr_avail);
00002e  4630              MOV      r0,r6
;;;1791   }
000030  e8bd81f0          POP      {r4-r8,pc}
;;;1792   #endif
                          ENDP


                          AREA ||i.Mem_PoolClr||, CODE, READONLY, ALIGN=1

                  Mem_PoolClr PROC
;;;1541   #if (LIB_MEM_CFG_HEAP_SIZE > 0u)
;;;1542   void  Mem_PoolClr (MEM_POOL  *p_pool,
000000  2200              MOVS     r2,#0
;;;1543                      LIB_ERR   *p_err)
;;;1544   {
;;;1545   #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)                 /* -------------- VALIDATE RTN ERR  PTR --------------- */
;;;1546       if (p_err == DEF_NULL) {
;;;1547           CPU_SW_EXCEPTION(;);
;;;1548       }
;;;1549   
;;;1550                                                                   /* -------------- VALIDATE MEM POOL PTR --------------- */
;;;1551       if (p_pool == DEF_NULL) {
;;;1552          *p_err = LIB_MEM_ERR_NULL_PTR;
;;;1553           return;
;;;1554       }
;;;1555   #endif
;;;1556   
;;;1557       p_pool->PoolAddrStart = DEF_NULL;
000002  6002              STR      r2,[r0,#0]
;;;1558       p_pool->PoolAddrEnd   = DEF_NULL;
000004  6042              STR      r2,[r0,#4]
;;;1559       p_pool->BlkSize       = 0u;
000006  60c2              STR      r2,[r0,#0xc]
;;;1560       p_pool->BlkNbr        = 0u;
000008  6082              STR      r2,[r0,#8]
;;;1561       p_pool->BlkFreeTbl    = DEF_NULL;
00000a  6102              STR      r2,[r0,#0x10]
;;;1562       p_pool->BlkFreeTblIx  = 0u;
00000c  6142              STR      r2,[r0,#0x14]
;;;1563   
;;;1564      *p_err = LIB_MEM_ERR_NONE;
00000e  f2427210          MOV      r2,#0x2710
000012  800a              STRH     r2,[r1,#0]
;;;1565   }
000014  4770              BX       lr
;;;1566   #endif
                          ENDP


                          AREA ||i.Mem_PoolCreate||, CODE, READONLY, ALIGN=2

                  Mem_PoolCreate PROC
;;;1350   #if (LIB_MEM_CFG_HEAP_SIZE > 0u)
;;;1351   void  Mem_PoolCreate (MEM_POOL          *p_pool,
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;1352                         void              *p_mem_base,
;;;1353                         CPU_SIZE_T         mem_size,
;;;1354                         MEM_POOL_BLK_QTY   blk_nbr,
;;;1355                         CPU_SIZE_T         blk_size,
;;;1356                         CPU_SIZE_T         blk_align,
;;;1357                         CPU_SIZE_T        *p_bytes_reqd,
;;;1358                         LIB_ERR           *p_err)
;;;1359   {
000004  b087              SUB      sp,sp,#0x1c
000006  4605              MOV      r5,r0
000008  4688              MOV      r8,r1
00000a  461e              MOV      r6,r3
00000c  9c17              LDR      r4,[sp,#0x5c]
;;;1360       MEM_SEG           *p_seg;
;;;1361       void              *p_pool_mem;
;;;1362       CPU_SIZE_T         pool_size;
;;;1363       CPU_SIZE_T         blk_size_align;
;;;1364       CPU_ADDR           pool_addr_end;
;;;1365       MEM_POOL_BLK_QTY   blk_ix;
;;;1366       CPU_INT08U        *p_blk;
;;;1367       CPU_SR_ALLOC();
00000e  2000              MOVS     r0,#0
000010  9003              STR      r0,[sp,#0xc]
;;;1368   
;;;1369   
;;;1370   #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)                 /* --------------- VALIDATE RTN ERR PTR --------------- */
;;;1371       if (p_err == DEF_NULL) {
;;;1372           CPU_SW_EXCEPTION(;);
;;;1373       }
;;;1374   
;;;1375                                                                   /* ------------- VALIDATE MEM POOL CREATE ------------- */
;;;1376       if (p_pool == DEF_NULL) {
;;;1377          *p_err = LIB_MEM_ERR_NULL_PTR;
;;;1378           return;
;;;1379       }
;;;1380   
;;;1381       if (p_mem_base != DEF_NULL) {
;;;1382           if (mem_size < 1u) {
;;;1383              *p_err = LIB_MEM_ERR_INVALID_SEG_SIZE;
;;;1384               return;
;;;1385           }
;;;1386       }
;;;1387   
;;;1388       if (blk_nbr < 1u) {
;;;1389          *p_err = LIB_MEM_ERR_INVALID_BLK_NBR;
;;;1390           return;
;;;1391       }
;;;1392   
;;;1393       if (blk_size < 1u) {
;;;1394          *p_err = LIB_MEM_ERR_INVALID_BLK_SIZE;
;;;1395           return;
;;;1396       }
;;;1397   
;;;1398       if (MATH_IS_PWR2(blk_align) != DEF_YES) {                   /* Chk that req alignment is a pwr of 2.                */
;;;1399          *p_err = LIB_MEM_ERR_INVALID_BLK_ALIGN;
;;;1400           return;
;;;1401       }
;;;1402   #endif
;;;1403   
;;;1404       Mem_PoolClr(p_pool, p_err);                                 /* Init mem pool.                                       */
000012  4621              MOV      r1,r4
000014  4628              MOV      r0,r5
000016  f7fffffe          BL       Mem_PoolClr
;;;1405       if (*p_err != LIB_MEM_ERR_NONE) {
00001a  8820              LDRH     r0,[r4,#0]
00001c  f2427110          MOV      r1,#0x2710
000020  4288              CMP      r0,r1
000022  d002              BEQ      |L17.42|
                  |L17.36|
;;;1406            return;
;;;1407       }
;;;1408   
;;;1409                                                                   /* -------- DETERMINE AND/OR ALLOC SEG TO USE --------- */
;;;1410       if (p_mem_base == DEF_NULL) {                               /* Use heap seg.                                        */
;;;1411           p_seg = &Mem_SegHeap;
;;;1412       } else {                                                    /* Use other seg.                                       */
;;;1413           CPU_CRITICAL_ENTER();
;;;1414           p_seg = Mem_SegOverlapChkCritical((CPU_ADDR)p_mem_base,
;;;1415                                                       mem_size,
;;;1416                                                       p_err);
;;;1417           switch (*p_err) {
;;;1418               case LIB_MEM_ERR_INVALID_SEG_EXISTS:                /* Seg already exists.                                  */
;;;1419                    break;
;;;1420   
;;;1421               case LIB_MEM_ERR_NONE:                              /* Seg must be created.                                 */
;;;1422                    p_seg = (MEM_SEG *)Mem_SegAllocExtCritical(&Mem_SegHeap,
;;;1423                                                                sizeof(MEM_SEG),
;;;1424                                                                sizeof(CPU_ALIGN),
;;;1425                                                                LIB_MEM_PADDING_ALIGN_NONE,
;;;1426                                                                p_bytes_reqd,
;;;1427                                                                p_err);
;;;1428                    if (*p_err != LIB_MEM_ERR_NONE) {
;;;1429                        CPU_CRITICAL_EXIT();
;;;1430                        return;
;;;1431                    }
;;;1432   
;;;1433   #if (LIB_MEM_CFG_DBG_INFO_EN == DEF_ENABLED)                    /* Track alloc if req'd.                                */
;;;1434                    Mem_SegAllocTrackCritical("Unknown segment data",
;;;1435                                              &Mem_SegHeap,
;;;1436                                               sizeof(MEM_SEG),
;;;1437                                               p_err);
;;;1438                    if (*p_err != LIB_MEM_ERR_NONE) {
;;;1439                        CPU_CRITICAL_EXIT();
;;;1440                        return;
;;;1441                    }
;;;1442   #endif
;;;1443   
;;;1444                    Mem_SegCreateCritical(          DEF_NULL,
;;;1445                                                    p_seg,
;;;1446                                          (CPU_ADDR)p_mem_base,
;;;1447                                                    LIB_MEM_PADDING_ALIGN_NONE,
;;;1448                                                    mem_size);
;;;1449                    break;
;;;1450   
;;;1451   
;;;1452               case LIB_MEM_ERR_INVALID_SEG_OVERLAP:
;;;1453               default:
;;;1454                    CPU_CRITICAL_EXIT();
;;;1455                    return;                                        /* Prevent 'break NOT reachable' compiler warning.      */
;;;1456           }
;;;1457   
;;;1458           CPU_CRITICAL_EXIT();
;;;1459       }
;;;1460   
;;;1461   
;;;1462                                                                   /* ---------------- ALLOC MEM FOR POOL ---------------- */
;;;1463                                                                   /* Calc blk size with align.                            */
;;;1464       blk_size_align =  MATH_ROUND_INC_UP_PWR2(blk_size, blk_align);
;;;1465       pool_size      =  blk_size_align * blk_nbr;                 /* Calc required size for pool.                         */
;;;1466   
;;;1467                                                                   /* Alloc mem for pool.                                  */
;;;1468       p_pool_mem = (void *)Mem_SegAllocInternal("Unnamed static pool",
;;;1469                                                  p_seg,
;;;1470                                                  pool_size,
;;;1471                                                  blk_align,
;;;1472                                                  LIB_MEM_PADDING_ALIGN_NONE,
;;;1473                                                  p_bytes_reqd,
;;;1474                                                  p_err);
;;;1475       if (*p_err != LIB_MEM_ERR_NONE) {
;;;1476           return;
;;;1477       }
;;;1478   
;;;1479                                                                   /* ------------ ALLOC MEM FOR FREE BLK TBL ------------ */
;;;1480       p_pool->BlkFreeTbl = (void *)Mem_SegAllocInternal("Unnamed static pool free blk tbl",
;;;1481                                                         &Mem_SegHeap,
;;;1482                                                          blk_nbr * sizeof(void *),
;;;1483                                                          sizeof(CPU_ALIGN),
;;;1484                                                          LIB_MEM_PADDING_ALIGN_NONE,
;;;1485                                                          p_bytes_reqd,
;;;1486                                                          p_err);
;;;1487       if (*p_err != LIB_MEM_ERR_NONE) {
;;;1488           return;
;;;1489       }
;;;1490   
;;;1491                                                                   /* ------------------ INIT BLK LIST ------------------- */
;;;1492       p_blk = (CPU_INT08U *)p_pool_mem;
;;;1493       for (blk_ix = 0; blk_ix < blk_nbr; blk_ix++) {
;;;1494           p_pool->BlkFreeTbl[blk_ix]  = p_blk;
;;;1495           p_blk                      += blk_size_align;
;;;1496       }
;;;1497   
;;;1498   
;;;1499                                                                   /* ------------------ INIT POOL DATA ------------------ */
;;;1500       pool_addr_end         = (CPU_ADDR)p_pool_mem + (pool_size - 1u);
;;;1501       p_pool->PoolAddrStart =  p_pool_mem;
;;;1502       p_pool->PoolAddrEnd   = (void *)pool_addr_end;
;;;1503       p_pool->BlkNbr        =  blk_nbr;
;;;1504       p_pool->BlkSize       =  blk_size_align;
;;;1505       p_pool->BlkFreeTblIx  =  blk_nbr;
;;;1506   }
000024  b00b              ADD      sp,sp,#0x2c
000026  e8bd8ff0          POP      {r4-r11,pc}
                  |L17.42|
00002a  f1b80f00          CMP      r8,#0                 ;1410
00002e  d102              BNE      |L17.54|
000030  f8df9138          LDR      r9,|L17.364|
000034  e047              B        |L17.198|
                  |L17.54|
000036  bf00              NOP                            ;1413
000038  bf00              NOP                            ;1413
00003a  f7fffffe          BL       CPU_SR_Save
00003e  9003              STR      r0,[sp,#0xc]          ;1413
000040  bf00              NOP                            ;1413
000042  bf00              NOP                            ;1413
000044  4622              MOV      r2,r4                 ;1414
000046  4640              MOV      r0,r8                 ;1414
000048  9909              LDR      r1,[sp,#0x24]         ;1414
00004a  f7fffffe          BL       Mem_SegOverlapChkCritical
00004e  4681              MOV      r9,r0                 ;1414
000050  8820              LDRH     r0,[r4,#0]            ;1417
000052  f5a0501c          SUB      r0,r0,#0x2700         ;1417
000056  3810              SUBS     r0,r0,#0x10           ;1417
000058  b120              CBZ      r0,|L17.100|
00005a  286f              CMP      r0,#0x6f              ;1417
00005c  d023              BEQ      |L17.166|
00005e  2870              CMP      r0,#0x70              ;1417
000060  d120              BNE      |L17.164|
000062  e028              B        |L17.182|
                  |L17.100|
000064  9816              LDR      r0,[sp,#0x58]         ;1422
000066  2301              MOVS     r3,#1                 ;1422
000068  2204              MOVS     r2,#4                 ;1422
00006a  2114              MOVS     r1,#0x14              ;1422
00006c  e9cd0400          STRD     r0,r4,[sp,#0]         ;1422
000070  483e              LDR      r0,|L17.364|
000072  f7fffffe          BL       Mem_SegAllocExtCritical
000076  4681              MOV      r9,r0                 ;1422
000078  8820              LDRH     r0,[r4,#0]            ;1428
00007a  f2427110          MOV      r1,#0x2710            ;1428
00007e  4288              CMP      r0,r1                 ;1428
000080  d007              BEQ      |L17.146|
000082  bf00              NOP                            ;1429
000084  bf00              NOP                            ;1429
000086  9803              LDR      r0,[sp,#0xc]          ;1429
000088  f7fffffe          BL       CPU_SR_Restore
00008c  bf00              NOP                            ;1429
00008e  bf00              NOP                            ;1429
000090  e7c8              B        |L17.36|
                  |L17.146|
000092  9809              LDR      r0,[sp,#0x24]         ;1444
000094  2301              MOVS     r3,#1                 ;1444
000096  4642              MOV      r2,r8                 ;1444
000098  4649              MOV      r1,r9                 ;1444
00009a  9000              STR      r0,[sp,#0]            ;1444
00009c  2000              MOVS     r0,#0                 ;1444
00009e  f7fffffe          BL       Mem_SegCreateCritical
0000a2  e008              B        |L17.182|
                  |L17.164|
0000a4  bf00              NOP                            ;1452
                  |L17.166|
0000a6  bf00              NOP                            ;1454
0000a8  bf00              NOP                            ;1454
0000aa  9803              LDR      r0,[sp,#0xc]          ;1454
0000ac  f7fffffe          BL       CPU_SR_Restore
0000b0  bf00              NOP                            ;1454
0000b2  bf00              NOP                            ;1454
0000b4  e7b6              B        |L17.36|
                  |L17.182|
0000b6  bf00              NOP                            ;1419
0000b8  bf00              NOP                            ;1458
0000ba  bf00              NOP                            ;1458
0000bc  9803              LDR      r0,[sp,#0xc]          ;1458
0000be  f7fffffe          BL       CPU_SR_Restore
0000c2  bf00              NOP                            ;1458
0000c4  bf00              NOP                            ;1458
                  |L17.198|
0000c6  9815              LDR      r0,[sp,#0x54]         ;1464
0000c8  1e41              SUBS     r1,r0,#1              ;1464
0000ca  9814              LDR      r0,[sp,#0x50]         ;1464
0000cc  ea200101          BIC      r1,r0,r1              ;1464
0000d0  9815              LDR      r0,[sp,#0x54]         ;1464
0000d2  1e40              SUBS     r0,r0,#1              ;1464
0000d4  9a14              LDR      r2,[sp,#0x50]         ;1464
0000d6  4010              ANDS     r0,r0,r2              ;1464
0000d8  b908              CBNZ     r0,|L17.222|
0000da  2000              MOVS     r0,#0                 ;1464
0000dc  e000              B        |L17.224|
                  |L17.222|
0000de  9815              LDR      r0,[sp,#0x54]         ;1464
                  |L17.224|
0000e0  eb010a00          ADD      r10,r1,r0             ;1464
0000e4  fb0af006          MUL      r0,r10,r6             ;1465
0000e8  9006              STR      r0,[sp,#0x18]         ;1465
0000ea  2101              MOVS     r1,#1                 ;1468
0000ec  9816              LDR      r0,[sp,#0x58]         ;1468
0000ee  e9cd0401          STRD     r0,r4,[sp,#4]         ;1468
0000f2  9100              STR      r1,[sp,#0]            ;1468
0000f4  4649              MOV      r1,r9                 ;1468
0000f6  a01e              ADR      r0,|L17.368|
0000f8  9b15              LDR      r3,[sp,#0x54]         ;1468
0000fa  9a06              LDR      r2,[sp,#0x18]         ;1468
0000fc  f7fffffe          BL       Mem_SegAllocInternal
000100  4607              MOV      r7,r0                 ;1468
000102  8820              LDRH     r0,[r4,#0]            ;1475
000104  f2427110          MOV      r1,#0x2710            ;1475
000108  4288              CMP      r0,r1                 ;1475
00010a  d000              BEQ      |L17.270|
00010c  e78a              B        |L17.36|
                  |L17.270|
00010e  2101              MOVS     r1,#1                 ;1480
000110  9816              LDR      r0,[sp,#0x58]         ;1480
000112  00b2              LSLS     r2,r6,#2              ;1480
000114  2304              MOVS     r3,#4                 ;1480
000116  e9cd0401          STRD     r0,r4,[sp,#4]         ;1480
00011a  9100              STR      r1,[sp,#0]            ;1480
00011c  4913              LDR      r1,|L17.364|
00011e  a019              ADR      r0,|L17.388|
000120  f7fffffe          BL       Mem_SegAllocInternal
000124  6128              STR      r0,[r5,#0x10]         ;1480
000126  8820              LDRH     r0,[r4,#0]            ;1487
000128  f2427110          MOV      r1,#0x2710            ;1487
00012c  4288              CMP      r0,r1                 ;1487
00012e  d000              BEQ      |L17.306|
000130  e778              B        |L17.36|
                  |L17.306|
000132  9704              STR      r7,[sp,#0x10]         ;1492
000134  f04f0b00          MOV      r11,#0                ;1493
000138  e008              B        |L17.332|
                  |L17.314|
00013a  9804              LDR      r0,[sp,#0x10]         ;1494
00013c  6929              LDR      r1,[r5,#0x10]         ;1494
00013e  f841002b          STR      r0,[r1,r11,LSL #2]    ;1494
000142  9804              LDR      r0,[sp,#0x10]         ;1495
000144  4450              ADD      r0,r0,r10             ;1495
000146  9004              STR      r0,[sp,#0x10]         ;1495
000148  f10b0b01          ADD      r11,r11,#1            ;1493
                  |L17.332|
00014c  45b3              CMP      r11,r6                ;1493
00014e  d3f4              BCC      |L17.314|
000150  9806              LDR      r0,[sp,#0x18]         ;1500
000152  1e40              SUBS     r0,r0,#1              ;1500
000154  4438              ADD      r0,r0,r7              ;1500
000156  9005              STR      r0,[sp,#0x14]         ;1500
000158  602f              STR      r7,[r5,#0]            ;1501
00015a  9805              LDR      r0,[sp,#0x14]         ;1502
00015c  6068              STR      r0,[r5,#4]            ;1502
00015e  60ae              STR      r6,[r5,#8]            ;1503
000160  f8c5a00c          STR      r10,[r5,#0xc]         ;1504
000164  616e              STR      r6,[r5,#0x14]         ;1505
000166  bf00              NOP      
000168  e75c              B        |L17.36|
;;;1507   #endif
                          ENDP

00016a  0000              DCW      0x0000
                  |L17.364|
                          DCD      Mem_SegHeap
                  |L17.368|
000170  556e6e61          DCB      "Unnamed static pool",0
000174  6d656420
000178  73746174
00017c  69632070
000180  6f6f6c00
                  |L17.388|
000184  556e6e61          DCB      "Unnamed static pool free blk tbl",0
000188  6d656420
00018c  73746174
000190  69632070
000194  6f6f6c20
000198  66726565
00019c  20626c6b
0001a0  2074626c
0001a4  00      
0001a5  00                DCB      0
0001a6  00                DCB      0
0001a7  00                DCB      0

                          AREA ||i.Mem_SegAlloc||, CODE, READONLY, ALIGN=2

                  Mem_SegAlloc PROC
;;;1113   
;;;1114   void  *Mem_SegAlloc (const  CPU_CHAR    *p_name,
000000  e92d43fe          PUSH     {r1-r9,lr}
;;;1115                               MEM_SEG     *p_seg,
;;;1116                               CPU_SIZE_T   size,
;;;1117                               LIB_ERR     *p_err)
;;;1118   {
000004  4607              MOV      r7,r0
000006  460c              MOV      r4,r1
000008  4690              MOV      r8,r2
00000a  461d              MOV      r5,r3
;;;1119       void  *p_blk;
;;;1120   
;;;1121   
;;;1122       if (p_seg == DEF_NULL) {                                    /* Alloc from heap if p_seg is null.                    */
00000c  b904              CBNZ     r4,|L18.16|
;;;1123   #if (LIB_MEM_CFG_HEAP_SIZE > 0u)
;;;1124           p_seg = &Mem_SegHeap;
00000e  4c08              LDR      r4,|L18.48|
                  |L18.16|
;;;1125   #else
;;;1126          *p_err = LIB_MEM_ERR_NULL_PTR;
;;;1127           return (DEF_NULL);
;;;1128   #endif
;;;1129       }
;;;1130   
;;;1131       p_blk = Mem_SegAllocInternal(p_name,
000010  2000              MOVS     r0,#0
000012  2101              MOVS     r1,#1
000014  2304              MOVS     r3,#4
000016  4642              MOV      r2,r8
000018  e9cd0501          STRD     r0,r5,[sp,#4]
00001c  9100              STR      r1,[sp,#0]
00001e  4621              MOV      r1,r4
000020  4638              MOV      r0,r7
000022  f7fffffe          BL       Mem_SegAllocInternal
000026  4606              MOV      r6,r0
;;;1132                                    p_seg,
;;;1133                                    size,
;;;1134                                    sizeof(CPU_ALIGN),
;;;1135                                    LIB_MEM_PADDING_ALIGN_NONE,
;;;1136                                    DEF_NULL,
;;;1137                                    p_err);
;;;1138   
;;;1139       return (p_blk);
000028  4630              MOV      r0,r6
;;;1140   }
00002a  e8bd83fe          POP      {r1-r9,pc}
;;;1141   
                          ENDP

00002e  0000              DCW      0x0000
                  |L18.48|
                          DCD      Mem_SegHeap

                          AREA ||i.Mem_SegAllocExt||, CODE, READONLY, ALIGN=2

                  Mem_SegAllocExt PROC
;;;1180   
;;;1181   void  *Mem_SegAllocExt (const  CPU_CHAR    *p_name,
000000  e92d4ffe          PUSH     {r1-r11,lr}
;;;1182                                  MEM_SEG     *p_seg,
;;;1183                                  CPU_SIZE_T   size,
;;;1184                                  CPU_SIZE_T   align,
;;;1185                                  CPU_SIZE_T  *p_bytes_reqd,
;;;1186                                  LIB_ERR     *p_err)
;;;1187   {
000004  4606              MOV      r6,r0
000006  460c              MOV      r4,r1
000008  4617              MOV      r7,r2
00000a  4698              MOV      r8,r3
00000c  e9dd9a0c          LDRD     r9,r10,[sp,#0x30]
;;;1188       void  *p_blk;
;;;1189   
;;;1190   
;;;1191       if (p_seg == DEF_NULL) {                                    /* Alloc from heap if p_seg is null.                    */
000010  b904              CBNZ     r4,|L19.20|
;;;1192   #if (LIB_MEM_CFG_HEAP_SIZE > 0u)
;;;1193           p_seg = &Mem_SegHeap;
000012  4c07              LDR      r4,|L19.48|
                  |L19.20|
;;;1194   #else
;;;1195          *p_err = LIB_MEM_ERR_NULL_PTR;
;;;1196           return (DEF_NULL);
;;;1197   #endif
;;;1198       }
;;;1199   
;;;1200       p_blk = Mem_SegAllocInternal(p_name,
000014  2001              MOVS     r0,#1
000016  4643              MOV      r3,r8
000018  463a              MOV      r2,r7
00001a  4621              MOV      r1,r4
00001c  e88d0601          STM      sp,{r0,r9,r10}
000020  4630              MOV      r0,r6
000022  f7fffffe          BL       Mem_SegAllocInternal
000026  4605              MOV      r5,r0
;;;1201                                    p_seg,
;;;1202                                    size,
;;;1203                                    align,
;;;1204                                    LIB_MEM_PADDING_ALIGN_NONE,
;;;1205                                    p_bytes_reqd,
;;;1206                                    p_err);
;;;1207   
;;;1208       return (p_blk);
000028  4628              MOV      r0,r5
;;;1209   }
00002a  e8bd8ffe          POP      {r1-r11,pc}
;;;1210   
                          ENDP

00002e  0000              DCW      0x0000
                  |L19.48|
                          DCD      Mem_SegHeap

                          AREA ||i.Mem_SegAllocExtCritical||, CODE, READONLY, ALIGN=1

                  Mem_SegAllocExtCritical PROC
;;;2550   
;;;2551   static  void  *Mem_SegAllocExtCritical (MEM_SEG     *p_seg,
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;2552                                           CPU_SIZE_T   size,
;;;2553                                           CPU_SIZE_T   align,
;;;2554                                           CPU_SIZE_T   padding_align,
;;;2555                                           CPU_SIZE_T  *p_bytes_reqd,
;;;2556                                           LIB_ERR     *p_err)
;;;2557   {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4691              MOV      r9,r2
00000a  e9ddc809          LDRD     r12,r8,[sp,#0x24]
;;;2558       CPU_ADDR    blk_addr;
;;;2559       CPU_ADDR    addr_next;
;;;2560       CPU_SIZE_T  size_rem_seg;
;;;2561       CPU_SIZE_T  size_tot_blk;
;;;2562       CPU_SIZE_T  blk_align = DEF_MAX(align, padding_align);
00000e  4599              CMP      r9,r3
000010  d901              BLS      |L20.22|
000012  4648              MOV      r0,r9
000014  e000              B        |L20.24|
                  |L20.22|
000016  4618              MOV      r0,r3
                  |L20.24|
000018  4682              MOV      r10,r0
;;;2563   
;;;2564   
;;;2565       blk_addr     = MATH_ROUND_INC_UP_PWR2(p_seg->AddrNext,      /* Compute align'ed blk addr.                           */
00001a  f1aa0b01          SUB      r11,r10,#1
00001e  68a0              LDR      r0,[r4,#8]
000020  ea20000b          BIC      r0,r0,r11
000024  f1aa0e01          SUB      lr,r10,#1
000028  f8d4b008          LDR      r11,[r4,#8]
00002c  ea0b0b0e          AND      r11,r11,lr
000030  f1bb0f00          CMP      r11,#0
000034  d102              BNE      |L20.60|
000036  f04f0b00          MOV      r11,#0
00003a  e000              B        |L20.62|
                  |L20.60|
00003c  46d3              MOV      r11,r10
                  |L20.62|
00003e  eb00010b          ADD      r1,r0,r11
;;;2566                                             blk_align);
;;;2567       addr_next    = MATH_ROUND_INC_UP_PWR2(blk_addr + size,      /* Compute addr of next alloc.                          */
000042  1948              ADDS     r0,r1,r5
000044  f1a30b01          SUB      r11,r3,#1
000048  ea20000b          BIC      r0,r0,r11
00004c  eb010b05          ADD      r11,r1,r5
000050  f1a30e01          SUB      lr,r3,#1
000054  ea0b0b0e          AND      r11,r11,lr
000058  f1bb0f00          CMP      r11,#0
00005c  d102              BNE      |L20.100|
00005e  f04f0b00          MOV      r11,#0
000062  e000              B        |L20.102|
                  |L20.100|
000064  469b              MOV      r11,r3
                  |L20.102|
000066  eb00020b          ADD      r2,r0,r11
;;;2568                                             padding_align);
;;;2569       size_rem_seg = p_seg->AddrEnd - p_seg->AddrNext + 1u;
00006a  e9d40b01          LDRD     r0,r11,[r4,#4]
00006e  eba0000b          SUB      r0,r0,r11
000072  1c46              ADDS     r6,r0,#1
;;;2570       size_tot_blk = addr_next - p_seg->AddrNext;                 /* Compute tot blk size including align and padding.    */
000074  68a0              LDR      r0,[r4,#8]
000076  1a17              SUBS     r7,r2,r0
;;;2571       if (size_rem_seg < size_tot_blk) {                          /* If seg doesn't have enough space ...                 */
000078  42be              CMP      r6,r7
00007a  d20c              BCS      |L20.150|
;;;2572           if (p_bytes_reqd != DEF_NULL) {                         /* ... calc nbr of req'd bytes.                         */
00007c  f1bc0f00          CMP      r12,#0
000080  d002              BEQ      |L20.136|
;;;2573              *p_bytes_reqd = size_tot_blk - size_rem_seg;
000082  1bb8              SUBS     r0,r7,r6
000084  f8cc0000          STR      r0,[r12,#0]
                  |L20.136|
;;;2574           }
;;;2575   
;;;2576          *p_err = LIB_MEM_ERR_SEG_OVF;
000088  f24270d9          MOV      r0,#0x27d9
00008c  f8a80000          STRH     r0,[r8,#0]
;;;2577           return (DEF_NULL);
000090  2000              MOVS     r0,#0
                  |L20.146|
;;;2578       }
;;;2579   
;;;2580       p_seg->AddrNext = addr_next;
;;;2581   
;;;2582      *p_err = LIB_MEM_ERR_NONE;
;;;2583   
;;;2584       return ((void *)blk_addr);
;;;2585   }
000092  e8bd8ff0          POP      {r4-r11,pc}
                  |L20.150|
000096  60a2              STR      r2,[r4,#8]            ;2580
000098  f2427010          MOV      r0,#0x2710            ;2582
00009c  f8a80000          STRH     r0,[r8,#0]            ;2582
0000a0  4608              MOV      r0,r1                 ;2584
0000a2  e7f6              B        |L20.146|
;;;2586   
                          ENDP


                          AREA ||i.Mem_SegAllocHW||, CODE, READONLY, ALIGN=2

                  Mem_SegAllocHW PROC
;;;1250   
;;;1251   void  *Mem_SegAllocHW (const  CPU_CHAR    *p_name,
000000  e92d4ffe          PUSH     {r1-r11,lr}
;;;1252                                 MEM_SEG     *p_seg,
;;;1253                                 CPU_SIZE_T   size,
;;;1254                                 CPU_SIZE_T   align,
;;;1255                                 CPU_SIZE_T  *p_bytes_reqd,
;;;1256                                 LIB_ERR     *p_err)
;;;1257   {
000004  4606              MOV      r6,r0
000006  460c              MOV      r4,r1
000008  4617              MOV      r7,r2
00000a  4698              MOV      r8,r3
00000c  e9dd9a0c          LDRD     r9,r10,[sp,#0x30]
;;;1258       void  *p_blk;
;;;1259   
;;;1260   
;;;1261       if (p_seg == DEF_NULL) {                                    /* Alloc from heap if p_seg is null.                    */
000010  b904              CBNZ     r4,|L21.20|
;;;1262   #if (LIB_MEM_CFG_HEAP_SIZE > 0u)
;;;1263           p_seg = &Mem_SegHeap;
000012  4c07              LDR      r4,|L21.48|
                  |L21.20|
;;;1264   #else
;;;1265          *p_err = LIB_MEM_ERR_NULL_PTR;
;;;1266           return (DEF_NULL);
;;;1267   #endif
;;;1268       }
;;;1269   
;;;1270       p_blk = Mem_SegAllocInternal(p_name,
000014  6920              LDR      r0,[r4,#0x10]
000016  4643              MOV      r3,r8
000018  463a              MOV      r2,r7
00001a  4621              MOV      r1,r4
00001c  e88d0601          STM      sp,{r0,r9,r10}
000020  4630              MOV      r0,r6
000022  f7fffffe          BL       Mem_SegAllocInternal
000026  4605              MOV      r5,r0
;;;1271                                    p_seg,
;;;1272                                    size,
;;;1273                                    align,
;;;1274                                    p_seg->PaddingAlign,
;;;1275                                    p_bytes_reqd,
;;;1276                                    p_err);
;;;1277   
;;;1278       return (p_blk);
000028  4628              MOV      r0,r5
;;;1279   }
00002a  e8bd8ffe          POP      {r1-r11,pc}
;;;1280   
                          ENDP

00002e  0000              DCW      0x0000
                  |L21.48|
                          DCD      Mem_SegHeap

                          AREA ||i.Mem_SegAllocInternal||, CODE, READONLY, ALIGN=1

                  Mem_SegAllocInternal PROC
;;;2457   
;;;2458   static  void  *Mem_SegAllocInternal (const  CPU_CHAR    *p_name,
000000  e92d5ffc          PUSH     {r2-r12,lr}
;;;2459                                               MEM_SEG     *p_seg,
;;;2460                                               CPU_SIZE_T   size,
;;;2461                                               CPU_SIZE_T   align,
;;;2462                                               CPU_SIZE_T   padding_align,
;;;2463                                               CPU_SIZE_T  *p_bytes_reqd,
;;;2464                                               LIB_ERR     *p_err)
;;;2465   {
000004  460c              MOV      r4,r1
000006  4615              MOV      r5,r2
000008  461e              MOV      r6,r3
00000a  e9dd9a0c          LDRD     r9,r10,[sp,#0x30]
00000e  9f0e              LDR      r7,[sp,#0x38]
;;;2466       void  *p_blk;
;;;2467       CPU_SR_ALLOC();
000010  f04f0b00          MOV      r11,#0
;;;2468   
;;;2469   
;;;2470   #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
;;;2471       if (p_err == DEF_NULL) {                                    /* Chk for null err ptr.                                */
;;;2472           CPU_SW_EXCEPTION(DEF_NULL);
;;;2473       }
;;;2474   
;;;2475       if (size < 1u) {                                            /* Chk for invalid sized mem req.                       */
;;;2476          *p_err = LIB_MEM_ERR_INVALID_MEM_SIZE;
;;;2477           return (DEF_NULL);
;;;2478       }
;;;2479   
;;;2480       if (MATH_IS_PWR2(align) != DEF_YES) {                       /* Chk that align is a pwr of 2.                        */
;;;2481          *p_err = LIB_MEM_ERR_INVALID_MEM_ALIGN;
;;;2482           return (DEF_NULL);
;;;2483       }
;;;2484   #endif
;;;2485   
;;;2486       CPU_CRITICAL_ENTER();
000014  bf00              NOP      
000016  bf00              NOP      
000018  f7fffffe          BL       CPU_SR_Save
00001c  4683              MOV      r11,r0
00001e  bf00              NOP      
000020  bf00              NOP      
;;;2487       p_blk = Mem_SegAllocExtCritical(p_seg,
000022  464b              MOV      r3,r9
000024  4632              MOV      r2,r6
000026  4629              MOV      r1,r5
000028  4620              MOV      r0,r4
00002a  e9cda700          STRD     r10,r7,[sp,#0]
00002e  f7fffffe          BL       Mem_SegAllocExtCritical
000032  4680              MOV      r8,r0
;;;2488                                       size,
;;;2489                                       align,
;;;2490                                       padding_align,
;;;2491                                       p_bytes_reqd,
;;;2492                                       p_err);
;;;2493       if (*p_err != LIB_MEM_ERR_NONE) {
000034  8838              LDRH     r0,[r7,#0]
000036  f2427110          MOV      r1,#0x2710
00003a  4288              CMP      r0,r1
00003c  d009              BEQ      |L22.82|
;;;2494           CPU_CRITICAL_EXIT();
00003e  bf00              NOP      
000040  bf00              NOP      
000042  4658              MOV      r0,r11
000044  f7fffffe          BL       CPU_SR_Restore
000048  bf00              NOP      
00004a  bf00              NOP      
;;;2495           return (DEF_NULL);
00004c  2000              MOVS     r0,#0
                  |L22.78|
;;;2496       }
;;;2497   
;;;2498   #if (LIB_MEM_CFG_DBG_INFO_EN == DEF_ENABLED)                    /* Track alloc if req'd.                                */
;;;2499       Mem_SegAllocTrackCritical(p_name,
;;;2500                                 p_seg,
;;;2501                                 size,
;;;2502                                 p_err);
;;;2503       if (*p_err != LIB_MEM_ERR_NONE) {
;;;2504           CPU_CRITICAL_EXIT();
;;;2505           return (DEF_NULL);
;;;2506       }
;;;2507   #else
;;;2508       (void)&p_name;
;;;2509   #endif
;;;2510       CPU_CRITICAL_EXIT();
;;;2511   
;;;2512       return (p_blk);
;;;2513   }
00004e  e8bd9ffc          POP      {r2-r12,pc}
                  |L22.82|
000052  bf00              NOP                            ;2510
000054  bf00              NOP                            ;2510
000056  4658              MOV      r0,r11                ;2510
000058  f7fffffe          BL       CPU_SR_Restore
00005c  bf00              NOP                            ;2510
00005e  bf00              NOP                            ;2510
000060  4640              MOV      r0,r8                 ;2512
000062  e7f4              B        |L22.78|
;;;2514   
                          ENDP


                          AREA ||i.Mem_SegClr||, CODE, READONLY, ALIGN=1

                  Mem_SegClr PROC
;;;968    #if (LIB_MEM_CFG_DBG_INFO_EN == DEF_DISABLED)
;;;969    void  Mem_SegClr (MEM_SEG  *p_seg,
000000  b570              PUSH     {r4-r6,lr}
;;;970                      LIB_ERR  *p_err)
;;;971    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;972        CPU_SR_ALLOC();
000006  2600              MOVS     r6,#0
;;;973    
;;;974    
;;;975    #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
;;;976        if (p_err == DEF_NULL) {                                    /* Chk for null err ptr.                                */
;;;977            CPU_SW_EXCEPTION(;);
;;;978        }
;;;979    
;;;980        if (p_seg == DEF_NULL) {                                    /* Chk for null seg ptr.                                */
;;;981           *p_err = LIB_MEM_ERR_NULL_PTR;
;;;982            return;
;;;983        }
;;;984    #endif
;;;985    
;;;986        CPU_CRITICAL_ENTER();
000008  bf00              NOP      
00000a  bf00              NOP      
00000c  f7fffffe          BL       CPU_SR_Save
000010  4606              MOV      r6,r0
000012  bf00              NOP      
000014  bf00              NOP      
;;;987        p_seg->AddrNext = p_seg->AddrBase;
000016  6820              LDR      r0,[r4,#0]
000018  60a0              STR      r0,[r4,#8]
;;;988        CPU_CRITICAL_EXIT();
00001a  bf00              NOP      
00001c  bf00              NOP      
00001e  4630              MOV      r0,r6
000020  f7fffffe          BL       CPU_SR_Restore
000024  bf00              NOP      
000026  bf00              NOP      
;;;989    
;;;990       *p_err = LIB_MEM_ERR_NONE;
000028  f2427010          MOV      r0,#0x2710
00002c  8028              STRH     r0,[r5,#0]
;;;991    }
00002e  bd70              POP      {r4-r6,pc}
;;;992    #endif
                          ENDP


                          AREA ||i.Mem_SegCreate||, CODE, READONLY, ALIGN=1

                  Mem_SegCreate PROC
;;;884    
;;;885    void  Mem_SegCreate (const  CPU_CHAR    *p_name,
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;886                                MEM_SEG     *p_seg,
;;;887                                CPU_ADDR     seg_base_addr,
;;;888                                CPU_SIZE_T   size,
;;;889                                CPU_SIZE_T   padding_align,
;;;890                                LIB_ERR     *p_err)
;;;891    {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
00000a  461c              MOV      r4,r3
00000c  e9dd890a          LDRD     r8,r9,[sp,#0x28]
;;;892        CPU_SR_ALLOC();
000010  f04f0a00          MOV      r10,#0
;;;893    
;;;894    
;;;895    #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
;;;896        if (p_err == DEF_NULL) {                                    /* Chk for null err ptr.                                */
;;;897            CPU_SW_EXCEPTION(;);
;;;898        }
;;;899    
;;;900        if (p_seg == DEF_NULL) {                                    /* Chk for null seg ptr.                                */
;;;901           *p_err = LIB_MEM_ERR_NULL_PTR;
;;;902            return;
;;;903        }
;;;904    
;;;905        if (size < 1u) {                                            /* Chk for invalid sized seg.                           */
;;;906           *p_err = LIB_MEM_ERR_INVALID_SEG_SIZE;
;;;907            return;
;;;908        }
;;;909                                                                    /* Chk for addr space ovf.                              */
;;;910        if (seg_base_addr + (size - 1u) < seg_base_addr) {
;;;911           *p_err = LIB_MEM_ERR_INVALID_SEG_SIZE;
;;;912            return;
;;;913        }
;;;914    
;;;915        if ((padding_align               != LIB_MEM_PADDING_ALIGN_NONE) &&
;;;916            (MATH_IS_PWR2(padding_align) != DEF_YES)) {
;;;917           *p_err = LIB_MEM_ERR_INVALID_MEM_ALIGN;
;;;918            return;
;;;919        }
;;;920    #endif
;;;921    
;;;922        CPU_CRITICAL_ENTER();
000014  bf00              NOP      
000016  bf00              NOP      
000018  f7fffffe          BL       CPU_SR_Save
00001c  4682              MOV      r10,r0
00001e  bf00              NOP      
000020  bf00              NOP      
;;;923    #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
;;;924        (void)Mem_SegOverlapChkCritical(seg_base_addr,              /* Chk for overlap.                                     */
;;;925                                        size,
;;;926                                        p_err);
;;;927        if (*p_err != LIB_MEM_ERR_NONE) {
;;;928            CPU_CRITICAL_EXIT();
;;;929            return;
;;;930        }
;;;931    #endif
;;;932    
;;;933        Mem_SegCreateCritical(p_name,                               /* Create seg.                                          */
000022  4643              MOV      r3,r8
000024  463a              MOV      r2,r7
000026  4631              MOV      r1,r6
000028  4628              MOV      r0,r5
00002a  9400              STR      r4,[sp,#0]
00002c  f7fffffe          BL       Mem_SegCreateCritical
;;;934                              p_seg,
;;;935                              seg_base_addr,
;;;936                              padding_align,
;;;937                              size);
;;;938        CPU_CRITICAL_EXIT();
000030  bf00              NOP      
000032  bf00              NOP      
000034  4650              MOV      r0,r10
000036  f7fffffe          BL       CPU_SR_Restore
00003a  bf00              NOP      
00003c  bf00              NOP      
;;;939    
;;;940       *p_err = LIB_MEM_ERR_NONE;
00003e  f2427010          MOV      r0,#0x2710
000042  f8a90000          STRH     r0,[r9,#0]
;;;941    }
000046  e8bd8ff8          POP      {r3-r11,pc}
;;;942    
                          ENDP


                          AREA ||i.Mem_SegCreateCritical||, CODE, READONLY, ALIGN=2

                  Mem_SegCreateCritical PROC
;;;2326   
;;;2327   static  void  Mem_SegCreateCritical(const  CPU_CHAR    *p_name,
000000  b530              PUSH     {r4,r5,lr}
;;;2328                                              MEM_SEG     *p_seg,
;;;2329                                              CPU_ADDR     seg_base_addr,
;;;2330                                              CPU_SIZE_T   padding_align,
;;;2331                                              CPU_SIZE_T   size)
;;;2332   {
000002  9c03              LDR      r4,[sp,#0xc]
;;;2333       p_seg->AddrBase         =  seg_base_addr;
000004  600a              STR      r2,[r1,#0]
;;;2334       p_seg->AddrEnd          = (seg_base_addr + (size - 1u));
000006  1e65              SUBS     r5,r4,#1
000008  4415              ADD      r5,r5,r2
00000a  604d              STR      r5,[r1,#4]
;;;2335       p_seg->AddrNext         =  seg_base_addr;
00000c  608a              STR      r2,[r1,#8]
;;;2336       p_seg->NextPtr          =  Mem_SegHeadPtr;
00000e  4d03              LDR      r5,|L25.28|
000010  682d              LDR      r5,[r5,#0]  ; Mem_SegHeadPtr
000012  60cd              STR      r5,[r1,#0xc]
;;;2337       p_seg->PaddingAlign     =  padding_align;
000014  610b              STR      r3,[r1,#0x10]
;;;2338   
;;;2339   #if (LIB_MEM_CFG_DBG_INFO_EN == DEF_ENABLED)
;;;2340       p_seg->NamePtr          = p_name;
;;;2341       p_seg->AllocInfoHeadPtr = DEF_NULL;
;;;2342   #else
;;;2343       (void)&p_name;
;;;2344   #endif
;;;2345   
;;;2346       Mem_SegHeadPtr = p_seg;
000016  4d01              LDR      r5,|L25.28|
000018  6029              STR      r1,[r5,#0]  ; Mem_SegHeadPtr
;;;2347   }
00001a  bd30              POP      {r4,r5,pc}
;;;2348   
                          ENDP

                  |L25.28|
                          DCD      Mem_SegHeadPtr

                          AREA ||i.Mem_SegOverlapChkCritical||, CODE, READONLY, ALIGN=2

                  Mem_SegOverlapChkCritical PROC
;;;2375   
;;;2376   static  MEM_SEG  *Mem_SegOverlapChkCritical (CPU_ADDR     seg_base_addr,
000000  b5f0              PUSH     {r4-r7,lr}
;;;2377                                                CPU_SIZE_T   size,
;;;2378                                                LIB_ERR     *p_err)
;;;2379   {
000002  4603              MOV      r3,r0
000004  460e              MOV      r6,r1
000006  4614              MOV      r4,r2
;;;2380       MEM_SEG   *p_seg_chk;
;;;2381       CPU_ADDR   seg_new_end;
;;;2382       CPU_ADDR   seg_chk_start;
;;;2383       CPU_ADDR   seg_chk_end;
;;;2384   
;;;2385   
;;;2386       seg_new_end = seg_base_addr + (size - 1u);
000008  1e70              SUBS     r0,r6,#1
00000a  18c7              ADDS     r7,r0,r3
;;;2387       p_seg_chk   = Mem_SegHeadPtr;
00000c  4811              LDR      r0,|L26.84|
00000e  6801              LDR      r1,[r0,#0]  ; Mem_SegHeadPtr
;;;2388   
;;;2389       while (p_seg_chk != DEF_NULL) {
000010  e018              B        |L26.68|
                  |L26.18|
;;;2390           seg_chk_start = (CPU_ADDR)p_seg_chk->AddrBase;
000012  680a              LDR      r2,[r1,#0]
;;;2391           seg_chk_end   = (CPU_ADDR)p_seg_chk->AddrEnd;
000014  684d              LDR      r5,[r1,#4]
;;;2392   
;;;2393           if ((seg_base_addr == seg_chk_start) && (seg_new_end == seg_chk_end)) {
000016  4293              CMP      r3,r2
000018  d106              BNE      |L26.40|
00001a  42af              CMP      r7,r5
00001c  d104              BNE      |L26.40|
;;;2394              *p_err = LIB_MEM_ERR_INVALID_SEG_EXISTS;
00001e  f44f501e          MOV      r0,#0x2780
000022  8020              STRH     r0,[r4,#0]
;;;2395               return (p_seg_chk);
000024  4608              MOV      r0,r1
                  |L26.38|
;;;2396           } else if (((seg_base_addr >= seg_chk_start) && (seg_base_addr <= seg_chk_end)) ||
;;;2397                      ((seg_base_addr <= seg_chk_start) && (seg_new_end   >= seg_chk_start))) {
;;;2398              *p_err = LIB_MEM_ERR_INVALID_SEG_OVERLAP;
;;;2399               return (p_seg_chk);
;;;2400           }
;;;2401   
;;;2402           p_seg_chk = p_seg_chk->NextPtr;
;;;2403       }
;;;2404   
;;;2405      *p_err = LIB_MEM_ERR_NONE;
;;;2406   
;;;2407       return (DEF_NULL);
;;;2408   }
000026  bdf0              POP      {r4-r7,pc}
                  |L26.40|
000028  4293              CMP      r3,r2                 ;2396
00002a  d301              BCC      |L26.48|
00002c  42ab              CMP      r3,r5                 ;2396
00002e  d903              BLS      |L26.56|
                  |L26.48|
000030  4293              CMP      r3,r2                 ;2397
000032  d806              BHI      |L26.66|
000034  4297              CMP      r7,r2                 ;2397
000036  d304              BCC      |L26.66|
                  |L26.56|
000038  f242707f          MOV      r0,#0x277f            ;2398
00003c  8020              STRH     r0,[r4,#0]            ;2398
00003e  4608              MOV      r0,r1                 ;2399
000040  e7f1              B        |L26.38|
                  |L26.66|
000042  68c9              LDR      r1,[r1,#0xc]          ;2402
                  |L26.68|
000044  2900              CMP      r1,#0                 ;2389
000046  d1e4              BNE      |L26.18|
000048  f2427010          MOV      r0,#0x2710            ;2405
00004c  8020              STRH     r0,[r4,#0]            ;2405
00004e  2000              MOVS     r0,#0                 ;2407
000050  e7e9              B        |L26.38|
;;;2409   
                          ENDP

000052  0000              DCW      0x0000
                  |L26.84|
                          DCD      Mem_SegHeadPtr

                          AREA ||i.Mem_SegRemSizeGet||, CODE, READONLY, ALIGN=2

                  Mem_SegRemSizeGet PROC
;;;1024   
;;;1025   CPU_SIZE_T  Mem_SegRemSizeGet (MEM_SEG       *p_seg,
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;1026                                  CPU_SIZE_T     align,
;;;1027                                  MEM_SEG_INFO  *p_seg_info,
;;;1028                                  LIB_ERR       *p_err)
;;;1029   {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4615              MOV      r5,r2
00000a  469a              MOV      r10,r3
;;;1030       CPU_SIZE_T  rem_size;
;;;1031       CPU_SIZE_T  total_size;
;;;1032       CPU_SIZE_T  used_size;
;;;1033       CPU_ADDR    next_addr_align;
;;;1034       CPU_SR_ALLOC();
00000c  2000              MOVS     r0,#0
00000e  9000              STR      r0,[sp,#0]
;;;1035   
;;;1036   
;;;1037   #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
;;;1038       if (p_err == DEF_NULL) {                                    /* Chk for null err ptr.                                */
;;;1039           CPU_SW_EXCEPTION(seg_info);
;;;1040       }
;;;1041   
;;;1042       if (MATH_IS_PWR2(align) != DEF_YES) {                       /* Chk for invalid align val.                           */
;;;1043          *p_err = LIB_MEM_ERR_INVALID_MEM_ALIGN;
;;;1044           return (0u);
;;;1045       }
;;;1046   #endif
;;;1047   
;;;1048       if (p_seg == DEF_NULL) {                                    /* Dflt to heap in case p_seg is null.                  */
000010  b904              CBNZ     r4,|L27.20|
;;;1049   #if (LIB_MEM_CFG_HEAP_SIZE > 0u)
;;;1050           p_seg = &Mem_SegHeap;
000012  4c19              LDR      r4,|L27.120|
                  |L27.20|
;;;1051   #else
;;;1052          *p_err = LIB_MEM_ERR_NULL_PTR;
;;;1053           return (0u);
;;;1054   #endif
;;;1055       }
;;;1056   
;;;1057       CPU_CRITICAL_ENTER();                                       /* Calc seg stats.                                      */
000014  bf00              NOP      
000016  bf00              NOP      
000018  f7fffffe          BL       CPU_SR_Save
00001c  9000              STR      r0,[sp,#0]
00001e  bf00              NOP      
000020  bf00              NOP      
;;;1058       next_addr_align = MATH_ROUND_INC_UP_PWR2(p_seg->AddrNext, align);
000022  1e71              SUBS     r1,r6,#1
000024  68a0              LDR      r0,[r4,#8]
000026  4388              BICS     r0,r0,r1
000028  1e72              SUBS     r2,r6,#1
00002a  68a1              LDR      r1,[r4,#8]
00002c  4011              ANDS     r1,r1,r2
00002e  b909              CBNZ     r1,|L27.52|
000030  2100              MOVS     r1,#0
000032  e000              B        |L27.54|
                  |L27.52|
000034  4631              MOV      r1,r6
                  |L27.54|
000036  eb000901          ADD      r9,r0,r1
;;;1059       CPU_CRITICAL_EXIT();
00003a  bf00              NOP      
00003c  bf00              NOP      
00003e  9800              LDR      r0,[sp,#0]
000040  f7fffffe          BL       CPU_SR_Restore
000044  bf00              NOP      
000046  bf00              NOP      
;;;1060   
;;;1061       total_size = p_seg->AddrEnd  - p_seg->AddrBase + 1u;
000048  e9d41000          LDRD     r1,r0,[r4,#0]
00004c  1a40              SUBS     r0,r0,r1
00004e  1c47              ADDS     r7,r0,#1
;;;1062       used_size  = next_addr_align - p_seg->AddrBase;
000050  6820              LDR      r0,[r4,#0]
000052  eba90800          SUB      r8,r9,r0
;;;1063       rem_size   = total_size      - used_size;
000056  eba70b08          SUB      r11,r7,r8
;;;1064   
;;;1065       if (p_seg_info != DEF_NULL) {
00005a  b135              CBZ      r5,|L27.106|
;;;1066           p_seg_info->TotalSize     = total_size;
00005c  606f              STR      r7,[r5,#4]
;;;1067           p_seg_info->UsedSize      = used_size;
00005e  f8c58000          STR      r8,[r5,#0]
;;;1068           p_seg_info->AddrBase      = p_seg->AddrBase;
000062  6820              LDR      r0,[r4,#0]
000064  60a8              STR      r0,[r5,#8]
;;;1069           p_seg_info->AddrNextAlloc = next_addr_align;
000066  f8c5900c          STR      r9,[r5,#0xc]
                  |L27.106|
;;;1070       }
;;;1071   
;;;1072      *p_err = LIB_MEM_ERR_NONE;
00006a  f2427010          MOV      r0,#0x2710
00006e  f8aa0000          STRH     r0,[r10,#0]
;;;1073   
;;;1074       return (rem_size);
000072  4658              MOV      r0,r11
;;;1075   }
000074  e8bd8ff8          POP      {r3-r11,pc}
;;;1076   
                          ENDP

                  |L27.120|
                          DCD      Mem_SegHeap

                          AREA ||i.Mem_Set||, CODE, READONLY, ALIGN=1

                  Mem_Set PROC
;;;302    
;;;303    void  Mem_Set (void        *pmem,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;304                   CPU_INT08U   data_val,
;;;305                   CPU_SIZE_T   size)
;;;306    {
000004  4605              MOV      r5,r0
000006  460b              MOV      r3,r1
000008  4694              MOV      r12,r2
;;;307        CPU_SIZE_T   size_rem;
;;;308        CPU_ALIGN    data_align;
;;;309        CPU_ALIGN   *pmem_align;
;;;310        CPU_INT08U  *pmem_08;
;;;311        CPU_DATA     mem_align_mod;
;;;312        CPU_DATA     i;
;;;313    
;;;314    
;;;315    #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
;;;316        if (size < 1) {                                             /* See Note #1.                                         */
;;;317            return;
;;;318        }
;;;319        if (pmem == (void *)0) {
;;;320            return;
;;;321        }
;;;322    #endif
;;;323    
;;;324    
;;;325        data_align = 0u;
00000a  2700              MOVS     r7,#0
;;;326        for (i = 0u; i < sizeof(CPU_ALIGN); i++) {                  /* Fill each data_align octet with data val.            */
00000c  2400              MOVS     r4,#0
00000e  e002              B        |L28.22|
                  |L28.16|
;;;327            data_align <<=  DEF_OCTET_NBR_BITS;
000010  023f              LSLS     r7,r7,#8
;;;328            data_align  |= (CPU_ALIGN)data_val;
000012  431f              ORRS     r7,r7,r3
000014  1c64              ADDS     r4,r4,#1              ;326
                  |L28.22|
000016  2c04              CMP      r4,#4                 ;326
000018  d3fa              BCC      |L28.16|
;;;329        }
;;;330    
;;;331        size_rem      =  size;
00001a  4660              MOV      r0,r12
;;;332        mem_align_mod = (CPU_INT08U)((CPU_ADDR)pmem % sizeof(CPU_ALIGN));   /* See Note #3.                                 */
00001c  f0050603          AND      r6,r5,#3
;;;333    
;;;334        pmem_08 = (CPU_INT08U *)pmem;
000020  4629              MOV      r1,r5
;;;335        if (mem_align_mod != 0u) {                                  /* If leading octets avail,                   ...       */
000022  b146              CBZ      r6,|L28.54|
;;;336            i = mem_align_mod;
000024  4634              MOV      r4,r6
;;;337            while ((size_rem > 0) &&                                /* ... start mem buf fill with leading octets ...       */
000026  e003              B        |L28.48|
                  |L28.40|
;;;338                   (i        < sizeof(CPU_ALIGN ))) {               /* ... until next CPU_ALIGN word boundary.              */
;;;339               *pmem_08++ = data_val;
000028  f8013b01          STRB     r3,[r1],#1
;;;340                size_rem -= sizeof(CPU_INT08U);
00002c  1e40              SUBS     r0,r0,#1
;;;341                i++;
00002e  1c64              ADDS     r4,r4,#1
                  |L28.48|
000030  b108              CBZ      r0,|L28.54|
000032  2c04              CMP      r4,#4                 ;338
000034  d3f8              BCC      |L28.40|
                  |L28.54|
;;;342            }
;;;343        }
;;;344    
;;;345        pmem_align = (CPU_ALIGN *)pmem_08;                          /* See Note #2.                                         */
000036  460a              MOV      r2,r1
;;;346        while (size_rem >= sizeof(CPU_ALIGN)) {                     /* While mem buf aligned on CPU_ALIGN word boundaries,  */
000038  e001              B        |L28.62|
                  |L28.58|
;;;347           *pmem_align++ = data_align;                              /* ... fill mem buf with    CPU_ALIGN-sized data.       */
00003a  c280              STM      r2!,{r7}
;;;348            size_rem    -= sizeof(CPU_ALIGN);
00003c  1f00              SUBS     r0,r0,#4
                  |L28.62|
00003e  2804              CMP      r0,#4                 ;346
000040  d2fb              BCS      |L28.58|
;;;349        }
;;;350    
;;;351        pmem_08 = (CPU_INT08U *)pmem_align;
000042  4611              MOV      r1,r2
;;;352        while (size_rem > 0) {                                      /* Finish mem buf fill with trailing octets.            */
000044  e002              B        |L28.76|
                  |L28.70|
;;;353           *pmem_08++   = data_val;
000046  f8013b01          STRB     r3,[r1],#1
;;;354            size_rem   -= sizeof(CPU_INT08U);
00004a  1e40              SUBS     r0,r0,#1
                  |L28.76|
00004c  2800              CMP      r0,#0                 ;352
00004e  d1fa              BNE      |L28.70|
;;;355        }
;;;356    }
000050  e8bd81f0          POP      {r4-r8,pc}
;;;357    
                          ENDP


                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  Mem_Heap
                          %        3072
                  Mem_SegHeap
                          %        20

                          AREA ||.data||, DATA, ALIGN=2

                  Mem_SegHeadPtr
                          DCD      0x00000000
