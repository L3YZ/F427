; generated by Component: ARM Compiler 5.05 (build 41) Tool: ArmCC [4d0eb9]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\os_mutex.o --asm_dir=.\Lst\ --list_dir=.\Lst\ --depend=.\obj\os_mutex.d --cpu=Cortex-M4.fp --apcs=interwork -O0 -I..\..\..\CMSIS\4.5.0\CMSIS\Include -I..\APP -I..\APP\ST -I..\APP\uCOS -I..\..\BSP\KeilMDK -I..\..\BSP\Board\inc -I..\..\BSP\STM32F4xx\inc -I..\..\BSP\Xlong\inc -I..\..\..\uCOS\uC-CPU -I..\..\..\uCOS\uC-CPU\Ports\ARM-Cortex-M4 -I..\..\..\uCOS\uC-LIB -I..\..\..\uCOS\uC-LIB\Ports\ARM-Cortex-M4 -I..\..\..\uCOS\uCOS-III\Source -I..\..\..\uCOS\uCOS-III\Ports\ARM-Cortex-M4 -IC:\Users\V200\Desktop\XLong\XLong\OS\KeilMDKPrj\RTE -Id:\Keil_v5\ARM\PACK\Keil\STM32F4xx_DFP\1.0.8\Device\Include -Id:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -DSTM32F427_437xx -DSTM32F427_437xx -DUSE_STDPERIPH_DRIVER --omf_browse=.\obj\os_mutex.crf ..\..\..\uCOS\uCOS-III\Source\os_mutex.c]
                          THUMB

                          AREA ||i.OSMutexCreate||, CODE, READONLY, ALIGN=2

                  OSMutexCreate PROC
;;;68     
;;;69     void  OSMutexCreate (OS_MUTEX  *p_mutex,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;70                          CPU_CHAR  *p_name,
;;;71                          OS_ERR    *p_err)
;;;72     {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4615              MOV      r5,r2
;;;73         CPU_SR_ALLOC();
00000a  2700              MOVS     r7,#0
;;;74     
;;;75     
;;;76     
;;;77     #ifdef OS_SAFETY_CRITICAL
;;;78         if (p_err == (OS_ERR *)0) {
;;;79             OS_SAFETY_CRITICAL_EXCEPTION();
;;;80             return;
;;;81         }
;;;82     #endif
;;;83     
;;;84     #ifdef OS_SAFETY_CRITICAL_IEC61508
;;;85         if (OSSafetyCriticalStartFlag == DEF_TRUE) {
;;;86            *p_err = OS_ERR_ILLEGAL_CREATE_RUN_TIME;
;;;87             return;
;;;88         }
;;;89     #endif
;;;90     
;;;91     #if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
;;;92         if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* Not allowed to be called from an ISR                   */
;;;93            *p_err = OS_ERR_CREATE_ISR;
;;;94             return;
;;;95         }
;;;96     #endif
;;;97     
;;;98     #if OS_CFG_ARG_CHK_EN > 0u
;;;99         if (p_mutex == (OS_MUTEX *)0) {                         /* Validate 'p_mutex'                                     */
00000c  b924              CBNZ     r4,|L1.24|
;;;100           *p_err = OS_ERR_OBJ_PTR_NULL;
00000e  f64550c3          MOV      r0,#0x5dc3
000012  8028              STRH     r0,[r5,#0]
                  |L1.20|
;;;101            return;
;;;102        }
;;;103    #endif
;;;104    
;;;105        OS_CRITICAL_ENTER();
;;;106    #if OS_OBJ_TYPE_REQ > 0u
;;;107        p_mutex->Type              =  OS_OBJ_TYPE_MUTEX;        /* Mark the data structure as a mutex                     */
;;;108    #endif
;;;109    #if OS_CFG_DBG_EN > 0u
;;;110        p_mutex->NamePtr           =  p_name;
;;;111    #else
;;;112        (void)&p_name;
;;;113    #endif
;;;114        p_mutex->MutexGrpNextPtr   = (OS_MUTEX     *)0;
;;;115        p_mutex->OwnerTCBPtr       = (OS_TCB       *)0;
;;;116        p_mutex->OwnerNestingCtr   = (OS_NESTING_CTR)0;         /* Mutex is available                                     */
;;;117        p_mutex->TS                = (CPU_TS        )0;
;;;118        OS_PendListInit(&p_mutex->PendList);                    /* Initialize the waiting list                            */
;;;119    
;;;120    #if OS_CFG_DBG_EN > 0u
;;;121        OS_MutexDbgListAdd(p_mutex);
;;;122    #endif
;;;123    
;;;124        OSMutexQty++;
;;;125    
;;;126    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN > 0u))
;;;127        TRACE_OS_MUTEX_CREATE(p_mutex, p_name);                 /* Record the event.                                      */
;;;128    #endif
;;;129    
;;;130        OS_CRITICAL_EXIT_NO_SCHED();
;;;131       *p_err = OS_ERR_NONE;
;;;132    }
000014  e8bd81f0          POP      {r4-r8,pc}
                  |L1.24|
000018  bf00              NOP                            ;105
00001a  bf00              NOP                            ;105
00001c  f7fffffe          BL       CPU_SR_Save
000020  4607              MOV      r7,r0                 ;105
000022  bf00              NOP                            ;105
000024  bf00              NOP                            ;105
000026  4810              LDR      r0,|L1.104|
000028  6020              STR      r0,[r4,#0]            ;107
00002a  6066              STR      r6,[r4,#4]            ;110
00002c  2000              MOVS     r0,#0                 ;114
00002e  6220              STR      r0,[r4,#0x20]         ;114
000030  6260              STR      r0,[r4,#0x24]         ;115
000032  f8840028          STRB     r0,[r4,#0x28]         ;116
000036  62e0              STR      r0,[r4,#0x2c]         ;117
000038  f1040008          ADD      r0,r4,#8              ;118
00003c  f7fffffe          BL       OS_PendListInit
000040  4620              MOV      r0,r4                 ;121
000042  f7fffffe          BL       OS_MutexDbgListAdd
000046  4809              LDR      r0,|L1.108|
000048  8800              LDRH     r0,[r0,#0]            ;124  ; OSMutexQty
00004a  1c40              ADDS     r0,r0,#1              ;124
00004c  4907              LDR      r1,|L1.108|
00004e  8008              STRH     r0,[r1,#0]            ;124
000050  bf00              NOP                            ;130
000052  bf00              NOP                            ;130
000054  4638              MOV      r0,r7                 ;130
000056  f7fffffe          BL       CPU_SR_Restore
00005a  bf00              NOP                            ;130
00005c  bf00              NOP                            ;130
00005e  2000              MOVS     r0,#0                 ;131
000060  8028              STRH     r0,[r5,#0]            ;131
000062  bf00              NOP      
000064  e7d6              B        |L1.20|
;;;133    
                          ENDP

000066  0000              DCW      0x0000
                  |L1.104|
                          DCD      0x5854554d
                  |L1.108|
                          DCD      OSMutexQty

                          AREA ||i.OSMutexDel||, CODE, READONLY, ALIGN=2

                  OSMutexDel PROC
;;;170    #if OS_CFG_MUTEX_DEL_EN > 0u
;;;171    OS_OBJ_QTY  OSMutexDel (OS_MUTEX  *p_mutex,
000000  e92d5fff          PUSH     {r0-r12,lr}
;;;172                            OS_OPT     opt,
;;;173                            OS_ERR    *p_err)
;;;174    {
000004  4604              MOV      r4,r0
000006  468a              MOV      r10,r1
000008  4615              MOV      r5,r2
;;;175        OS_OBJ_QTY     cnt;
;;;176        OS_OBJ_QTY     nbr_tasks;
;;;177        OS_PEND_DATA  *p_pend_data;
;;;178        OS_PEND_LIST  *p_pend_list;
;;;179        OS_TCB        *p_tcb;
;;;180        OS_TCB        *p_tcb_owner;
;;;181        CPU_TS         ts;
;;;182    #if OS_CFG_MUTEX_EN > 0u
;;;183        OS_PRIO        prio_new;
;;;184    #endif
;;;185        CPU_SR_ALLOC();
00000a  2000              MOVS     r0,#0
00000c  9000              STR      r0,[sp,#0]
;;;186    
;;;187    
;;;188    
;;;189    #ifdef OS_SAFETY_CRITICAL
;;;190        if (p_err == (OS_ERR *)0) {
;;;191            OS_SAFETY_CRITICAL_EXCEPTION();
;;;192            return ((OS_OBJ_QTY)0);
;;;193        }
;;;194    #endif
;;;195    
;;;196    #if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
;;;197        if (OSIntNestingCtr > (OS_NESTING_CTR)0) {                  /* Not allowed to delete a mutex from an ISR            */
;;;198           *p_err = OS_ERR_DEL_ISR;
;;;199            return ((OS_OBJ_QTY)0);
;;;200        }
;;;201    #endif
;;;202    
;;;203    #if OS_CFG_ARG_CHK_EN > 0u
;;;204        if (p_mutex == (OS_MUTEX *)0) {                             /* Validate 'p_mutex'                                   */
00000e  b934              CBNZ     r4,|L2.30|
;;;205           *p_err = OS_ERR_OBJ_PTR_NULL;
000010  f64550c3          MOV      r0,#0x5dc3
000014  8028              STRH     r0,[r5,#0]
;;;206            return ((OS_OBJ_QTY)0);
000016  2000              MOVS     r0,#0
                  |L2.24|
;;;207        }
;;;208        switch (opt) {                                              /* Validate 'opt'                                       */
;;;209            case OS_OPT_DEL_NO_PEND:
;;;210            case OS_OPT_DEL_ALWAYS:
;;;211                 break;
;;;212    
;;;213            default:
;;;214                *p_err =  OS_ERR_OPT_INVALID;
;;;215                 return ((OS_OBJ_QTY)0);
;;;216        }
;;;217    #endif
;;;218    
;;;219    #if OS_CFG_OBJ_TYPE_CHK_EN > 0u
;;;220        if (p_mutex->Type != OS_OBJ_TYPE_MUTEX) {                   /* Make sure mutex was created                          */
;;;221           *p_err = OS_ERR_OBJ_TYPE;
;;;222            return ((OS_OBJ_QTY)0);
;;;223        }
;;;224    #endif
;;;225    
;;;226        OS_CRITICAL_ENTER();
;;;227        p_pend_list = &p_mutex->PendList;
;;;228        cnt         = p_pend_list->NbrEntries;
;;;229        nbr_tasks   = cnt;
;;;230        switch (opt) {
;;;231            case OS_OPT_DEL_NO_PEND:                                /* Delete mutex only if no task waiting                 */
;;;232                 if (nbr_tasks == (OS_OBJ_QTY)0) {
;;;233    #if OS_CFG_DBG_EN > 0u
;;;234                     OS_MutexDbgListRemove(p_mutex);
;;;235    #endif
;;;236                     OSMutexQty--;
;;;237    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN > 0u))
;;;238                     TRACE_OS_MUTEX_DEL(p_mutex);                   /* Record the event.                                    */
;;;239    #endif
;;;240                     if (p_mutex->OwnerTCBPtr != (OS_TCB *)0) {     /* Does the mutex belong to a task?                     */
;;;241                         OS_MutexGrpRemove(p_mutex->OwnerTCBPtr, p_mutex); /* yes, remove it from the task group.           */
;;;242                     }
;;;243                     OS_MutexClr(p_mutex);
;;;244                     OS_CRITICAL_EXIT();
;;;245                    *p_err = OS_ERR_NONE;
;;;246                 } else {
;;;247                     OS_CRITICAL_EXIT();
;;;248                    *p_err = OS_ERR_TASK_WAITING;
;;;249                 }
;;;250                 break;
;;;251    
;;;252            case OS_OPT_DEL_ALWAYS:                                 /* Always delete the mutex                              */
;;;253                 ts = OS_TS_GET();                                  /* Get timestamp                                        */
;;;254                 while (cnt > 0u) {                                 /* Remove all tasks from the pend list                  */
;;;255                     p_pend_data = p_pend_list->HeadPtr;
;;;256                     p_tcb       = p_pend_data->TCBPtr;
;;;257                     OS_PendObjDel((OS_PEND_OBJ *)((void *)p_mutex),
;;;258                                   p_tcb,
;;;259                                   ts);
;;;260                     cnt--;
;;;261                 }
;;;262    #if OS_CFG_DBG_EN > 0u
;;;263                 OS_MutexDbgListRemove(p_mutex);
;;;264    #endif
;;;265                 OSMutexQty--;
;;;266    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN > 0u))
;;;267                 TRACE_OS_MUTEX_DEL(p_mutex);                       /* Record the event.                                    */
;;;268    #endif
;;;269    
;;;270                 p_tcb_owner = p_mutex->OwnerTCBPtr;
;;;271                 if (p_tcb_owner != (OS_TCB *)0) {                  /* Does the mutex belong to a task?                     */
;;;272                     OS_MutexGrpRemove(p_tcb_owner, p_mutex);       /* yes, remove it from the task group.                  */
;;;273                 }
;;;274    
;;;275    
;;;276                 if ((p_tcb_owner       != (OS_TCB *)0) &&          /* Did we had to change the prio of owner?              */
;;;277                     (p_tcb_owner->Prio !=  p_tcb_owner->BasePrio)) {
;;;278                     prio_new = OS_MutexGrpPrioFindHighest(p_tcb_owner);
;;;279                     prio_new = prio_new > p_tcb_owner->BasePrio ? p_tcb_owner->BasePrio : prio_new;
;;;280                     OS_TaskChangePrio(p_tcb_owner, prio_new);
;;;281    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN > 0u))
;;;282                              TRACE_OS_MUTEX_TASK_PRIO_DISINHERIT(p_tcb_owner, p_tcb_owner->Prio)
;;;283    #endif
;;;284                 }
;;;285    
;;;286                 OS_MutexClr(p_mutex);
;;;287                 OS_CRITICAL_EXIT_NO_SCHED();
;;;288                 OSSched();                                         /* Find highest priority task ready to run              */
;;;289                *p_err = OS_ERR_NONE;
;;;290                 break;
;;;291    
;;;292            default:
;;;293                 OS_CRITICAL_EXIT();
;;;294                *p_err = OS_ERR_OPT_INVALID;
;;;295                 break;
;;;296        }
;;;297        return (nbr_tasks);
;;;298    }
000018  b004              ADD      sp,sp,#0x10
00001a  e8bd9ff0          POP      {r4-r12,pc}
                  |L2.30|
00001e  f1ba0f00          CMP      r10,#0                ;208
000022  d003              BEQ      |L2.44|
000024  f1ba0f01          CMP      r10,#1                ;208
000028  d102              BNE      |L2.48|
00002a  e000              B        |L2.46|
                  |L2.44|
00002c  bf00              NOP                            ;210
                  |L2.46|
00002e  e004              B        |L2.58|
                  |L2.48|
000030  f6456025          MOV      r0,#0x5e25            ;214
000034  8028              STRH     r0,[r5,#0]            ;214
000036  2000              MOVS     r0,#0                 ;215
000038  e7ee              B        |L2.24|
                  |L2.58|
00003a  bf00              NOP                            ;211
00003c  494d              LDR      r1,|L2.372|
00003e  6820              LDR      r0,[r4,#0]            ;220
000040  4288              CMP      r0,r1                 ;220
000042  d004              BEQ      |L2.78|
000044  f64550c4          MOV      r0,#0x5dc4            ;221
000048  8028              STRH     r0,[r5,#0]            ;221
00004a  2000              MOVS     r0,#0                 ;222
00004c  e7e4              B        |L2.24|
                  |L2.78|
00004e  bf00              NOP                            ;226
000050  bf00              NOP                            ;226
000052  f7fffffe          BL       CPU_SR_Save
000056  9000              STR      r0,[sp,#0]            ;226
000058  bf00              NOP                            ;226
00005a  bf00              NOP                            ;226
00005c  f1040b08          ADD      r11,r4,#8             ;227
000060  f8bb7008          LDRH     r7,[r11,#8]           ;228
000064  46b8              MOV      r8,r7                 ;229
000066  f1ba0f00          CMP      r10,#0                ;230
00006a  d003              BEQ      |L2.116|
00006c  f1ba0f01          CMP      r10,#1                ;230
000070  d172              BNE      |L2.344|
000072  e028              B        |L2.198|
                  |L2.116|
000074  f1b80f00          CMP      r8,#0                 ;232
000078  d11a              BNE      |L2.176|
00007a  4620              MOV      r0,r4                 ;234
00007c  f7fffffe          BL       OS_MutexDbgListRemove
000080  483d              LDR      r0,|L2.376|
000082  8800              LDRH     r0,[r0,#0]            ;236  ; OSMutexQty
000084  1e40              SUBS     r0,r0,#1              ;236
000086  493c              LDR      r1,|L2.376|
000088  8008              STRH     r0,[r1,#0]            ;236
00008a  6a60              LDR      r0,[r4,#0x24]         ;240
00008c  b118              CBZ      r0,|L2.150|
00008e  4621              MOV      r1,r4                 ;241
000090  6a60              LDR      r0,[r4,#0x24]         ;241
000092  f7fffffe          BL       OS_MutexGrpRemove
                  |L2.150|
000096  4620              MOV      r0,r4                 ;243
000098  f7fffffe          BL       OS_MutexClr
00009c  bf00              NOP                            ;244
00009e  bf00              NOP                            ;244
0000a0  9800              LDR      r0,[sp,#0]            ;244
0000a2  f7fffffe          BL       CPU_SR_Restore
0000a6  bf00              NOP                            ;244
0000a8  bf00              NOP                            ;244
0000aa  2000              MOVS     r0,#0                 ;245
0000ac  8028              STRH     r0,[r5,#0]            ;245
0000ae  e009              B        |L2.196|
                  |L2.176|
0000b0  bf00              NOP                            ;247
0000b2  bf00              NOP                            ;247
0000b4  9800              LDR      r0,[sp,#0]            ;247
0000b6  f7fffffe          BL       CPU_SR_Restore
0000ba  bf00              NOP                            ;247
0000bc  bf00              NOP                            ;247
0000be  f247105f          MOV      r0,#0x715f            ;248
0000c2  8028              STRH     r0,[r5,#0]            ;248
                  |L2.196|
0000c4  e053              B        |L2.366|
                  |L2.198|
0000c6  f7fffffe          BL       CPU_TS_TmrRd
0000ca  9001              STR      r0,[sp,#4]            ;253
0000cc  e00c              B        |L2.232|
                  |L2.206|
0000ce  f8db0000          LDR      r0,[r11,#0]           ;255
0000d2  9003              STR      r0,[sp,#0xc]          ;255
0000d4  9803              LDR      r0,[sp,#0xc]          ;256
0000d6  6880              LDR      r0,[r0,#8]            ;256
0000d8  9002              STR      r0,[sp,#8]            ;256
0000da  4620              MOV      r0,r4                 ;257
0000dc  e9dd2101          LDRD     r2,r1,[sp,#4]         ;257
0000e0  f7fffffe          BL       OS_PendObjDel
0000e4  1e78              SUBS     r0,r7,#1              ;260
0000e6  b287              UXTH     r7,r0                 ;260
                  |L2.232|
0000e8  2f00              CMP      r7,#0                 ;254
0000ea  d1f0              BNE      |L2.206|
0000ec  4620              MOV      r0,r4                 ;263
0000ee  f7fffffe          BL       OS_MutexDbgListRemove
0000f2  4821              LDR      r0,|L2.376|
0000f4  8800              LDRH     r0,[r0,#0]            ;265  ; OSMutexQty
0000f6  1e40              SUBS     r0,r0,#1              ;265
0000f8  491f              LDR      r1,|L2.376|
0000fa  8008              STRH     r0,[r1,#0]            ;265
0000fc  6a66              LDR      r6,[r4,#0x24]         ;270
0000fe  b11e              CBZ      r6,|L2.264|
000100  4621              MOV      r1,r4                 ;272
000102  4630              MOV      r0,r6                 ;272
000104  f7fffffe          BL       OS_MutexGrpRemove
                  |L2.264|
000108  b1b6              CBZ      r6,|L2.312|
00010a  f8960037          LDRB     r0,[r6,#0x37]         ;277
00010e  f8961038          LDRB     r1,[r6,#0x38]         ;277
000112  4288              CMP      r0,r1                 ;277
000114  d010              BEQ      |L2.312|
000116  4630              MOV      r0,r6                 ;278
000118  f7fffffe          BL       OS_MutexGrpPrioFindHighest
00011c  4681              MOV      r9,r0                 ;278
00011e  f8961038          LDRB     r1,[r6,#0x38]         ;279
000122  4549              CMP      r1,r9                 ;279
000124  da02              BGE      |L2.300|
000126  f8960038          LDRB     r0,[r6,#0x38]         ;279
00012a  e000              B        |L2.302|
                  |L2.300|
00012c  4648              MOV      r0,r9                 ;279
                  |L2.302|
00012e  4681              MOV      r9,r0                 ;279
000130  4649              MOV      r1,r9                 ;280
000132  4630              MOV      r0,r6                 ;280
000134  f7fffffe          BL       OS_TaskChangePrio
                  |L2.312|
000138  4620              MOV      r0,r4                 ;286
00013a  f7fffffe          BL       OS_MutexClr
00013e  bf00              NOP                            ;287
000140  bf00              NOP                            ;287
000142  9800              LDR      r0,[sp,#0]            ;287
000144  f7fffffe          BL       CPU_SR_Restore
000148  bf00              NOP                            ;287
00014a  bf00              NOP                            ;287
00014c  f7fffffe          BL       OSSched
000150  2000              MOVS     r0,#0                 ;289
000152  8028              STRH     r0,[r5,#0]            ;289
000154  e00b              B        |L2.366|
000156  e7ff              B        |L2.344|
                  |L2.344|
000158  bf00              NOP                            ;293
00015a  bf00              NOP                            ;293
00015c  9800              LDR      r0,[sp,#0]            ;293
00015e  f7fffffe          BL       CPU_SR_Restore
000162  bf00              NOP                            ;293
000164  bf00              NOP                            ;293
000166  f6456025          MOV      r0,#0x5e25            ;294
00016a  8028              STRH     r0,[r5,#0]            ;294
00016c  bf00              NOP                            ;295
                  |L2.366|
00016e  bf00              NOP                            ;250
000170  4640              MOV      r0,r8                 ;297
000172  e751              B        |L2.24|
;;;299    #endif
                          ENDP

                  |L2.372|
                          DCD      0x5854554d
                  |L2.376|
                          DCD      OSMutexQty

                          AREA ||i.OSMutexPend||, CODE, READONLY, ALIGN=2

                  OSMutexPend PROC
;;;346    
;;;347    void  OSMutexPend (OS_MUTEX  *p_mutex,
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;348                       OS_TICK    timeout,
;;;349                       OS_OPT     opt,
;;;350                       CPU_TS    *p_ts,
;;;351                       OS_ERR    *p_err)
;;;352    {
000004  b088              SUB      sp,sp,#0x20
000006  4605              MOV      r5,r0
000008  4689              MOV      r9,r1
00000a  4617              MOV      r7,r2
00000c  461c              MOV      r4,r3
00000e  9e10              LDR      r6,[sp,#0x40]
;;;353        OS_PEND_DATA  pend_data;
;;;354        OS_TCB       *p_tcb;
;;;355        CPU_SR_ALLOC();
000010  f04f0a00          MOV      r10,#0
;;;356    
;;;357    
;;;358    
;;;359    #ifdef OS_SAFETY_CRITICAL
;;;360        if (p_err == (OS_ERR *)0) {
;;;361    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN > 0u))
;;;362            TRACE_OS_MUTEX_PEND_FAILED(p_mutex);                /* Record the event.                                      */
;;;363    #endif
;;;364            OS_SAFETY_CRITICAL_EXCEPTION();
;;;365            return;
;;;366        }
;;;367    #endif
;;;368    
;;;369    #if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
;;;370        if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* Not allowed to call from an ISR                        */
;;;371    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN > 0u))
;;;372            TRACE_OS_MUTEX_PEND_FAILED(p_mutex);                /* Record the event.                                      */
;;;373    #endif
;;;374           *p_err = OS_ERR_PEND_ISR;
;;;375            return;
;;;376        }
;;;377    #endif
;;;378    
;;;379    #if OS_CFG_ARG_CHK_EN > 0u
;;;380        if (p_mutex == (OS_MUTEX *)0) {                         /* Validate arguments                                     */
000014  b92d              CBNZ     r5,|L3.34|
;;;381    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN > 0u))
;;;382            TRACE_OS_MUTEX_PEND_FAILED(p_mutex);                /* Record the event.                                      */
;;;383    #endif
;;;384           *p_err = OS_ERR_OBJ_PTR_NULL;
000016  f64550c3          MOV      r0,#0x5dc3
00001a  8030              STRH     r0,[r6,#0]
                  |L3.28|
;;;385            return;
;;;386        }
;;;387        switch (opt) {                                          /* Validate 'opt'                                         */
;;;388            case OS_OPT_PEND_BLOCKING:
;;;389            case OS_OPT_PEND_NON_BLOCKING:
;;;390                 break;
;;;391    
;;;392            default:
;;;393    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN > 0u))
;;;394                 TRACE_OS_MUTEX_PEND_FAILED(p_mutex);           /* Record the event.                                      */
;;;395    #endif
;;;396                *p_err = OS_ERR_OPT_INVALID;
;;;397                 return;
;;;398        }
;;;399    #endif
;;;400    
;;;401    #if OS_CFG_OBJ_TYPE_CHK_EN > 0u
;;;402        if (p_mutex->Type != OS_OBJ_TYPE_MUTEX) {               /* Make sure mutex was created                            */
;;;403    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN > 0u))
;;;404            TRACE_OS_MUTEX_PEND_FAILED(p_mutex);                /* Record the event.                                      */
;;;405    #endif
;;;406           *p_err = OS_ERR_OBJ_TYPE;
;;;407            return;
;;;408        }
;;;409    #endif
;;;410    
;;;411        if (p_ts != (CPU_TS *)0) {
;;;412           *p_ts  = (CPU_TS  )0;                                /* Initialize the returned timestamp                      */
;;;413        }
;;;414    
;;;415        CPU_CRITICAL_ENTER();
;;;416        if (p_mutex->OwnerNestingCtr == (OS_NESTING_CTR)0) {    /* Resource available?                                    */
;;;417            p_mutex->OwnerTCBPtr       =  OSTCBCurPtr;          /* Yes, caller may proceed                                */
;;;418            p_mutex->OwnerNestingCtr   = (OS_NESTING_CTR)1;
;;;419            if (p_ts != (CPU_TS *)0) {
;;;420               *p_ts  = p_mutex->TS;
;;;421            }
;;;422            OS_MutexGrpAdd(OSTCBCurPtr, p_mutex);               /* Add mutex to owner's group                             */
;;;423            CPU_CRITICAL_EXIT();
;;;424    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN > 0u))
;;;425            TRACE_OS_MUTEX_PEND(p_mutex);                       /* Record the event.                                      */
;;;426    #endif
;;;427           *p_err = OS_ERR_NONE;
;;;428            return;
;;;429        }
;;;430    
;;;431        if (OSTCBCurPtr == p_mutex->OwnerTCBPtr) {              /* See if current task is already the owner of the mutex  */
;;;432            p_mutex->OwnerNestingCtr++;
;;;433            if (p_ts != (CPU_TS *)0) {
;;;434               *p_ts  = p_mutex->TS;
;;;435            }
;;;436            CPU_CRITICAL_EXIT();
;;;437    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN > 0u))
;;;438            TRACE_OS_MUTEX_PEND_FAILED(p_mutex);                /* Record the event.                                      */
;;;439    #endif
;;;440           *p_err = OS_ERR_MUTEX_OWNER;                         /* Indicate that current task already owns the mutex      */
;;;441            return;
;;;442        }
;;;443    
;;;444        if ((opt & OS_OPT_PEND_NON_BLOCKING) != (OS_OPT)0) {    /* Caller wants to block if not available?                */
;;;445            CPU_CRITICAL_EXIT();
;;;446    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN > 0u))
;;;447            TRACE_OS_MUTEX_PEND_FAILED(p_mutex);                /* Record the event.                                      */
;;;448    #endif
;;;449           *p_err = OS_ERR_PEND_WOULD_BLOCK;                    /* No                                                     */
;;;450            return;
;;;451        } else {
;;;452            if (OSSchedLockNestingCtr > (OS_NESTING_CTR)0) {    /* Can't pend when the scheduler is locked                */
;;;453                CPU_CRITICAL_EXIT();
;;;454    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN > 0u))
;;;455                TRACE_OS_MUTEX_PEND_FAILED(p_mutex);            /* Record the event.                                      */
;;;456    #endif
;;;457               *p_err = OS_ERR_SCHED_LOCKED;
;;;458                return;
;;;459            }
;;;460        }
;;;461                                                                /* Lock the scheduler/re-enable interrupts                */
;;;462        OS_CRITICAL_ENTER_CPU_EXIT();
;;;463        p_tcb = p_mutex->OwnerTCBPtr;                           /* Point to the TCB of the Mutex owner                    */
;;;464        if (p_tcb->Prio > OSTCBCurPtr->Prio) {                  /* See if mutex owner has a lower priority than current   */
;;;465            OS_TaskChangePrio(p_tcb, OSTCBCurPtr->Prio);
;;;466    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN > 0u))
;;;467                     TRACE_OS_MUTEX_TASK_PRIO_INHERIT(p_tcb, p_tcb->Prio);
;;;468    #endif
;;;469        }
;;;470    
;;;471        OS_Pend(&pend_data,                                     /* Block task pending on Mutex                            */
;;;472                (OS_PEND_OBJ *)((void *)p_mutex),
;;;473                 OS_TASK_PEND_ON_MUTEX,
;;;474                 timeout);
;;;475    
;;;476        OS_CRITICAL_EXIT_NO_SCHED();
;;;477    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN > 0u))
;;;478        TRACE_OS_MUTEX_PEND_BLOCK(p_mutex);                     /* Record the event.                                      */
;;;479    #endif
;;;480        OSSched();                                              /* Find the next highest priority task ready to run       */
;;;481    
;;;482        CPU_CRITICAL_ENTER();
;;;483        switch (OSTCBCurPtr->PendStatus) {
;;;484            case OS_STATUS_PEND_OK:                             /* We got the mutex                                       */
;;;485                 if (p_ts != (CPU_TS *)0) {
;;;486                    *p_ts  = OSTCBCurPtr->TS;
;;;487                 }
;;;488    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN > 0u))
;;;489                 TRACE_OS_MUTEX_PEND(p_mutex);                  /* Record the event.                                      */
;;;490    #endif
;;;491                *p_err = OS_ERR_NONE;
;;;492                 break;
;;;493    
;;;494            case OS_STATUS_PEND_ABORT:                          /* Indicate that we aborted                               */
;;;495                 if (p_ts != (CPU_TS *)0) {
;;;496                    *p_ts  = OSTCBCurPtr->TS;
;;;497                 }
;;;498    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN > 0u))
;;;499                 TRACE_OS_MUTEX_PEND_FAILED(p_mutex);           /* Record the event.                                      */
;;;500    #endif
;;;501                *p_err = OS_ERR_PEND_ABORT;
;;;502                 break;
;;;503    
;;;504            case OS_STATUS_PEND_TIMEOUT:                        /* Indicate that we didn't get mutex within timeout       */
;;;505                 if (p_ts != (CPU_TS *)0) {
;;;506                    *p_ts  = (CPU_TS  )0;
;;;507                 }
;;;508    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN > 0u))
;;;509                 TRACE_OS_MUTEX_PEND_FAILED(p_mutex);           /* Record the event.                                      */
;;;510    #endif
;;;511                *p_err = OS_ERR_TIMEOUT;
;;;512                 break;
;;;513    
;;;514            case OS_STATUS_PEND_DEL:                            /* Indicate that object pended on has been deleted        */
;;;515                 if (p_ts != (CPU_TS *)0) {
;;;516                    *p_ts  = OSTCBCurPtr->TS;
;;;517                 }
;;;518    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN > 0u))
;;;519                 TRACE_OS_MUTEX_PEND_FAILED(p_mutex);           /* Record the event.                                      */
;;;520    #endif
;;;521                *p_err = OS_ERR_OBJ_DEL;
;;;522                 break;
;;;523    
;;;524            default:
;;;525    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN > 0u))
;;;526                 TRACE_OS_MUTEX_PEND_FAILED(p_mutex);           /* Record the event.                                      */
;;;527    #endif
;;;528                *p_err = OS_ERR_STATUS_INVALID;
;;;529                 break;
;;;530        }
;;;531        CPU_CRITICAL_EXIT();
;;;532    }
00001c  b008              ADD      sp,sp,#0x20
00001e  e8bd87f0          POP      {r4-r10,pc}
                  |L3.34|
000022  b11f              CBZ      r7,|L3.44|
000024  f5b74f00          CMP      r7,#0x8000            ;387
000028  d102              BNE      |L3.48|
00002a  e000              B        |L3.46|
                  |L3.44|
00002c  bf00              NOP                            ;389
                  |L3.46|
00002e  e003              B        |L3.56|
                  |L3.48|
000030  f6456025          MOV      r0,#0x5e25            ;396
000034  8030              STRH     r0,[r6,#0]            ;396
000036  e7f1              B        |L3.28|
                  |L3.56|
000038  bf00              NOP                            ;390
00003a  4962              LDR      r1,|L3.452|
00003c  6828              LDR      r0,[r5,#0]            ;402
00003e  4288              CMP      r0,r1                 ;402
000040  d003              BEQ      |L3.74|
000042  f64550c4          MOV      r0,#0x5dc4            ;406
000046  8030              STRH     r0,[r6,#0]            ;406
000048  e7e8              B        |L3.28|
                  |L3.74|
00004a  b10c              CBZ      r4,|L3.80|
00004c  2000              MOVS     r0,#0                 ;412
00004e  6020              STR      r0,[r4,#0]            ;412
                  |L3.80|
000050  bf00              NOP                            ;415
000052  bf00              NOP                            ;415
000054  f7fffffe          BL       CPU_SR_Save
000058  4682              MOV      r10,r0                ;415
00005a  bf00              NOP                            ;415
00005c  bf00              NOP                            ;415
00005e  f8950028          LDRB     r0,[r5,#0x28]         ;416
000062  b9b8              CBNZ     r0,|L3.148|
000064  4858              LDR      r0,|L3.456|
000066  6800              LDR      r0,[r0,#0]            ;417  ; OSTCBCurPtr
000068  6268              STR      r0,[r5,#0x24]         ;417
00006a  2001              MOVS     r0,#1                 ;418
00006c  f8850028          STRB     r0,[r5,#0x28]         ;418
000070  b10c              CBZ      r4,|L3.118|
000072  6ae8              LDR      r0,[r5,#0x2c]         ;420
000074  6020              STR      r0,[r4,#0]            ;420
                  |L3.118|
000076  4629              MOV      r1,r5                 ;422
000078  4853              LDR      r0,|L3.456|
00007a  6800              LDR      r0,[r0,#0]            ;422  ; OSTCBCurPtr
00007c  f7fffffe          BL       OS_MutexGrpAdd
000080  bf00              NOP                            ;423
000082  bf00              NOP                            ;423
000084  4650              MOV      r0,r10                ;423
000086  f7fffffe          BL       CPU_SR_Restore
00008a  bf00              NOP                            ;423
00008c  bf00              NOP                            ;423
00008e  2000              MOVS     r0,#0                 ;427
000090  8030              STRH     r0,[r6,#0]            ;427
000092  e7c3              B        |L3.28|
                  |L3.148|
000094  494c              LDR      r1,|L3.456|
000096  6a68              LDR      r0,[r5,#0x24]         ;431
000098  6809              LDR      r1,[r1,#0]            ;431  ; OSTCBCurPtr
00009a  4288              CMP      r0,r1                 ;431
00009c  d112              BNE      |L3.196|
00009e  f8950028          LDRB     r0,[r5,#0x28]         ;432
0000a2  1c40              ADDS     r0,r0,#1              ;432
0000a4  f8850028          STRB     r0,[r5,#0x28]         ;432
0000a8  b10c              CBZ      r4,|L3.174|
0000aa  6ae8              LDR      r0,[r5,#0x2c]         ;434
0000ac  6020              STR      r0,[r4,#0]            ;434
                  |L3.174|
0000ae  bf00              NOP                            ;436
0000b0  bf00              NOP                            ;436
0000b2  4650              MOV      r0,r10                ;436
0000b4  f7fffffe          BL       CPU_SR_Restore
0000b8  bf00              NOP                            ;436
0000ba  bf00              NOP                            ;436
0000bc  f2457082          MOV      r0,#0x5782            ;440
0000c0  8030              STRH     r0,[r6,#0]            ;440
0000c2  e7ab              B        |L3.28|
                  |L3.196|
0000c4  f4074000          AND      r0,r7,#0x8000         ;444
0000c8  b150              CBZ      r0,|L3.224|
0000ca  bf00              NOP                            ;445
0000cc  bf00              NOP                            ;445
0000ce  4650              MOV      r0,r10                ;445
0000d0  f7fffffe          BL       CPU_SR_Restore
0000d4  bf00              NOP                            ;445
0000d6  bf00              NOP                            ;445
0000d8  f24610b0          MOV      r0,#0x61b0            ;449
0000dc  8030              STRH     r0,[r6,#0]            ;449
0000de  e79d              B        |L3.28|
                  |L3.224|
0000e0  483a              LDR      r0,|L3.460|
0000e2  7800              LDRB     r0,[r0,#0]            ;452  ; OSSchedLockNestingCtr
0000e4  2800              CMP      r0,#0                 ;452
0000e6  dd0a              BLE      |L3.254|
0000e8  bf00              NOP                            ;453
0000ea  bf00              NOP                            ;453
0000ec  4650              MOV      r0,r10                ;453
0000ee  f7fffffe          BL       CPU_SR_Restore
0000f2  bf00              NOP                            ;453
0000f4  bf00              NOP                            ;453
0000f6  f6465063          MOV      r0,#0x6d63            ;457
0000fa  8030              STRH     r0,[r6,#0]            ;457
0000fc  e78e              B        |L3.28|
                  |L3.254|
0000fe  f8d58024          LDR      r8,[r5,#0x24]         ;463
000102  f8980037          LDRB     r0,[r8,#0x37]         ;464
000106  4930              LDR      r1,|L3.456|
000108  6809              LDR      r1,[r1,#0]            ;464  ; OSTCBCurPtr
00010a  f8911037          LDRB     r1,[r1,#0x37]         ;464
00010e  4288              CMP      r0,r1                 ;464
000110  dd06              BLE      |L3.288|
000112  482d              LDR      r0,|L3.456|
000114  6800              LDR      r0,[r0,#0]            ;465  ; OSTCBCurPtr
000116  f8901037          LDRB     r1,[r0,#0x37]         ;465
00011a  4640              MOV      r0,r8                 ;465
00011c  f7fffffe          BL       OS_TaskChangePrio
                  |L3.288|
000120  464b              MOV      r3,r9                 ;471
000122  2204              MOVS     r2,#4                 ;471
000124  4629              MOV      r1,r5                 ;471
000126  4668              MOV      r0,sp                 ;471
000128  f7fffffe          BL       OS_Pend
00012c  bf00              NOP                            ;476
00012e  bf00              NOP                            ;476
000130  4650              MOV      r0,r10                ;476
000132  f7fffffe          BL       CPU_SR_Restore
000136  bf00              NOP                            ;476
000138  bf00              NOP                            ;476
00013a  f7fffffe          BL       OSSched
00013e  bf00              NOP                            ;482
000140  bf00              NOP                            ;482
000142  f7fffffe          BL       CPU_SR_Save
000146  4682              MOV      r10,r0                ;482
000148  bf00              NOP                            ;482
00014a  bf00              NOP                            ;482
00014c  481e              LDR      r0,|L3.456|
00014e  6800              LDR      r0,[r0,#0]            ;483  ; OSTCBCurPtr
000150  f8900035          LDRB     r0,[r0,#0x35]         ;483
000154  b130              CBZ      r0,|L3.356|
000156  2801              CMP      r0,#1                 ;483
000158  d00c              BEQ      |L3.372|
00015a  2802              CMP      r0,#2                 ;483
00015c  d01a              BEQ      |L3.404|
00015e  2803              CMP      r0,#3                 ;483
000160  d121              BNE      |L3.422|
000162  e010              B        |L3.390|
                  |L3.356|
000164  b11c              CBZ      r4,|L3.366|
000166  4818              LDR      r0,|L3.456|
000168  6800              LDR      r0,[r0,#0]            ;486  ; OSTCBCurPtr
00016a  6c80              LDR      r0,[r0,#0x48]         ;486
00016c  6020              STR      r0,[r4,#0]            ;486
                  |L3.366|
00016e  2000              MOVS     r0,#0                 ;491
000170  8030              STRH     r0,[r6,#0]            ;491
000172  e01c              B        |L3.430|
                  |L3.372|
000174  b11c              CBZ      r4,|L3.382|
000176  4814              LDR      r0,|L3.456|
000178  6800              LDR      r0,[r0,#0]            ;496  ; OSTCBCurPtr
00017a  6c80              LDR      r0,[r0,#0x48]         ;496
00017c  6020              STR      r0,[r4,#0]            ;496
                  |L3.382|
00017e  f24610a9          MOV      r0,#0x61a9            ;501
000182  8030              STRH     r0,[r6,#0]            ;501
000184  e013              B        |L3.430|
                  |L3.390|
000186  b10c              CBZ      r4,|L3.396|
000188  2000              MOVS     r0,#0                 ;506
00018a  6020              STR      r0,[r4,#0]            ;506
                  |L3.396|
00018c  f24720d9          MOV      r0,#0x72d9            ;511
000190  8030              STRH     r0,[r6,#0]            ;511
000192  e00c              B        |L3.430|
                  |L3.404|
000194  b11c              CBZ      r4,|L3.414|
000196  480c              LDR      r0,|L3.456|
000198  6800              LDR      r0,[r0,#0]            ;516  ; OSTCBCurPtr
00019a  6c80              LDR      r0,[r0,#0x48]         ;516
00019c  6020              STR      r0,[r4,#0]            ;516
                  |L3.414|
00019e  f64550c2          MOV      r0,#0x5dc2            ;521
0001a2  8030              STRH     r0,[r6,#0]            ;521
0001a4  e003              B        |L3.430|
                  |L3.422|
0001a6  f646602e          MOV      r0,#0x6e2e            ;528
0001aa  8030              STRH     r0,[r6,#0]            ;528
0001ac  bf00              NOP                            ;529
                  |L3.430|
0001ae  bf00              NOP                            ;492
0001b0  bf00              NOP                            ;531
0001b2  bf00              NOP                            ;531
0001b4  4650              MOV      r0,r10                ;531
0001b6  f7fffffe          BL       CPU_SR_Restore
0001ba  bf00              NOP                            ;531
0001bc  bf00              NOP                            ;531
0001be  bf00              NOP      
0001c0  e72c              B        |L3.28|
;;;533    
                          ENDP

0001c2  0000              DCW      0x0000
                  |L3.452|
                          DCD      0x5854554d
                  |L3.456|
                          DCD      OSTCBCurPtr
                  |L3.460|
                          DCD      OSSchedLockNestingCtr

                          AREA ||i.OSMutexPendAbort||, CODE, READONLY, ALIGN=2

                  OSMutexPendAbort PROC
;;;566    #if OS_CFG_MUTEX_PEND_ABORT_EN > 0u
;;;567    OS_OBJ_QTY  OSMutexPendAbort (OS_MUTEX  *p_mutex,
000000  e92d5ffc          PUSH     {r2-r12,lr}
;;;568                                  OS_OPT     opt,
;;;569                                  OS_ERR    *p_err)
;;;570    {
000004  4606              MOV      r6,r0
000006  460f              MOV      r7,r1
000008  4615              MOV      r5,r2
;;;571        OS_PEND_LIST  *p_pend_list;
;;;572        OS_TCB        *p_tcb;
;;;573        OS_TCB        *p_tcb_owner;
;;;574        CPU_TS         ts;
;;;575        OS_OBJ_QTY     nbr_tasks;
;;;576        OS_PRIO        prio_new;
;;;577        CPU_SR_ALLOC();
00000a  2000              MOVS     r0,#0
00000c  9000              STR      r0,[sp,#0]
;;;578    
;;;579    
;;;580    
;;;581    #ifdef OS_SAFETY_CRITICAL
;;;582        if (p_err == (OS_ERR *)0) {
;;;583            OS_SAFETY_CRITICAL_EXCEPTION();
;;;584            return ((OS_OBJ_QTY)0u);
;;;585        }
;;;586    #endif
;;;587    
;;;588    #if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
;;;589        if (OSIntNestingCtr > (OS_NESTING_CTR)0u) {                 /* Not allowed to Pend Abort from an ISR                */
;;;590           *p_err =  OS_ERR_PEND_ABORT_ISR;
;;;591            return ((OS_OBJ_QTY)0u);
;;;592        }
;;;593    #endif
;;;594    
;;;595    #if OS_CFG_ARG_CHK_EN > 0u
;;;596        if (p_mutex == (OS_MUTEX *)0) {                             /* Validate 'p_mutex'                                   */
00000e  b92e              CBNZ     r6,|L4.28|
;;;597           *p_err =  OS_ERR_OBJ_PTR_NULL;
000010  f64550c3          MOV      r0,#0x5dc3
000014  8028              STRH     r0,[r5,#0]
;;;598            return ((OS_OBJ_QTY)0u);
000016  2000              MOVS     r0,#0
                  |L4.24|
;;;599        }
;;;600        switch (opt) {                                              /* Validate 'opt'                                       */
;;;601            case OS_OPT_PEND_ABORT_1:
;;;602            case OS_OPT_PEND_ABORT_ALL:
;;;603            case OS_OPT_PEND_ABORT_1   | OS_OPT_POST_NO_SCHED:
;;;604            case OS_OPT_PEND_ABORT_ALL | OS_OPT_POST_NO_SCHED:
;;;605                 break;
;;;606    
;;;607            default:
;;;608                *p_err =  OS_ERR_OPT_INVALID;
;;;609                 return ((OS_OBJ_QTY)0u);
;;;610        }
;;;611    #endif
;;;612    
;;;613    #if OS_CFG_OBJ_TYPE_CHK_EN > 0u
;;;614        if (p_mutex->Type != OS_OBJ_TYPE_MUTEX) {                   /* Make sure mutex was created                          */
;;;615           *p_err =  OS_ERR_OBJ_TYPE;
;;;616            return ((OS_OBJ_QTY)0u);
;;;617        }
;;;618    #endif
;;;619    
;;;620        CPU_CRITICAL_ENTER();
;;;621        p_pend_list = &p_mutex->PendList;
;;;622        if (p_pend_list->NbrEntries == (OS_OBJ_QTY)0u) {            /* Any task waiting on mutex?                           */
;;;623            CPU_CRITICAL_EXIT();                                    /* No                                                   */
;;;624           *p_err =  OS_ERR_PEND_ABORT_NONE;
;;;625            return ((OS_OBJ_QTY)0u);
;;;626        }
;;;627    
;;;628        OS_CRITICAL_ENTER_CPU_EXIT();
;;;629        nbr_tasks = 0u;
;;;630        ts        = OS_TS_GET();                                    /* Get local time stamp so all tasks get the same time  */
;;;631        while (p_pend_list->NbrEntries > (OS_OBJ_QTY)0u) {
;;;632            p_tcb = p_pend_list->HeadPtr->TCBPtr;
;;;633    
;;;634            OS_PendAbort((OS_PEND_OBJ *)((void *)p_mutex),
;;;635                         p_tcb,
;;;636                         ts);
;;;637    
;;;638            p_tcb_owner = p_mutex->OwnerTCBPtr;
;;;639            prio_new    = p_tcb_owner->Prio;
;;;640            if ((p_tcb_owner->Prio != p_tcb_owner->BasePrio) &&
;;;641                (p_tcb_owner->Prio == p_tcb->Prio)) {               /* Has the owner inherited a priority?                  */
;;;642                prio_new = OS_MutexGrpPrioFindHighest(p_tcb_owner);
;;;643                prio_new = prio_new > p_tcb_owner->BasePrio ? p_tcb_owner->BasePrio : prio_new;
;;;644            }
;;;645    
;;;646            if(prio_new != p_tcb_owner->Prio) {
;;;647                OS_TaskChangePrio(p_tcb_owner, prio_new);
;;;648    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN > 0u))
;;;649                              TRACE_OS_MUTEX_TASK_PRIO_DISINHERIT(p_tcb_owner, p_tcb_owner->Prio);
;;;650    #endif
;;;651            }
;;;652    
;;;653            nbr_tasks++;
;;;654            if (opt != OS_OPT_PEND_ABORT_ALL) {                     /* Pend abort all tasks waiting?                        */
;;;655                break;                                              /* No                                                   */
;;;656            }
;;;657        }
;;;658        OS_CRITICAL_EXIT_NO_SCHED();
;;;659    
;;;660        if ((opt & OS_OPT_POST_NO_SCHED) == (OS_OPT)0u) {
;;;661            OSSched();                                              /* Run the scheduler                                    */
;;;662        }
;;;663    
;;;664       *p_err = OS_ERR_NONE;
;;;665        return (nbr_tasks);
;;;666    }
000018  e8bd9ffc          POP      {r2-r12,pc}
                  |L4.28|
00001c  b14f              CBZ      r7,|L4.50|
00001e  f5b77f80          CMP      r7,#0x100             ;600
000022  d007              BEQ      |L4.52|
000024  f5b74f00          CMP      r7,#0x8000            ;600
000028  d005              BEQ      |L4.54|
00002a  f5b74f01          CMP      r7,#0x8100            ;600
00002e  d104              BNE      |L4.58|
000030  e002              B        |L4.56|
                  |L4.50|
000032  bf00              NOP                            ;602
                  |L4.52|
000034  bf00              NOP                            ;603
                  |L4.54|
000036  bf00              NOP                            ;604
                  |L4.56|
000038  e004              B        |L4.68|
                  |L4.58|
00003a  f6456025          MOV      r0,#0x5e25            ;608
00003e  8028              STRH     r0,[r5,#0]            ;608
000040  2000              MOVS     r0,#0                 ;609
000042  e7e9              B        |L4.24|
                  |L4.68|
000044  bf00              NOP                            ;605
000046  4938              LDR      r1,|L4.296|
000048  6830              LDR      r0,[r6,#0]            ;614
00004a  4288              CMP      r0,r1                 ;614
00004c  d004              BEQ      |L4.88|
00004e  f64550c4          MOV      r0,#0x5dc4            ;615
000052  8028              STRH     r0,[r5,#0]            ;615
000054  2000              MOVS     r0,#0                 ;616
000056  e7df              B        |L4.24|
                  |L4.88|
000058  bf00              NOP                            ;620
00005a  bf00              NOP                            ;620
00005c  f7fffffe          BL       CPU_SR_Save
000060  9000              STR      r0,[sp,#0]            ;620
000062  bf00              NOP                            ;620
000064  bf00              NOP                            ;620
000066  f1060808          ADD      r8,r6,#8              ;621
00006a  f8b80008          LDRH     r0,[r8,#8]            ;622
00006e  b958              CBNZ     r0,|L4.136|
000070  bf00              NOP                            ;623
000072  bf00              NOP                            ;623
000074  9800              LDR      r0,[sp,#0]            ;623
000076  f7fffffe          BL       CPU_SR_Restore
00007a  bf00              NOP                            ;623
00007c  bf00              NOP                            ;623
00007e  f24610ab          MOV      r0,#0x61ab            ;624
000082  8028              STRH     r0,[r5,#0]            ;624
000084  2000              MOVS     r0,#0                 ;625
000086  e7c7              B        |L4.24|
                  |L4.136|
000088  f04f0a00          MOV      r10,#0                ;629
00008c  f7fffffe          BL       CPU_TS_TmrRd
000090  9001              STR      r0,[sp,#4]            ;630
000092  e033              B        |L4.252|
                  |L4.148|
000094  f8d80000          LDR      r0,[r8,#0]            ;632
000098  f8d09008          LDR      r9,[r0,#8]            ;632
00009c  4649              MOV      r1,r9                 ;634
00009e  4630              MOV      r0,r6                 ;634
0000a0  9a01              LDR      r2,[sp,#4]            ;634
0000a2  f7fffffe          BL       OS_PendAbort
0000a6  6a74              LDR      r4,[r6,#0x24]         ;638
0000a8  f814bf37          LDRB     r11,[r4,#0x37]!       ;639
0000ac  7820              LDRB     r0,[r4,#0]            ;640
0000ae  7861              LDRB     r1,[r4,#1]            ;640
0000b0  3c37              SUBS     r4,r4,#0x37           ;640
0000b2  4288              CMP      r0,r1                 ;640
0000b4  d012              BEQ      |L4.220|
0000b6  f8940037          LDRB     r0,[r4,#0x37]         ;641
0000ba  f8991037          LDRB     r1,[r9,#0x37]         ;641
0000be  4288              CMP      r0,r1                 ;641
0000c0  d10c              BNE      |L4.220|
0000c2  4620              MOV      r0,r4                 ;642
0000c4  f7fffffe          BL       OS_MutexGrpPrioFindHighest
0000c8  4683              MOV      r11,r0                ;642
0000ca  f8940038          LDRB     r0,[r4,#0x38]         ;643
0000ce  4558              CMP      r0,r11                ;643
0000d0  da02              BGE      |L4.216|
0000d2  f8940038          LDRB     r0,[r4,#0x38]         ;643
0000d6  e000              B        |L4.218|
                  |L4.216|
0000d8  4658              MOV      r0,r11                ;643
                  |L4.218|
0000da  4683              MOV      r11,r0                ;643
                  |L4.220|
0000dc  f8940037          LDRB     r0,[r4,#0x37]         ;646
0000e0  4558              CMP      r0,r11                ;646
0000e2  d003              BEQ      |L4.236|
0000e4  4659              MOV      r1,r11                ;647
0000e6  4620              MOV      r0,r4                 ;647
0000e8  f7fffffe          BL       OS_TaskChangePrio
                  |L4.236|
0000ec  f10a0001          ADD      r0,r10,#1             ;653
0000f0  fa1ffa80          UXTH     r10,r0                ;653
0000f4  f5b77f80          CMP      r7,#0x100             ;654
0000f8  d000              BEQ      |L4.252|
0000fa  e003              B        |L4.260|
                  |L4.252|
0000fc  f8b80008          LDRH     r0,[r8,#8]            ;631
000100  2800              CMP      r0,#0                 ;631
000102  dcc7              BGT      |L4.148|
                  |L4.260|
000104  bf00              NOP                            ;655
000106  bf00              NOP                            ;658
000108  bf00              NOP                            ;658
00010a  9800              LDR      r0,[sp,#0]            ;658
00010c  f7fffffe          BL       CPU_SR_Restore
000110  bf00              NOP                            ;658
000112  bf00              NOP                            ;658
000114  f4074000          AND      r0,r7,#0x8000         ;660
000118  b908              CBNZ     r0,|L4.286|
00011a  f7fffffe          BL       OSSched
                  |L4.286|
00011e  2000              MOVS     r0,#0                 ;664
000120  8028              STRH     r0,[r5,#0]            ;664
000122  4650              MOV      r0,r10                ;665
000124  e778              B        |L4.24|
;;;667    #endif
                          ENDP

000126  0000              DCW      0x0000
                  |L4.296|
                          DCD      0x5854554d

                          AREA ||i.OSMutexPost||, CODE, READONLY, ALIGN=2

                  OSMutexPost PROC
;;;695    
;;;696    void  OSMutexPost (OS_MUTEX  *p_mutex,
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;697                       OS_OPT     opt,
;;;698                       OS_ERR    *p_err)
;;;699    {
000004  4604              MOV      r4,r0
000006  4689              MOV      r9,r1
000008  4615              MOV      r5,r2
;;;700        OS_PEND_LIST  *p_pend_list;
;;;701        OS_TCB        *p_tcb;
;;;702        CPU_TS         ts;
;;;703        OS_PRIO        prio_new;
;;;704        CPU_SR_ALLOC();
00000a  f04f0b00          MOV      r11,#0
;;;705    
;;;706    
;;;707    
;;;708    #ifdef OS_SAFETY_CRITICAL
;;;709        if (p_err == (OS_ERR *)0) {
;;;710    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN > 0u))
;;;711            TRACE_OS_MUTEX_POST_FAILED(p_mutex);                /* Record the event.                                      */
;;;712    #endif
;;;713            OS_SAFETY_CRITICAL_EXCEPTION();
;;;714            return;
;;;715        }
;;;716    #endif
;;;717    
;;;718    #if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
;;;719        if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* Not allowed to call from an ISR                        */
;;;720    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN > 0u))
;;;721            TRACE_OS_MUTEX_POST_FAILED(p_mutex);                /* Record the event.                                      */
;;;722    #endif
;;;723           *p_err = OS_ERR_POST_ISR;
;;;724            return;
;;;725        }
;;;726    #endif
;;;727    
;;;728    #if OS_CFG_ARG_CHK_EN > 0u
;;;729        if (p_mutex == (OS_MUTEX *)0) {                         /* Validate 'p_mutex'                                     */
00000e  b924              CBNZ     r4,|L5.26|
;;;730    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN > 0u))
;;;731            TRACE_OS_MUTEX_POST_FAILED(p_mutex);                /* Record the event.                                      */
;;;732    #endif
;;;733           *p_err = OS_ERR_OBJ_PTR_NULL;
000010  f64550c3          MOV      r0,#0x5dc3
000014  8028              STRH     r0,[r5,#0]
                  |L5.22|
;;;734            return;
;;;735        }
;;;736        switch (opt) {                                          /* Validate 'opt'                                         */
;;;737            case OS_OPT_POST_NONE:
;;;738            case OS_OPT_POST_NO_SCHED:
;;;739                 break;
;;;740    
;;;741            default:
;;;742    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN > 0u))
;;;743                 TRACE_OS_MUTEX_POST_FAILED(p_mutex);           /* Record the event.                                      */
;;;744    #endif
;;;745                *p_err =  OS_ERR_OPT_INVALID;
;;;746                 return;
;;;747        }
;;;748    #endif
;;;749    
;;;750    #if OS_CFG_OBJ_TYPE_CHK_EN > 0u
;;;751        if (p_mutex->Type != OS_OBJ_TYPE_MUTEX) {               /* Make sure mutex was created                            */
;;;752    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN > 0u))
;;;753            TRACE_OS_MUTEX_POST_FAILED(p_mutex);                /* Record the event.                                      */
;;;754    #endif
;;;755           *p_err = OS_ERR_OBJ_TYPE;
;;;756            return;
;;;757        }
;;;758    #endif
;;;759    
;;;760        CPU_CRITICAL_ENTER();
;;;761        if (OSTCBCurPtr != p_mutex->OwnerTCBPtr) {              /* Make sure the mutex owner is releasing the mutex       */
;;;762            CPU_CRITICAL_EXIT();
;;;763    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN > 0u))
;;;764            TRACE_OS_MUTEX_POST_FAILED(p_mutex);                /* Record the event.                                      */
;;;765    #endif
;;;766           *p_err = OS_ERR_MUTEX_NOT_OWNER;
;;;767            return;
;;;768        }
;;;769    
;;;770    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN > 0u))
;;;771        TRACE_OS_MUTEX_POST(p_mutex);                           /* Record the event.                                      */
;;;772    #endif
;;;773    
;;;774        OS_CRITICAL_ENTER_CPU_EXIT();
;;;775        ts          = OS_TS_GET();                              /* Get timestamp                                          */
;;;776        p_mutex->TS = ts;
;;;777        p_mutex->OwnerNestingCtr--;                             /* Decrement owner's nesting counter                      */
;;;778        if (p_mutex->OwnerNestingCtr > (OS_NESTING_CTR)0) {     /* Are we done with all nestings?                         */
;;;779            OS_CRITICAL_EXIT();                                 /* No                                                     */
;;;780           *p_err = OS_ERR_MUTEX_NESTING;
;;;781            return;
;;;782        }
;;;783    
;;;784        OS_MutexGrpRemove(OSTCBCurPtr, p_mutex);                /* Remove mutex from owner's group                        */
;;;785    
;;;786        p_pend_list = &p_mutex->PendList;
;;;787        if (p_pend_list->NbrEntries == (OS_OBJ_QTY)0) {         /* Any task waiting on mutex?                             */
;;;788            p_mutex->OwnerTCBPtr     = (OS_TCB       *)0;       /* No                                                     */
;;;789            p_mutex->OwnerNestingCtr = (OS_NESTING_CTR)0;
;;;790            OS_CRITICAL_EXIT();
;;;791           *p_err = OS_ERR_NONE;
;;;792            return;
;;;793        }
;;;794                                                                /* Yes                                                    */
;;;795        if (OSTCBCurPtr->Prio != OSTCBCurPtr->BasePrio) {       /* Has owner inherited a priority?                        */
;;;796            prio_new = OS_MutexGrpPrioFindHighest(OSTCBCurPtr); /* Yes, find highest priority pending                     */
;;;797            prio_new = prio_new > OSTCBCurPtr->BasePrio ? OSTCBCurPtr->BasePrio : prio_new;
;;;798            if (prio_new > OSTCBCurPtr->Prio) {
;;;799                OS_RdyListRemove(OSTCBCurPtr);
;;;800                OSTCBCurPtr->Prio = prio_new;                   /* Lower owner's priority back to its original one        */
;;;801    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN > 0u))
;;;802                TRACE_OS_MUTEX_TASK_PRIO_DISINHERIT(OSTCBCurPtr, prio_new);
;;;803    #endif
;;;804                OS_PrioInsert(prio_new);
;;;805                OS_RdyListInsertTail(OSTCBCurPtr);              /* Insert owner in ready list at new priority             */
;;;806                OSPrioCur         = prio_new;
;;;807            }
;;;808        }
;;;809                                                                /* Get TCB from head of pend list                         */
;;;810        p_tcb                      = p_pend_list->HeadPtr->TCBPtr;
;;;811        p_mutex->OwnerTCBPtr       = p_tcb;                     /* Give mutex to new owner                                */
;;;812        p_mutex->OwnerNestingCtr   = (OS_NESTING_CTR)1;
;;;813        OS_MutexGrpAdd(p_tcb, p_mutex);
;;;814                                                                /* Post to mutex                                          */
;;;815        OS_Post((OS_PEND_OBJ *)((void *)p_mutex),
;;;816                (OS_TCB      *)p_tcb,
;;;817                (void        *)0,
;;;818                (OS_MSG_SIZE  )0,
;;;819                (CPU_TS       )ts);
;;;820    
;;;821        OS_CRITICAL_EXIT_NO_SCHED();
;;;822    
;;;823        if ((opt & OS_OPT_POST_NO_SCHED) == (OS_OPT)0) {
;;;824            OSSched();                                          /* Run the scheduler                                      */
;;;825        }
;;;826    
;;;827       *p_err = OS_ERR_NONE;
;;;828    }
000016  e8bd8ff8          POP      {r3-r11,pc}
                  |L5.26|
00001a  f1b90f00          CMP      r9,#0                 ;736
00001e  d003              BEQ      |L5.40|
000020  f5b94f00          CMP      r9,#0x8000            ;736
000024  d102              BNE      |L5.44|
000026  e000              B        |L5.42|
                  |L5.40|
000028  bf00              NOP                            ;738
                  |L5.42|
00002a  e003              B        |L5.52|
                  |L5.44|
00002c  f6456025          MOV      r0,#0x5e25            ;745
000030  8028              STRH     r0,[r5,#0]            ;745
000032  e7f0              B        |L5.22|
                  |L5.52|
000034  bf00              NOP                            ;739
000036  4952              LDR      r1,|L5.384|
000038  6820              LDR      r0,[r4,#0]            ;751
00003a  4288              CMP      r0,r1                 ;751
00003c  d003              BEQ      |L5.70|
00003e  f64550c4          MOV      r0,#0x5dc4            ;755
000042  8028              STRH     r0,[r5,#0]            ;755
000044  e7e7              B        |L5.22|
                  |L5.70|
000046  bf00              NOP                            ;760
000048  bf00              NOP                            ;760
00004a  f7fffffe          BL       CPU_SR_Save
00004e  4683              MOV      r11,r0                ;760
000050  bf00              NOP                            ;760
000052  bf00              NOP                            ;760
000054  494b              LDR      r1,|L5.388|
000056  6a60              LDR      r0,[r4,#0x24]         ;761
000058  6809              LDR      r1,[r1,#0]            ;761  ; OSTCBCurPtr
00005a  4288              CMP      r0,r1                 ;761
00005c  d00a              BEQ      |L5.116|
00005e  bf00              NOP                            ;762
000060  bf00              NOP                            ;762
000062  4658              MOV      r0,r11                ;762
000064  f7fffffe          BL       CPU_SR_Restore
000068  bf00              NOP                            ;762
00006a  bf00              NOP                            ;762
00006c  f2457081          MOV      r0,#0x5781            ;766
000070  8028              STRH     r0,[r5,#0]            ;766
000072  e7d0              B        |L5.22|
                  |L5.116|
000074  f7fffffe          BL       CPU_TS_TmrRd
000078  4680              MOV      r8,r0                 ;775
00007a  3428              ADDS     r4,r4,#0x28           ;776
00007c  f8c48004          STR      r8,[r4,#4]            ;776
000080  7820              LDRB     r0,[r4,#0]            ;777
000082  1e40              SUBS     r0,r0,#1              ;777
000084  7020              STRB     r0,[r4,#0]            ;777
000086  f8140928          LDRB     r0,[r4],#-0x28        ;778
00008a  2800              CMP      r0,#0                 ;778
00008c  dd0a              BLE      |L5.164|
00008e  bf00              NOP                            ;779
000090  bf00              NOP                            ;779
000092  4658              MOV      r0,r11                ;779
000094  f7fffffe          BL       CPU_SR_Restore
000098  bf00              NOP                            ;779
00009a  bf00              NOP                            ;779
00009c  f2457083          MOV      r0,#0x5783            ;780
0000a0  8028              STRH     r0,[r5,#0]            ;780
0000a2  e7b8              B        |L5.22|
                  |L5.164|
0000a4  4621              MOV      r1,r4                 ;784
0000a6  4837              LDR      r0,|L5.388|
0000a8  6800              LDR      r0,[r0,#0]            ;784  ; OSTCBCurPtr
0000aa  f7fffffe          BL       OS_MutexGrpRemove
0000ae  f1040a08          ADD      r10,r4,#8             ;786
0000b2  f8ba0008          LDRH     r0,[r10,#8]           ;787
0000b6  b968              CBNZ     r0,|L5.212|
0000b8  2000              MOVS     r0,#0                 ;788
0000ba  6260              STR      r0,[r4,#0x24]         ;788
0000bc  f8840028          STRB     r0,[r4,#0x28]         ;789
0000c0  bf00              NOP                            ;790
0000c2  bf00              NOP                            ;790
0000c4  4658              MOV      r0,r11                ;790
0000c6  f7fffffe          BL       CPU_SR_Restore
0000ca  bf00              NOP                            ;790
0000cc  bf00              NOP                            ;790
0000ce  2000              MOVS     r0,#0                 ;791
0000d0  8028              STRH     r0,[r5,#0]            ;791
0000d2  e7a0              B        |L5.22|
                  |L5.212|
0000d4  482b              LDR      r0,|L5.388|
0000d6  6800              LDR      r0,[r0,#0]            ;795  ; OSTCBCurPtr
0000d8  f8900037          LDRB     r0,[r0,#0x37]         ;795
0000dc  4929              LDR      r1,|L5.388|
0000de  6809              LDR      r1,[r1,#0]            ;795  ; OSTCBCurPtr
0000e0  f8911038          LDRB     r1,[r1,#0x38]         ;795
0000e4  4288              CMP      r0,r1                 ;795
0000e6  d028              BEQ      |L5.314|
0000e8  4826              LDR      r0,|L5.388|
0000ea  6800              LDR      r0,[r0,#0]            ;796  ; OSTCBCurPtr
0000ec  f7fffffe          BL       OS_MutexGrpPrioFindHighest
0000f0  4606              MOV      r6,r0                 ;796
0000f2  4824              LDR      r0,|L5.388|
0000f4  6800              LDR      r0,[r0,#0]            ;797  ; OSTCBCurPtr
0000f6  f8901038          LDRB     r1,[r0,#0x38]         ;797
0000fa  42b1              CMP      r1,r6                 ;797
0000fc  da04              BGE      |L5.264|
0000fe  4821              LDR      r0,|L5.388|
000100  6800              LDR      r0,[r0,#0]            ;797  ; OSTCBCurPtr
000102  f8900038          LDRB     r0,[r0,#0x38]         ;797
000106  e000              B        |L5.266|
                  |L5.264|
000108  4630              MOV      r0,r6                 ;797
                  |L5.266|
00010a  4606              MOV      r6,r0                 ;797
00010c  481d              LDR      r0,|L5.388|
00010e  6800              LDR      r0,[r0,#0]            ;798  ; OSTCBCurPtr
000110  f8900037          LDRB     r0,[r0,#0x37]         ;798
000114  42b0              CMP      r0,r6                 ;798
000116  da10              BGE      |L5.314|
000118  481a              LDR      r0,|L5.388|
00011a  6800              LDR      r0,[r0,#0]            ;799  ; OSTCBCurPtr
00011c  f7fffffe          BL       OS_RdyListRemove
000120  4818              LDR      r0,|L5.388|
000122  6800              LDR      r0,[r0,#0]            ;800  ; OSTCBCurPtr
000124  f8806037          STRB     r6,[r0,#0x37]         ;800
000128  4630              MOV      r0,r6                 ;804
00012a  f7fffffe          BL       OS_PrioInsert
00012e  4815              LDR      r0,|L5.388|
000130  6800              LDR      r0,[r0,#0]            ;805  ; OSTCBCurPtr
000132  f7fffffe          BL       OS_RdyListInsertTail
000136  4814              LDR      r0,|L5.392|
000138  7006              STRB     r6,[r0,#0]            ;806
                  |L5.314|
00013a  f8da0000          LDR      r0,[r10,#0]           ;810
00013e  6887              LDR      r7,[r0,#8]            ;810
000140  6267              STR      r7,[r4,#0x24]         ;811
000142  2001              MOVS     r0,#1                 ;812
000144  f8840028          STRB     r0,[r4,#0x28]         ;812
000148  4621              MOV      r1,r4                 ;813
00014a  4638              MOV      r0,r7                 ;813
00014c  f7fffffe          BL       OS_MutexGrpAdd
000150  2300              MOVS     r3,#0                 ;815
000152  461a              MOV      r2,r3                 ;815
000154  4639              MOV      r1,r7                 ;815
000156  4620              MOV      r0,r4                 ;815
000158  f8cd8000          STR      r8,[sp,#0]            ;815
00015c  f7fffffe          BL       OS_Post
000160  bf00              NOP                            ;821
000162  bf00              NOP                            ;821
000164  4658              MOV      r0,r11                ;821
000166  f7fffffe          BL       CPU_SR_Restore
00016a  bf00              NOP                            ;821
00016c  bf00              NOP                            ;821
00016e  f4094000          AND      r0,r9,#0x8000         ;823
000172  b908              CBNZ     r0,|L5.376|
000174  f7fffffe          BL       OSSched
                  |L5.376|
000178  2000              MOVS     r0,#0                 ;827
00017a  8028              STRH     r0,[r5,#0]            ;827
00017c  bf00              NOP      
00017e  e74a              B        |L5.22|
;;;829    
                          ENDP

                  |L5.384|
                          DCD      0x5854554d
                  |L5.388|
                          DCD      OSTCBCurPtr
                  |L5.392|
                          DCD      OSPrioCur

                          AREA ||i.OS_MutexClr||, CODE, READONLY, ALIGN=2

                  OS_MutexClr PROC
;;;846    
;;;847    void  OS_MutexClr (OS_MUTEX  *p_mutex)
000000  b510              PUSH     {r4,lr}
;;;848    {
000002  4604              MOV      r4,r0
;;;849    #if OS_OBJ_TYPE_REQ > 0u
;;;850        p_mutex->Type              =  OS_OBJ_TYPE_NONE;         /* Mark the data structure as a NONE                      */
000004  4807              LDR      r0,|L6.36|
000006  6020              STR      r0,[r4,#0]
;;;851    #endif
;;;852    #if OS_CFG_DBG_EN > 0u
;;;853        p_mutex->NamePtr           = (CPU_CHAR     *)((void *)"?MUTEX");
000008  a007              ADR      r0,|L6.40|
00000a  6060              STR      r0,[r4,#4]
;;;854    #endif
;;;855        p_mutex->MutexGrpNextPtr   = (OS_MUTEX     *)0;
00000c  2000              MOVS     r0,#0
00000e  6220              STR      r0,[r4,#0x20]
;;;856        p_mutex->OwnerTCBPtr       = (OS_TCB       *)0;
000010  6260              STR      r0,[r4,#0x24]
;;;857        p_mutex->OwnerNestingCtr   = (OS_NESTING_CTR)0;
000012  f8840028          STRB     r0,[r4,#0x28]
;;;858        p_mutex->TS                = (CPU_TS        )0;
000016  62e0              STR      r0,[r4,#0x2c]
;;;859        OS_PendListInit(&p_mutex->PendList);                    /* Initialize the waiting list                            */
000018  f1040008          ADD      r0,r4,#8
00001c  f7fffffe          BL       OS_PendListInit
;;;860    }
000020  bd10              POP      {r4,pc}
;;;861    
                          ENDP

000022  0000              DCW      0x0000
                  |L6.36|
                          DCD      0x454e4f4e
                  |L6.40|
000028  3f4d5554          DCB      "?MUTEX",0
00002c  455800  
00002f  00                DCB      0

                          AREA ||i.OS_MutexDbgListAdd||, CODE, READONLY, ALIGN=2

                  OS_MutexDbgListAdd PROC
;;;878    #if OS_CFG_DBG_EN > 0u
;;;879    void  OS_MutexDbgListAdd (OS_MUTEX  *p_mutex)
000000  a109              ADR      r1,|L7.40|
;;;880    {
;;;881        p_mutex->DbgNamePtr               = (CPU_CHAR *)((void *)" ");
000002  61c1              STR      r1,[r0,#0x1c]
;;;882        p_mutex->DbgPrevPtr               = (OS_MUTEX *)0;
000004  2100              MOVS     r1,#0
000006  6141              STR      r1,[r0,#0x14]
;;;883        if (OSMutexDbgListPtr == (OS_MUTEX *)0) {
000008  4908              LDR      r1,|L7.44|
00000a  6809              LDR      r1,[r1,#0]  ; OSMutexDbgListPtr
00000c  b911              CBNZ     r1,|L7.20|
;;;884            p_mutex->DbgNextPtr           = (OS_MUTEX *)0;
00000e  2100              MOVS     r1,#0
000010  6181              STR      r1,[r0,#0x18]
000012  e005              B        |L7.32|
                  |L7.20|
;;;885        } else {
;;;886            p_mutex->DbgNextPtr           =  OSMutexDbgListPtr;
000014  4905              LDR      r1,|L7.44|
000016  6809              LDR      r1,[r1,#0]  ; OSMutexDbgListPtr
000018  6181              STR      r1,[r0,#0x18]
;;;887            OSMutexDbgListPtr->DbgPrevPtr =  p_mutex;
00001a  4904              LDR      r1,|L7.44|
00001c  6809              LDR      r1,[r1,#0]  ; OSMutexDbgListPtr
00001e  6148              STR      r0,[r1,#0x14]
                  |L7.32|
;;;888        }
;;;889        OSMutexDbgListPtr                 =  p_mutex;
000020  4902              LDR      r1,|L7.44|
000022  6008              STR      r0,[r1,#0]  ; OSMutexDbgListPtr
;;;890    }
000024  4770              BX       lr
;;;891    
                          ENDP

000026  0000              DCW      0x0000
                  |L7.40|
000028  2000              DCB      " ",0
00002a  00                DCB      0
00002b  00                DCB      0
                  |L7.44|
                          DCD      OSMutexDbgListPtr

                          AREA ||i.OS_MutexDbgListRemove||, CODE, READONLY, ALIGN=2

                  OS_MutexDbgListRemove PROC
;;;893    
;;;894    void  OS_MutexDbgListRemove (OS_MUTEX  *p_mutex)
000000  6942              LDR      r2,[r0,#0x14]
;;;895    {
;;;896        OS_MUTEX  *p_mutex_next;
;;;897        OS_MUTEX  *p_mutex_prev;
;;;898    
;;;899    
;;;900        p_mutex_prev = p_mutex->DbgPrevPtr;
;;;901        p_mutex_next = p_mutex->DbgNextPtr;
000002  6981              LDR      r1,[r0,#0x18]
;;;902    
;;;903        if (p_mutex_prev == (OS_MUTEX *)0) {
000004  b93a              CBNZ     r2,|L8.22|
;;;904            OSMutexDbgListPtr = p_mutex_next;
000006  4b09              LDR      r3,|L8.44|
000008  6019              STR      r1,[r3,#0]  ; OSMutexDbgListPtr
;;;905            if (p_mutex_next != (OS_MUTEX *)0) {
00000a  b109              CBZ      r1,|L8.16|
;;;906                p_mutex_next->DbgPrevPtr = (OS_MUTEX *)0;
00000c  2300              MOVS     r3,#0
00000e  614b              STR      r3,[r1,#0x14]
                  |L8.16|
;;;907            }
;;;908            p_mutex->DbgNextPtr = (OS_MUTEX *)0;
000010  2300              MOVS     r3,#0
000012  6183              STR      r3,[r0,#0x18]
000014  e009              B        |L8.42|
                  |L8.22|
;;;909    
;;;910        } else if (p_mutex_next == (OS_MUTEX *)0) {
000016  b919              CBNZ     r1,|L8.32|
;;;911            p_mutex_prev->DbgNextPtr = (OS_MUTEX *)0;
000018  2300              MOVS     r3,#0
00001a  6193              STR      r3,[r2,#0x18]
;;;912            p_mutex->DbgPrevPtr      = (OS_MUTEX *)0;
00001c  6143              STR      r3,[r0,#0x14]
00001e  e004              B        |L8.42|
                  |L8.32|
;;;913    
;;;914        } else {
;;;915            p_mutex_prev->DbgNextPtr =  p_mutex_next;
000020  6191              STR      r1,[r2,#0x18]
;;;916            p_mutex_next->DbgPrevPtr =  p_mutex_prev;
000022  614a              STR      r2,[r1,#0x14]
;;;917            p_mutex->DbgNextPtr      = (OS_MUTEX *)0;
000024  2300              MOVS     r3,#0
000026  6183              STR      r3,[r0,#0x18]
;;;918            p_mutex->DbgPrevPtr      = (OS_MUTEX *)0;
000028  6143              STR      r3,[r0,#0x14]
                  |L8.42|
;;;919        }
;;;920    }
00002a  4770              BX       lr
;;;921    #endif
                          ENDP

                  |L8.44|
                          DCD      OSMutexDbgListPtr

                          AREA ||i.OS_MutexGrpAdd||, CODE, READONLY, ALIGN=1

                  OS_MutexGrpAdd PROC
;;;976    
;;;977    void  OS_MutexGrpAdd (OS_TCB  *p_tcb, OS_MUTEX  *p_mutex)
000000  6bc2              LDR      r2,[r0,#0x3c]
;;;978    {
;;;979        p_mutex->MutexGrpNextPtr = p_tcb->MutexGrpHeadPtr;      /* The mutex grp is not sorted add to head of list.       */
000002  620a              STR      r2,[r1,#0x20]
;;;980        p_tcb->MutexGrpHeadPtr   = p_mutex;
000004  63c1              STR      r1,[r0,#0x3c]
;;;981    }
000006  4770              BX       lr
;;;982    
                          ENDP


                          AREA ||i.OS_MutexGrpPostAll||, CODE, READONLY, ALIGN=1

                  OS_MutexGrpPostAll PROC
;;;1074   
;;;1075   void  OS_MutexGrpPostAll (OS_TCB  *p_tcb)
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;1076   {
000004  4605              MOV      r5,r0
;;;1077       OS_MUTEX      *p_mutex;
;;;1078       OS_MUTEX      *p_mutex_next;
;;;1079       CPU_TS         ts;
;;;1080       OS_PEND_LIST  *p_pend_list;
;;;1081       OS_TCB        *p_tcb_new;
;;;1082   
;;;1083   
;;;1084       p_mutex = p_tcb->MutexGrpHeadPtr;
000006  6bec              LDR      r4,[r5,#0x3c]
;;;1085   
;;;1086       while(p_mutex != (OS_MUTEX *)0) {
000008  e026              B        |L10.88|
                  |L10.10|
;;;1087   
;;;1088   #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN > 0u))
;;;1089       TRACE_OS_MUTEX_POST(p_mutex);                               /* Record the event.                                    */
;;;1090   #endif
;;;1091   
;;;1092           p_mutex_next = p_mutex->MutexGrpNextPtr;
00000a  f8d49020          LDR      r9,[r4,#0x20]
;;;1093           ts           = OS_TS_GET();                             /* Get timestamp                                        */
00000e  f7fffffe          BL       CPU_TS_TmrRd
000012  4606              MOV      r6,r0
;;;1094           p_mutex->TS  = ts;
000014  62e6              STR      r6,[r4,#0x2c]
;;;1095           OS_MutexGrpRemove(p_tcb,  p_mutex);                     /* Remove mutex from owner's group                      */
000016  4621              MOV      r1,r4
000018  4628              MOV      r0,r5
00001a  f7fffffe          BL       OS_MutexGrpRemove
;;;1096   
;;;1097           p_pend_list = &p_mutex->PendList;
00001e  f1040808          ADD      r8,r4,#8
;;;1098           if (p_pend_list->NbrEntries == (OS_OBJ_QTY)0) {         /* Any task waiting on mutex?                           */
000022  f8b80008          LDRH     r0,[r8,#8]
000026  b920              CBNZ     r0,|L10.50|
;;;1099               p_mutex->OwnerNestingCtr =           0u;            /* Decrement owner's nesting counter                    */
000028  2000              MOVS     r0,#0
00002a  f8840028          STRB     r0,[r4,#0x28]
;;;1100               p_mutex->OwnerTCBPtr     = (OS_TCB *)0;             /* No                                                   */
00002e  6260              STR      r0,[r4,#0x24]
000030  e011              B        |L10.86|
                  |L10.50|
;;;1101           } else {
;;;1102                                                                   /* Get TCB from head of pend list                       */
;;;1103               p_tcb_new = p_pend_list->HeadPtr->TCBPtr;
000032  f8d80000          LDR      r0,[r8,#0]
000036  6887              LDR      r7,[r0,#8]
;;;1104               p_mutex->OwnerTCBPtr     = p_tcb;                   /* Give mutex to new owner                              */
000038  6265              STR      r5,[r4,#0x24]
;;;1105               p_mutex->OwnerNestingCtr = 1u;
00003a  2001              MOVS     r0,#1
00003c  f8840028          STRB     r0,[r4,#0x28]
;;;1106               OS_MutexGrpAdd(p_tcb_new, p_mutex);
000040  4621              MOV      r1,r4
000042  4638              MOV      r0,r7
000044  f7fffffe          BL       OS_MutexGrpAdd
;;;1107                                                                   /* Post to mutex                                        */
;;;1108               OS_Post((OS_PEND_OBJ *)((void *)p_mutex),
000048  2300              MOVS     r3,#0
00004a  461a              MOV      r2,r3
00004c  4639              MOV      r1,r7
00004e  4620              MOV      r0,r4
000050  9600              STR      r6,[sp,#0]
000052  f7fffffe          BL       OS_Post
                  |L10.86|
;;;1109                                               p_tcb_new,
;;;1110                                       (void *)0,
;;;1111                                               0u,
;;;1112                                               ts);
;;;1113           }
;;;1114   
;;;1115           p_mutex = p_mutex_next;
000056  464c              MOV      r4,r9
                  |L10.88|
000058  2c00              CMP      r4,#0                 ;1086
00005a  d1d6              BNE      |L10.10|
;;;1116       }
;;;1117   
;;;1118   }
00005c  e8bd83f8          POP      {r3-r9,pc}
;;;1119   
                          ENDP


                          AREA ||i.OS_MutexGrpPrioFindHighest||, CODE, READONLY, ALIGN=1

                  OS_MutexGrpPrioFindHighest PROC
;;;1031   
;;;1032   OS_PRIO  OS_MutexGrpPrioFindHighest (OS_TCB  *p_tcb)
000000  b530              PUSH     {r4,r5,lr}
;;;1033   {
000002  4604              MOV      r4,r0
;;;1034       OS_MUTEX     **pp_mutex;
;;;1035       OS_PRIO        highest_prio;
;;;1036       OS_PRIO        prio;
;;;1037       OS_PEND_DATA  *p_head;
;;;1038   
;;;1039   
;;;1040       highest_prio = OS_CFG_PRIO_MAX - 1u;
000004  203f              MOVS     r0,#0x3f
;;;1041       pp_mutex = &p_tcb->MutexGrpHeadPtr;
000006  f104013c          ADD      r1,r4,#0x3c
;;;1042   
;;;1043       while(*pp_mutex != (OS_MUTEX *)0) {
00000a  e00b              B        |L11.36|
                  |L11.12|
;;;1044           p_head = (*pp_mutex)->PendList.HeadPtr;
00000c  680d              LDR      r5,[r1,#0]
00000e  68ab              LDR      r3,[r5,#8]
;;;1045           if (p_head!= (OS_PEND_DATA *)0) {
000010  b12b              CBZ      r3,|L11.30|
;;;1046               prio = p_head->TCBPtr->Prio;
000012  689d              LDR      r5,[r3,#8]
000014  f8952037          LDRB     r2,[r5,#0x37]
;;;1047               if(prio < highest_prio) {
000018  4282              CMP      r2,r0
00001a  da00              BGE      |L11.30|
;;;1048                   highest_prio = prio;
00001c  4610              MOV      r0,r2
                  |L11.30|
;;;1049               }
;;;1050           }
;;;1051           pp_mutex = &(*pp_mutex)->MutexGrpNextPtr;
00001e  680d              LDR      r5,[r1,#0]
000020  f1050120          ADD      r1,r5,#0x20
                  |L11.36|
000024  680d              LDR      r5,[r1,#0]            ;1043
000026  2d00              CMP      r5,#0                 ;1043
000028  d1f0              BNE      |L11.12|
;;;1052       }
;;;1053   
;;;1054       return (highest_prio);
;;;1055   }
00002a  bd30              POP      {r4,r5,pc}
;;;1056   
                          ENDP


                          AREA ||i.OS_MutexGrpRemove||, CODE, READONLY, ALIGN=1

                  OS_MutexGrpRemove PROC
;;;1001   
;;;1002   void  OS_MutexGrpRemove (OS_TCB  *p_tcb, OS_MUTEX  *p_mutex)
000000  4602              MOV      r2,r0
;;;1003   {
;;;1004       OS_MUTEX  **pp_mutex;
;;;1005   
;;;1006       pp_mutex = &p_tcb->MutexGrpHeadPtr;
000002  f102003c          ADD      r0,r2,#0x3c
;;;1007   
;;;1008       while(*pp_mutex != p_mutex) {
000006  e002              B        |L12.14|
                  |L12.8|
;;;1009           pp_mutex = &(*pp_mutex)->MutexGrpNextPtr;
000008  6803              LDR      r3,[r0,#0]
00000a  f1030020          ADD      r0,r3,#0x20
                  |L12.14|
00000e  6803              LDR      r3,[r0,#0]            ;1008
000010  428b              CMP      r3,r1                 ;1008
000012  d1f9              BNE      |L12.8|
;;;1010       }
;;;1011   
;;;1012       *pp_mutex = (*pp_mutex)->MutexGrpNextPtr;
000014  6803              LDR      r3,[r0,#0]
000016  6a1b              LDR      r3,[r3,#0x20]
000018  6003              STR      r3,[r0,#0]
;;;1013   }
00001a  4770              BX       lr
;;;1014   
                          ENDP


                          AREA ||i.OS_MutexInit||, CODE, READONLY, ALIGN=2

                  OS_MutexInit PROC
;;;940    
;;;941    void  OS_MutexInit (OS_ERR  *p_err)
000000  2100              MOVS     r1,#0
;;;942    {
;;;943    #ifdef OS_SAFETY_CRITICAL
;;;944        if (p_err == (OS_ERR *)0) {
;;;945            OS_SAFETY_CRITICAL_EXCEPTION();
;;;946            return;
;;;947        }
;;;948    #endif
;;;949    
;;;950    #if OS_CFG_DBG_EN > 0u
;;;951        OSMutexDbgListPtr = (OS_MUTEX *)0;
000002  4a03              LDR      r2,|L13.16|
000004  6011              STR      r1,[r2,#0]  ; OSMutexDbgListPtr
;;;952    #endif
;;;953    
;;;954        OSMutexQty        = (OS_OBJ_QTY)0;
000006  4a03              LDR      r2,|L13.20|
000008  8011              STRH     r1,[r2,#0]
;;;955       *p_err             =  OS_ERR_NONE;
00000a  8001              STRH     r1,[r0,#0]
;;;956    }
00000c  4770              BX       lr
;;;957    
                          ENDP

00000e  0000              DCW      0x0000
                  |L13.16|
                          DCD      OSMutexDbgListPtr
                  |L13.20|
                          DCD      OSMutexQty
