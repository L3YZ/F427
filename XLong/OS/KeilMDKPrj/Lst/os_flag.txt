; generated by Component: ARM Compiler 5.05 (build 41) Tool: ArmCC [4d0eb9]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\os_flag.o --asm_dir=.\Lst\ --list_dir=.\Lst\ --depend=.\obj\os_flag.d --cpu=Cortex-M4.fp --apcs=interwork -O0 -I..\..\..\CMSIS\4.5.0\CMSIS\Include -I..\APP -I..\APP\ST -I..\APP\uCOS -I..\..\BSP\KeilMDK -I..\..\BSP\Board\inc -I..\..\BSP\STM32F4xx\inc -I..\..\BSP\Xlong\inc -I..\..\..\uCOS\uC-CPU -I..\..\..\uCOS\uC-CPU\Ports\ARM-Cortex-M4 -I..\..\..\uCOS\uC-LIB -I..\..\..\uCOS\uC-LIB\Ports\ARM-Cortex-M4 -I..\..\..\uCOS\uCOS-III\Source -I..\..\..\uCOS\uCOS-III\Ports\ARM-Cortex-M4 -IC:\Users\V200\Desktop\XLong\XLong\OS\KeilMDKPrj\RTE -Id:\Keil_v5\ARM\PACK\Keil\STM32F4xx_DFP\1.0.8\Device\Include -Id:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -DSTM32F427_437xx -DSTM32F427_437xx -DUSE_STDPERIPH_DRIVER --omf_browse=.\obj\os_flag.crf ..\..\..\uCOS\uCOS-III\Source\os_flag.c]
                          THUMB

                          AREA ||i.OSFlagCreate||, CODE, READONLY, ALIGN=2

                  OSFlagCreate PROC
;;;70     
;;;71     void  OSFlagCreate (OS_FLAG_GRP  *p_grp,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;72                         CPU_CHAR     *p_name,
;;;73                         OS_FLAGS      flags,
;;;74                         OS_ERR       *p_err)
;;;75     {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
00000a  461d              MOV      r5,r3
;;;76         CPU_SR_ALLOC();
00000c  f04f0800          MOV      r8,#0
;;;77     
;;;78     
;;;79     
;;;80     #ifdef OS_SAFETY_CRITICAL
;;;81         if (p_err == (OS_ERR *)0) {
;;;82             OS_SAFETY_CRITICAL_EXCEPTION();
;;;83             return;
;;;84         }
;;;85     #endif
;;;86     
;;;87     #ifdef OS_SAFETY_CRITICAL_IEC61508
;;;88         if (OSSafetyCriticalStartFlag == DEF_TRUE) {
;;;89            *p_err = OS_ERR_ILLEGAL_CREATE_RUN_TIME;
;;;90             return;
;;;91         }
;;;92     #endif
;;;93     
;;;94     #if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
;;;95         if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* See if called from ISR ...                             */
;;;96            *p_err = OS_ERR_CREATE_ISR;                          /* ... can't CREATE from an ISR                           */
;;;97             return;
;;;98         }
;;;99     #endif
;;;100    
;;;101    #if OS_CFG_ARG_CHK_EN > 0u
;;;102        if (p_grp == (OS_FLAG_GRP *)0) {                        /* Validate 'p_grp'                                       */
000010  b924              CBNZ     r4,|L1.28|
;;;103           *p_err = OS_ERR_OBJ_PTR_NULL;
000012  f64550c3          MOV      r0,#0x5dc3
000016  8028              STRH     r0,[r5,#0]
                  |L1.24|
;;;104            return;
;;;105        }
;;;106    #endif
;;;107    
;;;108        OS_CRITICAL_ENTER();
;;;109    #if OS_OBJ_TYPE_REQ > 0u
;;;110        p_grp->Type    = OS_OBJ_TYPE_FLAG;                      /* Set to event flag group type                           */
;;;111    #endif
;;;112    #if OS_CFG_DBG_EN > 0u
;;;113        p_grp->NamePtr = p_name;
;;;114    #else
;;;115        (void)&p_name;
;;;116    #endif
;;;117        p_grp->Flags   = flags;                                 /* Set to desired initial value                           */
;;;118        p_grp->TS      = (CPU_TS)0;
;;;119        OS_PendListInit(&p_grp->PendList);
;;;120    
;;;121    #if OS_CFG_DBG_EN > 0u
;;;122        OS_FlagDbgListAdd(p_grp);
;;;123    #endif
;;;124        OSFlagQty++;
;;;125    
;;;126    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN > 0u))
;;;127        TRACE_OS_FLAG_CREATE(p_grp, p_name);                    /* Record the event.                                      */
;;;128    #endif
;;;129        
;;;130        OS_CRITICAL_EXIT_NO_SCHED();
;;;131       *p_err = OS_ERR_NONE;
;;;132    }
000018  e8bd81f0          POP      {r4-r8,pc}
                  |L1.28|
00001c  bf00              NOP                            ;108
00001e  bf00              NOP                            ;108
000020  f7fffffe          BL       CPU_SR_Save
000024  4680              MOV      r8,r0                 ;108
000026  bf00              NOP                            ;108
000028  bf00              NOP                            ;108
00002a  480e              LDR      r0,|L1.100|
00002c  6020              STR      r0,[r4,#0]            ;110
00002e  6066              STR      r6,[r4,#4]            ;113
000030  6227              STR      r7,[r4,#0x20]         ;117
000032  2000              MOVS     r0,#0                 ;118
000034  6260              STR      r0,[r4,#0x24]         ;118
000036  f1040008          ADD      r0,r4,#8              ;119
00003a  f7fffffe          BL       OS_PendListInit
00003e  4620              MOV      r0,r4                 ;122
000040  f7fffffe          BL       OS_FlagDbgListAdd
000044  4808              LDR      r0,|L1.104|
000046  8800              LDRH     r0,[r0,#0]            ;124  ; OSFlagQty
000048  1c40              ADDS     r0,r0,#1              ;124
00004a  4907              LDR      r1,|L1.104|
00004c  8008              STRH     r0,[r1,#0]            ;124
00004e  bf00              NOP                            ;130
000050  bf00              NOP                            ;130
000052  4640              MOV      r0,r8                 ;130
000054  f7fffffe          BL       CPU_SR_Restore
000058  bf00              NOP                            ;130
00005a  bf00              NOP                            ;130
00005c  2000              MOVS     r0,#0                 ;131
00005e  8028              STRH     r0,[r5,#0]            ;131
000060  bf00              NOP      
000062  e7d9              B        |L1.24|
;;;133    
                          ENDP

                  |L1.100|
                          DCD      0x47414c46
                  |L1.104|
                          DCD      OSFlagQty

                          AREA ||i.OSFlagDel||, CODE, READONLY, ALIGN=2

                  OSFlagDel PROC
;;;166    #if OS_CFG_FLAG_DEL_EN > 0u
;;;167    OS_OBJ_QTY  OSFlagDel (OS_FLAG_GRP  *p_grp,
000000  e92d5ffc          PUSH     {r2-r12,lr}
;;;168                           OS_OPT        opt,
;;;169                           OS_ERR       *p_err)
;;;170    {
000004  4605              MOV      r5,r0
000006  4688              MOV      r8,r1
000008  4614              MOV      r4,r2
;;;171        OS_OBJ_QTY        cnt;
;;;172        OS_OBJ_QTY        nbr_tasks;
;;;173        OS_PEND_DATA     *p_pend_data;
;;;174        OS_PEND_LIST     *p_pend_list;
;;;175        OS_TCB           *p_tcb;
;;;176        CPU_TS            ts;
;;;177        CPU_SR_ALLOC();
00000a  2000              MOVS     r0,#0
00000c  9000              STR      r0,[sp,#0]
;;;178    
;;;179    
;;;180    
;;;181    #ifdef OS_SAFETY_CRITICAL
;;;182        if (p_err == (OS_ERR *)0) {
;;;183            OS_SAFETY_CRITICAL_EXCEPTION();
;;;184            return ((OS_OBJ_QTY)0);
;;;185        }
;;;186    #endif
;;;187    
;;;188    #if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
;;;189        if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* See if called from ISR ...                             */
;;;190           *p_err = OS_ERR_DEL_ISR;                             /* ... can't DELETE from an ISR                           */
;;;191            return ((OS_OBJ_QTY)0);
;;;192        }
;;;193    #endif
;;;194    
;;;195    #if OS_CFG_ARG_CHK_EN > 0u
;;;196        if (p_grp == (OS_FLAG_GRP *)0) {                        /* Validate 'p_grp'                                       */
00000e  b92d              CBNZ     r5,|L2.28|
;;;197           *p_err  = OS_ERR_OBJ_PTR_NULL;
000010  f64550c3          MOV      r0,#0x5dc3
000014  8020              STRH     r0,[r4,#0]
;;;198            return ((OS_OBJ_QTY)0);
000016  2000              MOVS     r0,#0
                  |L2.24|
;;;199        }
;;;200        switch (opt) {                                          /* Validate 'opt'                                         */
;;;201            case OS_OPT_DEL_NO_PEND:
;;;202            case OS_OPT_DEL_ALWAYS:
;;;203                 break;
;;;204    
;;;205            default:
;;;206                *p_err = OS_ERR_OPT_INVALID;
;;;207                 return ((OS_OBJ_QTY)0);
;;;208        }
;;;209    #endif
;;;210    
;;;211    #if OS_CFG_OBJ_TYPE_CHK_EN > 0u
;;;212        if (p_grp->Type != OS_OBJ_TYPE_FLAG) {                  /* Validate event group object                            */
;;;213           *p_err = OS_ERR_OBJ_TYPE;
;;;214            return ((OS_OBJ_QTY)0);
;;;215        }
;;;216    #endif
;;;217        OS_CRITICAL_ENTER();
;;;218        p_pend_list = &p_grp->PendList;
;;;219        cnt         = p_pend_list->NbrEntries;
;;;220        nbr_tasks   = cnt;
;;;221        switch (opt) {
;;;222            case OS_OPT_DEL_NO_PEND:                            /* Delete group if no task waiting                        */
;;;223                 if (nbr_tasks == (OS_OBJ_QTY)0) {
;;;224    #if OS_CFG_DBG_EN > 0u
;;;225                     OS_FlagDbgListRemove(p_grp);
;;;226    #endif
;;;227                     OSFlagQty--;
;;;228    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN > 0u))
;;;229                     TRACE_OS_FLAG_DEL(p_grp);                  /* Record the event.                                      */
;;;230    #endif
;;;231                     OS_FlagClr(p_grp);
;;;232    
;;;233                     OS_CRITICAL_EXIT();
;;;234    
;;;235                    *p_err = OS_ERR_NONE;
;;;236                 } else {
;;;237                     OS_CRITICAL_EXIT();
;;;238                    *p_err = OS_ERR_TASK_WAITING;
;;;239                 }
;;;240                 break;
;;;241    
;;;242            case OS_OPT_DEL_ALWAYS:                             /* Always delete the event flag group                     */
;;;243                 ts = OS_TS_GET();                              /* Get local time stamp so all tasks get the same time    */
;;;244                 while (cnt > 0u) {                             /* Remove all tasks from the pend list                    */
;;;245                     p_pend_data = p_pend_list->HeadPtr;
;;;246                     p_tcb       = p_pend_data->TCBPtr;
;;;247                     OS_PendObjDel((OS_PEND_OBJ *)((void *)p_grp),
;;;248                                   p_tcb,
;;;249                                   ts);
;;;250                     cnt--;
;;;251                 }
;;;252    #if OS_CFG_DBG_EN > 0u
;;;253                 OS_FlagDbgListRemove(p_grp);
;;;254    #endif
;;;255                 OSFlagQty--;
;;;256    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN > 0u))
;;;257                 TRACE_OS_FLAG_DEL(p_grp);                      /* Record the event.                                      */
;;;258    #endif
;;;259                 OS_FlagClr(p_grp);
;;;260                 OS_CRITICAL_EXIT_NO_SCHED();
;;;261    
;;;262                 OSSched();                                     /* Find highest priority task ready to run                */
;;;263                *p_err = OS_ERR_NONE;
;;;264                 break;
;;;265    
;;;266            default:
;;;267                 OS_CRITICAL_EXIT();
;;;268                *p_err = OS_ERR_OPT_INVALID;
;;;269                 break;
;;;270        }
;;;271        return (nbr_tasks);
;;;272    }
000018  e8bd9ffc          POP      {r2-r12,pc}
                  |L2.28|
00001c  f1b80f00          CMP      r8,#0                 ;200
000020  d003              BEQ      |L2.42|
000022  f1b80f01          CMP      r8,#1                 ;200
000026  d102              BNE      |L2.46|
000028  e000              B        |L2.44|
                  |L2.42|
00002a  bf00              NOP                            ;202
                  |L2.44|
00002c  e004              B        |L2.56|
                  |L2.46|
00002e  f6456025          MOV      r0,#0x5e25            ;206
000032  8020              STRH     r0,[r4,#0]            ;206
000034  2000              MOVS     r0,#0                 ;207
000036  e7ef              B        |L2.24|
                  |L2.56|
000038  bf00              NOP                            ;203
00003a  4939              LDR      r1,|L2.288|
00003c  6828              LDR      r0,[r5,#0]            ;212
00003e  4288              CMP      r0,r1                 ;212
000040  d004              BEQ      |L2.76|
000042  f64550c4          MOV      r0,#0x5dc4            ;213
000046  8020              STRH     r0,[r4,#0]            ;213
000048  2000              MOVS     r0,#0                 ;214
00004a  e7e5              B        |L2.24|
                  |L2.76|
00004c  bf00              NOP                            ;217
00004e  bf00              NOP                            ;217
000050  f7fffffe          BL       CPU_SR_Save
000054  9000              STR      r0,[sp,#0]            ;217
000056  bf00              NOP                            ;217
000058  bf00              NOP                            ;217
00005a  f1050908          ADD      r9,r5,#8              ;218
00005e  f8b96008          LDRH     r6,[r9,#8]            ;219
000062  4637              MOV      r7,r6                 ;220
000064  f1b80f00          CMP      r8,#0                 ;221
000068  d003              BEQ      |L2.114|
00006a  f1b80f01          CMP      r8,#1                 ;221
00006e  d149              BNE      |L2.260|
000070  e020              B        |L2.180|
                  |L2.114|
000072  b9a7              CBNZ     r7,|L2.158|
000074  4628              MOV      r0,r5                 ;225
000076  f7fffffe          BL       OS_FlagDbgListRemove
00007a  482a              LDR      r0,|L2.292|
00007c  8800              LDRH     r0,[r0,#0]            ;227  ; OSFlagQty
00007e  1e40              SUBS     r0,r0,#1              ;227
000080  4928              LDR      r1,|L2.292|
000082  8008              STRH     r0,[r1,#0]            ;227
000084  4628              MOV      r0,r5                 ;231
000086  f7fffffe          BL       OS_FlagClr
00008a  bf00              NOP                            ;233
00008c  bf00              NOP                            ;233
00008e  9800              LDR      r0,[sp,#0]            ;233
000090  f7fffffe          BL       CPU_SR_Restore
000094  bf00              NOP                            ;233
000096  bf00              NOP                            ;233
000098  2000              MOVS     r0,#0                 ;235
00009a  8020              STRH     r0,[r4,#0]            ;235
00009c  e009              B        |L2.178|
                  |L2.158|
00009e  bf00              NOP                            ;237
0000a0  bf00              NOP                            ;237
0000a2  9800              LDR      r0,[sp,#0]            ;237
0000a4  f7fffffe          BL       CPU_SR_Restore
0000a8  bf00              NOP                            ;237
0000aa  bf00              NOP                            ;237
0000ac  f247105f          MOV      r0,#0x715f            ;238
0000b0  8020              STRH     r0,[r4,#0]            ;238
                  |L2.178|
0000b2  e032              B        |L2.282|
                  |L2.180|
0000b4  f7fffffe          BL       CPU_TS_TmrRd
0000b8  9001              STR      r0,[sp,#4]            ;243
0000ba  e00a              B        |L2.210|
                  |L2.188|
0000bc  f8d9a000          LDR      r10,[r9,#0]           ;245
0000c0  f8dab008          LDR      r11,[r10,#8]          ;246
0000c4  4659              MOV      r1,r11                ;247
0000c6  4628              MOV      r0,r5                 ;247
0000c8  9a01              LDR      r2,[sp,#4]            ;247
0000ca  f7fffffe          BL       OS_PendObjDel
0000ce  1e70              SUBS     r0,r6,#1              ;250
0000d0  b286              UXTH     r6,r0                 ;250
                  |L2.210|
0000d2  2e00              CMP      r6,#0                 ;244
0000d4  d1f2              BNE      |L2.188|
0000d6  4628              MOV      r0,r5                 ;253
0000d8  f7fffffe          BL       OS_FlagDbgListRemove
0000dc  4811              LDR      r0,|L2.292|
0000de  8800              LDRH     r0,[r0,#0]            ;255  ; OSFlagQty
0000e0  1e40              SUBS     r0,r0,#1              ;255
0000e2  4910              LDR      r1,|L2.292|
0000e4  8008              STRH     r0,[r1,#0]            ;255
0000e6  4628              MOV      r0,r5                 ;259
0000e8  f7fffffe          BL       OS_FlagClr
0000ec  bf00              NOP                            ;260
0000ee  bf00              NOP                            ;260
0000f0  9800              LDR      r0,[sp,#0]            ;260
0000f2  f7fffffe          BL       CPU_SR_Restore
0000f6  bf00              NOP                            ;260
0000f8  bf00              NOP                            ;260
0000fa  f7fffffe          BL       OSSched
0000fe  2000              MOVS     r0,#0                 ;263
000100  8020              STRH     r0,[r4,#0]            ;263
000102  e00a              B        |L2.282|
                  |L2.260|
000104  bf00              NOP                            ;267
000106  bf00              NOP                            ;267
000108  9800              LDR      r0,[sp,#0]            ;267
00010a  f7fffffe          BL       CPU_SR_Restore
00010e  bf00              NOP                            ;267
000110  bf00              NOP                            ;267
000112  f6456025          MOV      r0,#0x5e25            ;268
000116  8020              STRH     r0,[r4,#0]            ;268
000118  bf00              NOP                            ;269
                  |L2.282|
00011a  bf00              NOP                            ;240
00011c  4638              MOV      r0,r7                 ;271
00011e  e77b              B        |L2.24|
;;;273    #endif
                          ENDP

                  |L2.288|
                          DCD      0x47414c46
                  |L2.292|
                          DCD      OSFlagQty

                          AREA ||i.OSFlagPend||, CODE, READONLY, ALIGN=2

                  OSFlagPend PROC
;;;333    
;;;334    OS_FLAGS  OSFlagPend (OS_FLAG_GRP  *p_grp,
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;335                          OS_FLAGS      flags,
;;;336                          OS_TICK       timeout,
;;;337                          OS_OPT        opt,
;;;338                          CPU_TS       *p_ts,
;;;339                          OS_ERR       *p_err)
;;;340    {
000004  b08b              SUB      sp,sp,#0x2c
000006  4604              MOV      r4,r0
000008  4688              MOV      r8,r1
00000a  4693              MOV      r11,r2
00000c  4699              MOV      r9,r3
00000e  e9dd7514          LDRD     r7,r5,[sp,#0x50]
;;;341        CPU_BOOLEAN   consume;
;;;342        OS_FLAGS      flags_rdy;
;;;343        OS_OPT        mode;
;;;344        OS_PEND_DATA  pend_data;
;;;345        CPU_SR_ALLOC();
000012  2000              MOVS     r0,#0
000014  9001              STR      r0,[sp,#4]
;;;346    
;;;347    
;;;348    
;;;349    #ifdef OS_SAFETY_CRITICAL
;;;350        if (p_err == (OS_ERR *)0) {
;;;351    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN > 0u))
;;;352            TRACE_OS_FLAG_PEND_FAILED(p_grp);                   /* Record the event.                                      */
;;;353    #endif
;;;354            OS_SAFETY_CRITICAL_EXCEPTION();
;;;355            return ((OS_FLAGS)0);
;;;356        }
;;;357    #endif
;;;358    
;;;359    #if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
;;;360        if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* See if called from ISR ...                             */
;;;361    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN > 0u))
;;;362            TRACE_OS_FLAG_PEND_FAILED(p_grp);                   /* Record the event.                                      */
;;;363    #endif
;;;364           *p_err = OS_ERR_PEND_ISR;                            /* ... can't PEND from an ISR                             */
;;;365            return ((OS_FLAGS)0);
;;;366        }
;;;367    #endif
;;;368    
;;;369    #if OS_CFG_ARG_CHK_EN > 0u
;;;370        if (p_grp == (OS_FLAG_GRP *)0) {                        /* Validate 'p_grp'                                       */
000016  b934              CBNZ     r4,|L3.38|
;;;371    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN > 0u))
;;;372            TRACE_OS_FLAG_PEND_FAILED(p_grp);                   /* Record the event.                                      */
;;;373    #endif
;;;374           *p_err = OS_ERR_OBJ_PTR_NULL;
000018  f64550c3          MOV      r0,#0x5dc3
00001c  8028              STRH     r0,[r5,#0]
;;;375            return ((OS_FLAGS)0);
00001e  2000              MOVS     r0,#0
                  |L3.32|
;;;376        }
;;;377        switch (opt) {                                          /* Validate 'opt'                                         */
;;;378            case OS_OPT_PEND_FLAG_CLR_ALL:
;;;379            case OS_OPT_PEND_FLAG_CLR_ANY:
;;;380            case OS_OPT_PEND_FLAG_SET_ALL:
;;;381            case OS_OPT_PEND_FLAG_SET_ANY:
;;;382            case OS_OPT_PEND_FLAG_CLR_ALL | OS_OPT_PEND_FLAG_CONSUME:
;;;383            case OS_OPT_PEND_FLAG_CLR_ANY | OS_OPT_PEND_FLAG_CONSUME:
;;;384            case OS_OPT_PEND_FLAG_SET_ALL | OS_OPT_PEND_FLAG_CONSUME:
;;;385            case OS_OPT_PEND_FLAG_SET_ANY | OS_OPT_PEND_FLAG_CONSUME:
;;;386            case OS_OPT_PEND_FLAG_CLR_ALL | OS_OPT_PEND_NON_BLOCKING:
;;;387            case OS_OPT_PEND_FLAG_CLR_ANY | OS_OPT_PEND_NON_BLOCKING:
;;;388            case OS_OPT_PEND_FLAG_SET_ALL | OS_OPT_PEND_NON_BLOCKING:
;;;389            case OS_OPT_PEND_FLAG_SET_ANY | OS_OPT_PEND_NON_BLOCKING:
;;;390            case OS_OPT_PEND_FLAG_CLR_ALL | OS_OPT_PEND_FLAG_CONSUME | OS_OPT_PEND_NON_BLOCKING:
;;;391            case OS_OPT_PEND_FLAG_CLR_ANY | OS_OPT_PEND_FLAG_CONSUME | OS_OPT_PEND_NON_BLOCKING:
;;;392            case OS_OPT_PEND_FLAG_SET_ALL | OS_OPT_PEND_FLAG_CONSUME | OS_OPT_PEND_NON_BLOCKING:
;;;393            case OS_OPT_PEND_FLAG_SET_ANY | OS_OPT_PEND_FLAG_CONSUME | OS_OPT_PEND_NON_BLOCKING:
;;;394                 break;
;;;395    
;;;396            default:
;;;397    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN > 0u))
;;;398                 TRACE_OS_FLAG_PEND_FAILED(p_grp);              /* Record the event.                                      */
;;;399    #endif
;;;400                *p_err = OS_ERR_OPT_INVALID;
;;;401                 return ((OS_OBJ_QTY)0);
;;;402        }
;;;403    #endif
;;;404    
;;;405    #if OS_CFG_OBJ_TYPE_CHK_EN > 0u
;;;406        if (p_grp->Type != OS_OBJ_TYPE_FLAG) {                  /* Validate that we are pointing at an event flag         */
;;;407    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN > 0u))
;;;408            TRACE_OS_FLAG_PEND_FAILED(p_grp);                   /* Record the event.                                      */
;;;409    #endif
;;;410           *p_err = OS_ERR_OBJ_TYPE;
;;;411            return ((OS_FLAGS)0);
;;;412        }
;;;413    #endif
;;;414    
;;;415        if ((opt & OS_OPT_PEND_FLAG_CONSUME) != (OS_OPT)0) {    /* See if we need to consume the flags                    */
;;;416            consume = DEF_TRUE;
;;;417        } else {
;;;418            consume = DEF_FALSE;
;;;419        }
;;;420    
;;;421        if (p_ts != (CPU_TS *)0) {
;;;422           *p_ts = (CPU_TS)0;                                   /* Initialize the returned timestamp                      */
;;;423        }
;;;424    
;;;425        mode = opt & OS_OPT_PEND_FLAG_MASK;
;;;426        CPU_CRITICAL_ENTER();
;;;427        switch (mode) {
;;;428            case OS_OPT_PEND_FLAG_SET_ALL:                      /* See if all required flags are set                      */
;;;429                 flags_rdy = (OS_FLAGS)(p_grp->Flags & flags);  /* Extract only the bits we want                          */
;;;430                 if (flags_rdy == flags) {                      /* Must match ALL the bits that we want                   */
;;;431                     if (consume == DEF_TRUE) {                 /* See if we need to consume the flags                    */
;;;432                         p_grp->Flags &= ~flags_rdy;            /* Clear ONLY the flags that we wanted                    */
;;;433                     }
;;;434                     OSTCBCurPtr->FlagsRdy = flags_rdy;         /* Save flags that were ready                             */
;;;435                     if (p_ts != (CPU_TS *)0) {
;;;436                        *p_ts  = p_grp->TS;
;;;437                     }
;;;438                     CPU_CRITICAL_EXIT();                       /* Yes, condition met, return to caller                   */
;;;439    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN > 0u))
;;;440                     TRACE_OS_FLAG_PEND(p_grp);                 /* Record the event.                                      */
;;;441    #endif
;;;442                    *p_err = OS_ERR_NONE;
;;;443                     return (flags_rdy);
;;;444                 } else {                                       /* Block task until events occur or timeout               */
;;;445                     if ((opt & OS_OPT_PEND_NON_BLOCKING) != (OS_OPT)0) {
;;;446                         CPU_CRITICAL_EXIT();
;;;447    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN > 0u))
;;;448                         TRACE_OS_FLAG_PEND_FAILED(p_grp);      /* Record the event.                                      */
;;;449    #endif
;;;450                        *p_err = OS_ERR_PEND_WOULD_BLOCK;       /* Specified non-blocking so task would block             */
;;;451                         return ((OS_FLAGS)0);
;;;452                     } else {                                   /* Specified blocking so check is scheduler is locked     */
;;;453                         if (OSSchedLockNestingCtr > (OS_NESTING_CTR)0) { /* See if called with scheduler locked ...      */
;;;454                             CPU_CRITICAL_EXIT();
;;;455    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN > 0u))
;;;456                             TRACE_OS_FLAG_PEND_FAILED(p_grp);  /* Record the event.                                      */
;;;457    #endif
;;;458                            *p_err = OS_ERR_SCHED_LOCKED;       /* ... can't PEND when locked                             */
;;;459                             return ((OS_FLAGS)0);
;;;460                         }
;;;461                     }
;;;462                                                                /* Lock the scheduler/re-enable interrupts                */
;;;463                     OS_CRITICAL_ENTER_CPU_EXIT();              
;;;464                     OS_FlagBlock(&pend_data,
;;;465                                  p_grp,
;;;466                                  flags,
;;;467                                  opt,
;;;468                                  timeout);
;;;469                     OS_CRITICAL_EXIT_NO_SCHED();
;;;470                 }
;;;471                 break;
;;;472    
;;;473            case OS_OPT_PEND_FLAG_SET_ANY:
;;;474                 flags_rdy = (OS_FLAGS)(p_grp->Flags & flags);  /* Extract only the bits we want                          */
;;;475                 if (flags_rdy != (OS_FLAGS)0) {                /* See if any flag set                                    */
;;;476                     if (consume == DEF_TRUE) {                 /* See if we need to consume the flags                    */
;;;477                         p_grp->Flags &= ~flags_rdy;            /* Clear ONLY the flags that we got                       */
;;;478                     }
;;;479                     OSTCBCurPtr->FlagsRdy = flags_rdy;         /* Save flags that were ready                             */
;;;480                     if (p_ts != (CPU_TS *)0) {
;;;481                        *p_ts  = p_grp->TS;
;;;482                     }
;;;483                     CPU_CRITICAL_EXIT();                       /* Yes, condition met, return to caller                   */
;;;484    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN > 0u))
;;;485                     TRACE_OS_FLAG_PEND(p_grp);                 /* Record the event.                                      */
;;;486    #endif
;;;487                    *p_err = OS_ERR_NONE;
;;;488                     return (flags_rdy);
;;;489                 } else {                                       /* Block task until events occur or timeout               */
;;;490                     if ((opt & OS_OPT_PEND_NON_BLOCKING) != (OS_OPT)0) {
;;;491                         CPU_CRITICAL_EXIT();
;;;492                        *p_err = OS_ERR_PEND_WOULD_BLOCK;       /* Specified non-blocking so task would block             */
;;;493                         return ((OS_FLAGS)0);
;;;494                     } else {                                   /* Specified blocking so check is scheduler is locked     */
;;;495                         if (OSSchedLockNestingCtr > (OS_NESTING_CTR)0) { /* See if called with scheduler locked ...      */
;;;496                             CPU_CRITICAL_EXIT();
;;;497                            *p_err = OS_ERR_SCHED_LOCKED;                 /* ... can't PEND when locked                   */
;;;498                             return ((OS_FLAGS)0);
;;;499                         }
;;;500                     }
;;;501                                                                /* Lock the scheduler/re-enable interrupts                */
;;;502                     OS_CRITICAL_ENTER_CPU_EXIT();              
;;;503                     OS_FlagBlock(&pend_data,
;;;504                                  p_grp,
;;;505                                  flags,
;;;506                                  opt,
;;;507                                  timeout);
;;;508                     OS_CRITICAL_EXIT_NO_SCHED();
;;;509                 }
;;;510                 break;
;;;511    
;;;512    #if OS_CFG_FLAG_MODE_CLR_EN > 0u
;;;513            case OS_OPT_PEND_FLAG_CLR_ALL:                      /* See if all required flags are cleared                  */
;;;514                 flags_rdy = (OS_FLAGS)(~p_grp->Flags & flags); /* Extract only the bits we want                          */
;;;515                 if (flags_rdy == flags) {                      /* Must match ALL the bits that we want                   */
;;;516                     if (consume == DEF_TRUE) {                 /* See if we need to consume the flags                    */
;;;517                         p_grp->Flags |= flags_rdy;             /* Set ONLY the flags that we wanted                      */
;;;518                     }
;;;519                     OSTCBCurPtr->FlagsRdy = flags_rdy;         /* Save flags that were ready                             */
;;;520                     if (p_ts != (CPU_TS *)0) {
;;;521                        *p_ts  = p_grp->TS;
;;;522                     }
;;;523                     CPU_CRITICAL_EXIT();                       /* Yes, condition met, return to caller                   */
;;;524    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN > 0u))
;;;525                     TRACE_OS_FLAG_PEND(p_grp);                 /* Record the event.                                      */
;;;526    #endif                 
;;;527                    *p_err = OS_ERR_NONE;
;;;528                     return (flags_rdy);
;;;529                 } else {                                       /* Block task until events occur or timeout               */
;;;530                     if ((opt & OS_OPT_PEND_NON_BLOCKING) != (OS_OPT)0) {
;;;531                         CPU_CRITICAL_EXIT();
;;;532                        *p_err = OS_ERR_PEND_WOULD_BLOCK;       /* Specified non-blocking so task would block             */
;;;533                         return ((OS_FLAGS)0);
;;;534                     } else {                                   /* Specified blocking so check is scheduler is locked     */
;;;535                         if (OSSchedLockNestingCtr > (OS_NESTING_CTR)0) { /* See if called with scheduler locked ...      */
;;;536                             CPU_CRITICAL_EXIT();
;;;537                            *p_err = OS_ERR_SCHED_LOCKED;                 /* ... can't PEND when locked                   */
;;;538                             return ((OS_FLAGS)0);
;;;539                         }
;;;540                     }
;;;541                                                                
;;;542                     OS_CRITICAL_ENTER_CPU_EXIT();              /* Lock the scheduler/re-enable interrupts                */
;;;543                     OS_FlagBlock(&pend_data,
;;;544                                  p_grp,
;;;545                                  flags,
;;;546                                  opt,
;;;547                                  timeout);
;;;548                     OS_CRITICAL_EXIT_NO_SCHED();
;;;549                 }
;;;550                 break;
;;;551    
;;;552            case OS_OPT_PEND_FLAG_CLR_ANY:
;;;553                 flags_rdy = (OS_FLAGS)(~p_grp->Flags & flags); /* Extract only the bits we want                          */
;;;554                 if (flags_rdy != (OS_FLAGS)0) {                /* See if any flag cleared                                */
;;;555                     if (consume == DEF_TRUE) {                 /* See if we need to consume the flags                    */
;;;556                         p_grp->Flags |= flags_rdy;             /* Set ONLY the flags that we got                         */
;;;557                     }
;;;558                     OSTCBCurPtr->FlagsRdy = flags_rdy;         /* Save flags that were ready                             */
;;;559                     if (p_ts != (CPU_TS *)0) {
;;;560                        *p_ts  = p_grp->TS;
;;;561                     }
;;;562                     CPU_CRITICAL_EXIT();                       /* Yes, condition met, return to caller                   */
;;;563    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN > 0u))
;;;564                     TRACE_OS_FLAG_PEND(p_grp);                 /* Record the event.                                      */
;;;565    #endif
;;;566                    *p_err = OS_ERR_NONE;
;;;567                     return (flags_rdy);
;;;568                 } else {                                       /* Block task until events occur or timeout               */
;;;569                     if ((opt & OS_OPT_PEND_NON_BLOCKING) != (OS_OPT)0) {
;;;570                         CPU_CRITICAL_EXIT();
;;;571                        *p_err = OS_ERR_PEND_WOULD_BLOCK;       /* Specified non-blocking so task would block             */
;;;572                         return ((OS_FLAGS)0);
;;;573                     } else {                                   /* Specified blocking so check is scheduler is locked     */
;;;574                         if (OSSchedLockNestingCtr > (OS_NESTING_CTR)0) { /* See if called with scheduler locked ...      */
;;;575                             CPU_CRITICAL_EXIT();
;;;576                            *p_err = OS_ERR_SCHED_LOCKED;                 /* ... can't PEND when locked                   */
;;;577                             return ((OS_FLAGS)0);
;;;578                         }
;;;579                     }
;;;580                                                                
;;;581                     OS_CRITICAL_ENTER_CPU_EXIT();              /* Lock the scheduler/re-enable interrupts                */
;;;582                     OS_FlagBlock(&pend_data,              
;;;583                                  p_grp,
;;;584                                  flags,
;;;585                                  opt,
;;;586                                  timeout);
;;;587                     OS_CRITICAL_EXIT_NO_SCHED();
;;;588                 }
;;;589                 break;
;;;590    #endif
;;;591    
;;;592            default:
;;;593                 CPU_CRITICAL_EXIT();
;;;594    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN > 0u))
;;;595                 TRACE_OS_FLAG_PEND_FAILED(p_grp);              /* Record the event.                                      */
;;;596    #endif
;;;597                *p_err = OS_ERR_OPT_INVALID;
;;;598                 return ((OS_FLAGS)0);
;;;599        }
;;;600    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN > 0u))
;;;601        TRACE_OS_FLAG_PEND_BLOCK(p_grp);                        /* Record the event.                                      */
;;;602    #endif
;;;603        OSSched();                                              /* Find next HPT ready to run                             */
;;;604    
;;;605        CPU_CRITICAL_ENTER();
;;;606        switch (OSTCBCurPtr->PendStatus) {
;;;607            case OS_STATUS_PEND_OK:                             /* We got the event flags                                 */
;;;608                 if (p_ts != (CPU_TS *)0) {
;;;609                    *p_ts  = OSTCBCurPtr->TS;
;;;610                 }
;;;611    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN > 0u))
;;;612                 TRACE_OS_FLAG_PEND(p_grp);                     /* Record the event.                                      */
;;;613    #endif
;;;614                *p_err = OS_ERR_NONE;
;;;615                 break;
;;;616    
;;;617            case OS_STATUS_PEND_ABORT:                          /* Indicate that we aborted                               */
;;;618                 if (p_ts != (CPU_TS *)0) {
;;;619                    *p_ts  = OSTCBCurPtr->TS;
;;;620                 }
;;;621                 CPU_CRITICAL_EXIT();
;;;622    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN > 0u))
;;;623                 TRACE_OS_FLAG_PEND_FAILED(p_grp);              /* Record the event.                                      */
;;;624    #endif
;;;625                *p_err = OS_ERR_PEND_ABORT;
;;;626                 break;
;;;627    
;;;628            case OS_STATUS_PEND_TIMEOUT:                        /* Indicate that we didn't get semaphore within timeout   */
;;;629                 if (p_ts != (CPU_TS *)0) {
;;;630                    *p_ts  = (CPU_TS  )0;
;;;631                 }
;;;632                 CPU_CRITICAL_EXIT();
;;;633    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN > 0u))
;;;634                 TRACE_OS_FLAG_PEND_FAILED(p_grp);              /* Record the event.                                      */
;;;635    #endif
;;;636                *p_err = OS_ERR_TIMEOUT;
;;;637                 break;
;;;638    
;;;639            case OS_STATUS_PEND_DEL:                            /* Indicate that object pended on has been deleted        */
;;;640                 if (p_ts != (CPU_TS *)0) {
;;;641                    *p_ts  = OSTCBCurPtr->TS;
;;;642                 }
;;;643                 CPU_CRITICAL_EXIT();
;;;644    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN > 0u))
;;;645                 TRACE_OS_FLAG_PEND_FAILED(p_grp);              /* Record the event.                                      */
;;;646    #endif
;;;647                *p_err = OS_ERR_OBJ_DEL;
;;;648                 break;
;;;649    
;;;650            default:
;;;651                 CPU_CRITICAL_EXIT();
;;;652    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN > 0u))
;;;653                 TRACE_OS_FLAG_PEND_FAILED(p_grp);              /* Record the event.                                      */
;;;654    #endif
;;;655                *p_err = OS_ERR_STATUS_INVALID;
;;;656                 break;
;;;657        }
;;;658        if (*p_err != OS_ERR_NONE) {
;;;659            return ((OS_FLAGS)0);
;;;660        }
;;;661    
;;;662        flags_rdy = OSTCBCurPtr->FlagsRdy;
;;;663        if (consume == DEF_TRUE) {                              /* See if we need to consume the flags                    */
;;;664            switch (mode) {
;;;665                case OS_OPT_PEND_FLAG_SET_ALL:
;;;666                case OS_OPT_PEND_FLAG_SET_ANY:                  /* Clear ONLY the flags we got                            */
;;;667                     p_grp->Flags &= ~flags_rdy;
;;;668                     break;
;;;669    
;;;670    #if OS_CFG_FLAG_MODE_CLR_EN > 0u
;;;671                case OS_OPT_PEND_FLAG_CLR_ALL:
;;;672                case OS_OPT_PEND_FLAG_CLR_ANY:                  /* Set   ONLY the flags we got                            */
;;;673                     p_grp->Flags |=  flags_rdy;
;;;674                     break;
;;;675    #endif
;;;676                default:
;;;677                     CPU_CRITICAL_EXIT();
;;;678                    *p_err = OS_ERR_OPT_INVALID;
;;;679                     return ((OS_FLAGS)0);
;;;680            }
;;;681        }
;;;682        CPU_CRITICAL_EXIT();
;;;683       *p_err = OS_ERR_NONE;                                    /* Event(s) must have occurred                            */
;;;684        return (flags_rdy);
;;;685    }
000020  b00b              ADD      sp,sp,#0x2c
000022  e8bd8ff0          POP      {r4-r11,pc}
                  |L3.38|
000026  f2480101          MOV      r1,#0x8001            ;377
00002a  eba90001          SUB      r0,r9,r1              ;377
00002e  4589              CMP      r9,r1                 ;377
000030  d036              BEQ      |L3.160|
000032  dc1a              BGT      |L3.106|
000034  f2401101          MOV      r1,#0x101             ;377
000038  eba90001          SUB      r0,r9,r1              ;377
00003c  4589              CMP      r9,r1                 ;377
00003e  d02b              BEQ      |L3.152|
000040  dc0c              BGT      |L3.92|
000042  f1b90f01          CMP      r9,#1                 ;377
000046  d023              BEQ      |L3.144|
000048  f1b90f02          CMP      r9,#2                 ;377
00004c  d021              BEQ      |L3.146|
00004e  f1b90f04          CMP      r9,#4                 ;377
000052  d01f              BEQ      |L3.148|
000054  f1b90f08          CMP      r9,#8                 ;377
000058  d12a              BNE      |L3.176|
00005a  e01c              B        |L3.150|
                  |L3.92|
00005c  2801              CMP      r0,#1                 ;377
00005e  d01c              BEQ      |L3.154|
000060  2803              CMP      r0,#3                 ;377
000062  d01b              BEQ      |L3.156|
000064  2807              CMP      r0,#7                 ;377
000066  d123              BNE      |L3.176|
000068  e019              B        |L3.158|
                  |L3.106|
00006a  f5b07f80          CMP      r0,#0x100             ;377
00006e  d01b              BEQ      |L3.168|
000070  dc06              BGT      |L3.128|
000072  2801              CMP      r0,#1                 ;377
000074  d015              BEQ      |L3.162|
000076  2803              CMP      r0,#3                 ;377
000078  d014              BEQ      |L3.164|
00007a  2807              CMP      r0,#7                 ;377
00007c  d118              BNE      |L3.176|
00007e  e012              B        |L3.166|
                  |L3.128|
000080  f2a01001          SUB      r0,r0,#0x101          ;377
000084  b188              CBZ      r0,|L3.170|
000086  2802              CMP      r0,#2                 ;377
000088  d010              BEQ      |L3.172|
00008a  2806              CMP      r0,#6                 ;377
00008c  d110              BNE      |L3.176|
00008e  e00e              B        |L3.174|
                  |L3.144|
000090  bf00              NOP                            ;379
                  |L3.146|
000092  bf00              NOP                            ;380
                  |L3.148|
000094  bf00              NOP                            ;381
                  |L3.150|
000096  bf00              NOP                            ;382
                  |L3.152|
000098  bf00              NOP                            ;383
                  |L3.154|
00009a  bf00              NOP                            ;384
                  |L3.156|
00009c  bf00              NOP                            ;385
                  |L3.158|
00009e  bf00              NOP                            ;386
                  |L3.160|
0000a0  bf00              NOP                            ;387
                  |L3.162|
0000a2  bf00              NOP                            ;388
                  |L3.164|
0000a4  bf00              NOP                            ;389
                  |L3.166|
0000a6  bf00              NOP                            ;390
                  |L3.168|
0000a8  bf00              NOP                            ;391
                  |L3.170|
0000aa  bf00              NOP                            ;392
                  |L3.172|
0000ac  bf00              NOP                            ;393
                  |L3.174|
0000ae  e004              B        |L3.186|
                  |L3.176|
0000b0  f6456025          MOV      r0,#0x5e25            ;400
0000b4  8028              STRH     r0,[r5,#0]            ;400
0000b6  2000              MOVS     r0,#0                 ;401
0000b8  e7b2              B        |L3.32|
                  |L3.186|
0000ba  bf00              NOP                            ;394
0000bc  49f9              LDR      r1,|L3.1188|
0000be  6820              LDR      r0,[r4,#0]            ;406
0000c0  4288              CMP      r0,r1                 ;406
0000c2  d004              BEQ      |L3.206|
0000c4  f64550c4          MOV      r0,#0x5dc4            ;410
0000c8  8028              STRH     r0,[r5,#0]            ;410
0000ca  2000              MOVS     r0,#0                 ;411
0000cc  e7a8              B        |L3.32|
                  |L3.206|
0000ce  f4097080          AND      r0,r9,#0x100          ;415
0000d2  b110              CBZ      r0,|L3.218|
0000d4  f04f0a01          MOV      r10,#1                ;416
0000d8  e001              B        |L3.222|
                  |L3.218|
0000da  f04f0a00          MOV      r10,#0                ;418
                  |L3.222|
0000de  b10f              CBZ      r7,|L3.228|
0000e0  2000              MOVS     r0,#0                 ;422
0000e2  6038              STR      r0,[r7,#0]            ;422
                  |L3.228|
0000e4  f009000f          AND      r0,r9,#0xf            ;425
0000e8  900a              STR      r0,[sp,#0x28]         ;425
0000ea  bf00              NOP                            ;426
0000ec  bf00              NOP                            ;426
0000ee  f7fffffe          BL       CPU_SR_Save
0000f2  9001              STR      r0,[sp,#4]            ;426
0000f4  bf00              NOP                            ;426
0000f6  bf00              NOP                            ;426
0000f8  980a              LDR      r0,[sp,#0x28]         ;427
0000fa  2801              CMP      r0,#1                 ;427
0000fc  d07d              BEQ      |L3.506|
0000fe  2802              CMP      r0,#2                 ;427
000100  d07c              BEQ      |L3.508|
000102  2804              CMP      r0,#4                 ;427
000104  d002              BEQ      |L3.268|
000106  2808              CMP      r0,#8                 ;427
000108  d179              BNE      |L3.510|
00010a  e04b              B        |L3.420|
                  |L3.268|
00010c  6a20              LDR      r0,[r4,#0x20]         ;429
00010e  ea000608          AND      r6,r0,r8              ;429
000112  4546              CMP      r6,r8                 ;430
000114  d117              BNE      |L3.326|
000116  f1ba0f01          CMP      r10,#1                ;431
00011a  d102              BNE      |L3.290|
00011c  6a20              LDR      r0,[r4,#0x20]         ;432
00011e  43b0              BICS     r0,r0,r6              ;432
000120  6220              STR      r0,[r4,#0x20]         ;432
                  |L3.290|
000122  48e1              LDR      r0,|L3.1192|
000124  6800              LDR      r0,[r0,#0]            ;434  ; OSTCBCurPtr
000126  f8c06080          STR      r6,[r0,#0x80]         ;434
00012a  b10f              CBZ      r7,|L3.304|
00012c  6a60              LDR      r0,[r4,#0x24]         ;436
00012e  6038              STR      r0,[r7,#0]            ;436
                  |L3.304|
000130  bf00              NOP                            ;438
000132  bf00              NOP                            ;438
000134  9801              LDR      r0,[sp,#4]            ;438
000136  f7fffffe          BL       CPU_SR_Restore
00013a  bf00              NOP                            ;438
00013c  bf00              NOP                            ;438
00013e  2000              MOVS     r0,#0                 ;442
000140  8028              STRH     r0,[r5,#0]            ;442
000142  4630              MOV      r0,r6                 ;443
000144  e76c              B        |L3.32|
                  |L3.326|
000146  f4094000          AND      r0,r9,#0x8000         ;445
00014a  b158              CBZ      r0,|L3.356|
00014c  bf00              NOP                            ;446
00014e  bf00              NOP                            ;446
000150  9801              LDR      r0,[sp,#4]            ;446
000152  f7fffffe          BL       CPU_SR_Restore
000156  bf00              NOP                            ;446
000158  bf00              NOP                            ;446
00015a  f24610b0          MOV      r0,#0x61b0            ;450
00015e  8028              STRH     r0,[r5,#0]            ;450
000160  2000              MOVS     r0,#0                 ;451
000162  e75d              B        |L3.32|
                  |L3.356|
000164  48d1              LDR      r0,|L3.1196|
000166  7800              LDRB     r0,[r0,#0]            ;453  ; OSSchedLockNestingCtr
000168  2800              CMP      r0,#0                 ;453
00016a  dd0b              BLE      |L3.388|
00016c  bf00              NOP                            ;454
00016e  bf00              NOP                            ;454
000170  9801              LDR      r0,[sp,#4]            ;454
000172  f7fffffe          BL       CPU_SR_Restore
000176  bf00              NOP                            ;454
000178  bf00              NOP                            ;454
00017a  f6465063          MOV      r0,#0x6d63            ;458
00017e  8028              STRH     r0,[r5,#0]            ;458
000180  2000              MOVS     r0,#0                 ;459
000182  e74d              B        |L3.32|
                  |L3.388|
000184  464b              MOV      r3,r9                 ;464
000186  4642              MOV      r2,r8                 ;464
000188  4621              MOV      r1,r4                 ;464
00018a  a802              ADD      r0,sp,#8              ;464
00018c  f8cdb000          STR      r11,[sp,#0]           ;464
000190  f7fffffe          BL       OS_FlagBlock
000194  bf00              NOP                            ;469
000196  bf00              NOP                            ;469
000198  9801              LDR      r0,[sp,#4]            ;469
00019a  f7fffffe          BL       CPU_SR_Restore
00019e  bf00              NOP                            ;469
0001a0  bf00              NOP                            ;469
0001a2  e0f0              B        |L3.902|
                  |L3.420|
0001a4  6a20              LDR      r0,[r4,#0x20]         ;474
0001a6  ea000608          AND      r6,r0,r8              ;474
0001aa  b1be              CBZ      r6,|L3.476|
0001ac  f1ba0f01          CMP      r10,#1                ;476
0001b0  d102              BNE      |L3.440|
0001b2  6a20              LDR      r0,[r4,#0x20]         ;477
0001b4  43b0              BICS     r0,r0,r6              ;477
0001b6  6220              STR      r0,[r4,#0x20]         ;477
                  |L3.440|
0001b8  48bb              LDR      r0,|L3.1192|
0001ba  6800              LDR      r0,[r0,#0]            ;479  ; OSTCBCurPtr
0001bc  f8c06080          STR      r6,[r0,#0x80]         ;479
0001c0  b10f              CBZ      r7,|L3.454|
0001c2  6a60              LDR      r0,[r4,#0x24]         ;481
0001c4  6038              STR      r0,[r7,#0]            ;481
                  |L3.454|
0001c6  bf00              NOP                            ;483
0001c8  bf00              NOP                            ;483
0001ca  9801              LDR      r0,[sp,#4]            ;483
0001cc  f7fffffe          BL       CPU_SR_Restore
0001d0  bf00              NOP                            ;483
0001d2  bf00              NOP                            ;483
0001d4  2000              MOVS     r0,#0                 ;487
0001d6  8028              STRH     r0,[r5,#0]            ;487
0001d8  4630              MOV      r0,r6                 ;488
0001da  e721              B        |L3.32|
                  |L3.476|
0001dc  f4094000          AND      r0,r9,#0x8000         ;490
0001e0  b170              CBZ      r0,|L3.512|
0001e2  bf00              NOP                            ;491
0001e4  bf00              NOP                            ;491
0001e6  9801              LDR      r0,[sp,#4]            ;491
0001e8  f7fffffe          BL       CPU_SR_Restore
0001ec  bf00              NOP                            ;491
0001ee  bf00              NOP                            ;491
0001f0  f24610b0          MOV      r0,#0x61b0            ;492
0001f4  8028              STRH     r0,[r5,#0]            ;492
0001f6  2000              MOVS     r0,#0                 ;493
0001f8  e712              B        |L3.32|
                  |L3.506|
0001fa  e021              B        |L3.576|
                  |L3.508|
0001fc  e06c              B        |L3.728|
                  |L3.510|
0001fe  e0b6              B        |L3.878|
                  |L3.512|
000200  48aa              LDR      r0,|L3.1196|
000202  7800              LDRB     r0,[r0,#0]            ;495  ; OSSchedLockNestingCtr
000204  2800              CMP      r0,#0                 ;495
000206  dd0b              BLE      |L3.544|
000208  bf00              NOP                            ;496
00020a  bf00              NOP                            ;496
00020c  9801              LDR      r0,[sp,#4]            ;496
00020e  f7fffffe          BL       CPU_SR_Restore
000212  bf00              NOP                            ;496
000214  bf00              NOP                            ;496
000216  f6465063          MOV      r0,#0x6d63            ;497
00021a  8028              STRH     r0,[r5,#0]            ;497
00021c  2000              MOVS     r0,#0                 ;498
00021e  e6ff              B        |L3.32|
                  |L3.544|
000220  464b              MOV      r3,r9                 ;503
000222  4642              MOV      r2,r8                 ;503
000224  4621              MOV      r1,r4                 ;503
000226  a802              ADD      r0,sp,#8              ;503
000228  f8cdb000          STR      r11,[sp,#0]           ;503
00022c  f7fffffe          BL       OS_FlagBlock
000230  bf00              NOP                            ;508
000232  bf00              NOP                            ;508
000234  9801              LDR      r0,[sp,#4]            ;508
000236  f7fffffe          BL       CPU_SR_Restore
00023a  bf00              NOP                            ;508
00023c  bf00              NOP                            ;508
00023e  e0a2              B        |L3.902|
                  |L3.576|
000240  6a20              LDR      r0,[r4,#0x20]         ;514
000242  ea280600          BIC      r6,r8,r0              ;514
000246  4546              CMP      r6,r8                 ;515
000248  d117              BNE      |L3.634|
00024a  f1ba0f01          CMP      r10,#1                ;516
00024e  d102              BNE      |L3.598|
000250  6a20              LDR      r0,[r4,#0x20]         ;517
000252  4330              ORRS     r0,r0,r6              ;517
000254  6220              STR      r0,[r4,#0x20]         ;517
                  |L3.598|
000256  4894              LDR      r0,|L3.1192|
000258  6800              LDR      r0,[r0,#0]            ;519  ; OSTCBCurPtr
00025a  f8c06080          STR      r6,[r0,#0x80]         ;519
00025e  b10f              CBZ      r7,|L3.612|
000260  6a60              LDR      r0,[r4,#0x24]         ;521
000262  6038              STR      r0,[r7,#0]            ;521
                  |L3.612|
000264  bf00              NOP                            ;523
000266  bf00              NOP                            ;523
000268  9801              LDR      r0,[sp,#4]            ;523
00026a  f7fffffe          BL       CPU_SR_Restore
00026e  bf00              NOP                            ;523
000270  bf00              NOP                            ;523
000272  2000              MOVS     r0,#0                 ;527
000274  8028              STRH     r0,[r5,#0]            ;527
000276  4630              MOV      r0,r6                 ;528
000278  e6d2              B        |L3.32|
                  |L3.634|
00027a  f4094000          AND      r0,r9,#0x8000         ;530
00027e  b158              CBZ      r0,|L3.664|
000280  bf00              NOP                            ;531
000282  bf00              NOP                            ;531
000284  9801              LDR      r0,[sp,#4]            ;531
000286  f7fffffe          BL       CPU_SR_Restore
00028a  bf00              NOP                            ;531
00028c  bf00              NOP                            ;531
00028e  f24610b0          MOV      r0,#0x61b0            ;532
000292  8028              STRH     r0,[r5,#0]            ;532
000294  2000              MOVS     r0,#0                 ;533
000296  e6c3              B        |L3.32|
                  |L3.664|
000298  4884              LDR      r0,|L3.1196|
00029a  7800              LDRB     r0,[r0,#0]            ;535  ; OSSchedLockNestingCtr
00029c  2800              CMP      r0,#0                 ;535
00029e  dd0b              BLE      |L3.696|
0002a0  bf00              NOP                            ;536
0002a2  bf00              NOP                            ;536
0002a4  9801              LDR      r0,[sp,#4]            ;536
0002a6  f7fffffe          BL       CPU_SR_Restore
0002aa  bf00              NOP                            ;536
0002ac  bf00              NOP                            ;536
0002ae  f6465063          MOV      r0,#0x6d63            ;537
0002b2  8028              STRH     r0,[r5,#0]            ;537
0002b4  2000              MOVS     r0,#0                 ;538
0002b6  e6b3              B        |L3.32|
                  |L3.696|
0002b8  464b              MOV      r3,r9                 ;543
0002ba  4642              MOV      r2,r8                 ;543
0002bc  4621              MOV      r1,r4                 ;543
0002be  a802              ADD      r0,sp,#8              ;543
0002c0  f8cdb000          STR      r11,[sp,#0]           ;543
0002c4  f7fffffe          BL       OS_FlagBlock
0002c8  bf00              NOP                            ;548
0002ca  bf00              NOP                            ;548
0002cc  9801              LDR      r0,[sp,#4]            ;548
0002ce  f7fffffe          BL       CPU_SR_Restore
0002d2  bf00              NOP                            ;548
0002d4  bf00              NOP                            ;548
0002d6  e056              B        |L3.902|
                  |L3.728|
0002d8  6a20              LDR      r0,[r4,#0x20]         ;553
0002da  ea280600          BIC      r6,r8,r0              ;553
0002de  b1be              CBZ      r6,|L3.784|
0002e0  f1ba0f01          CMP      r10,#1                ;555
0002e4  d102              BNE      |L3.748|
0002e6  6a20              LDR      r0,[r4,#0x20]         ;556
0002e8  4330              ORRS     r0,r0,r6              ;556
0002ea  6220              STR      r0,[r4,#0x20]         ;556
                  |L3.748|
0002ec  486e              LDR      r0,|L3.1192|
0002ee  6800              LDR      r0,[r0,#0]            ;558  ; OSTCBCurPtr
0002f0  f8c06080          STR      r6,[r0,#0x80]         ;558
0002f4  b10f              CBZ      r7,|L3.762|
0002f6  6a60              LDR      r0,[r4,#0x24]         ;560
0002f8  6038              STR      r0,[r7,#0]            ;560
                  |L3.762|
0002fa  bf00              NOP                            ;562
0002fc  bf00              NOP                            ;562
0002fe  9801              LDR      r0,[sp,#4]            ;562
000300  f7fffffe          BL       CPU_SR_Restore
000304  bf00              NOP                            ;562
000306  bf00              NOP                            ;562
000308  2000              MOVS     r0,#0                 ;566
00030a  8028              STRH     r0,[r5,#0]            ;566
00030c  4630              MOV      r0,r6                 ;567
00030e  e687              B        |L3.32|
                  |L3.784|
000310  f4094000          AND      r0,r9,#0x8000         ;569
000314  b158              CBZ      r0,|L3.814|
000316  bf00              NOP                            ;570
000318  bf00              NOP                            ;570
00031a  9801              LDR      r0,[sp,#4]            ;570
00031c  f7fffffe          BL       CPU_SR_Restore
000320  bf00              NOP                            ;570
000322  bf00              NOP                            ;570
000324  f24610b0          MOV      r0,#0x61b0            ;571
000328  8028              STRH     r0,[r5,#0]            ;571
00032a  2000              MOVS     r0,#0                 ;572
00032c  e678              B        |L3.32|
                  |L3.814|
00032e  485f              LDR      r0,|L3.1196|
000330  7800              LDRB     r0,[r0,#0]            ;574  ; OSSchedLockNestingCtr
000332  2800              CMP      r0,#0                 ;574
000334  dd0b              BLE      |L3.846|
000336  bf00              NOP                            ;575
000338  bf00              NOP                            ;575
00033a  9801              LDR      r0,[sp,#4]            ;575
00033c  f7fffffe          BL       CPU_SR_Restore
000340  bf00              NOP                            ;575
000342  bf00              NOP                            ;575
000344  f6465063          MOV      r0,#0x6d63            ;576
000348  8028              STRH     r0,[r5,#0]            ;576
00034a  2000              MOVS     r0,#0                 ;577
00034c  e668              B        |L3.32|
                  |L3.846|
00034e  464b              MOV      r3,r9                 ;582
000350  4642              MOV      r2,r8                 ;582
000352  4621              MOV      r1,r4                 ;582
000354  a802              ADD      r0,sp,#8              ;582
000356  f8cdb000          STR      r11,[sp,#0]           ;582
00035a  f7fffffe          BL       OS_FlagBlock
00035e  bf00              NOP                            ;587
000360  bf00              NOP                            ;587
000362  9801              LDR      r0,[sp,#4]            ;587
000364  f7fffffe          BL       CPU_SR_Restore
000368  bf00              NOP                            ;587
00036a  bf00              NOP                            ;587
00036c  e00b              B        |L3.902|
                  |L3.878|
00036e  bf00              NOP                            ;593
000370  bf00              NOP                            ;593
000372  9801              LDR      r0,[sp,#4]            ;593
000374  f7fffffe          BL       CPU_SR_Restore
000378  bf00              NOP                            ;593
00037a  bf00              NOP                            ;593
00037c  f6456025          MOV      r0,#0x5e25            ;597
000380  8028              STRH     r0,[r5,#0]            ;597
000382  2000              MOVS     r0,#0                 ;598
000384  e64c              B        |L3.32|
                  |L3.902|
000386  bf00              NOP                            ;471
000388  f7fffffe          BL       OSSched
00038c  bf00              NOP                            ;605
00038e  bf00              NOP                            ;605
000390  f7fffffe          BL       CPU_SR_Save
000394  9001              STR      r0,[sp,#4]            ;605
000396  bf00              NOP                            ;605
000398  bf00              NOP                            ;605
00039a  4843              LDR      r0,|L3.1192|
00039c  6800              LDR      r0,[r0,#0]            ;606  ; OSTCBCurPtr
00039e  f8900035          LDRB     r0,[r0,#0x35]         ;606
0003a2  b130              CBZ      r0,|L3.946|
0003a4  2801              CMP      r0,#1                 ;606
0003a6  d00c              BEQ      |L3.962|
0003a8  2802              CMP      r0,#2                 ;606
0003aa  d028              BEQ      |L3.1022|
0003ac  2803              CMP      r0,#3                 ;606
0003ae  d136              BNE      |L3.1054|
0003b0  e017              B        |L3.994|
                  |L3.946|
0003b2  b11f              CBZ      r7,|L3.956|
0003b4  483c              LDR      r0,|L3.1192|
0003b6  6800              LDR      r0,[r0,#0]            ;609  ; OSTCBCurPtr
0003b8  6c80              LDR      r0,[r0,#0x48]         ;609
0003ba  6038              STR      r0,[r7,#0]            ;609
                  |L3.956|
0003bc  2000              MOVS     r0,#0                 ;614
0003be  8028              STRH     r0,[r5,#0]            ;614
0003c0  e038              B        |L3.1076|
                  |L3.962|
0003c2  b11f              CBZ      r7,|L3.972|
0003c4  4838              LDR      r0,|L3.1192|
0003c6  6800              LDR      r0,[r0,#0]            ;619  ; OSTCBCurPtr
0003c8  6c80              LDR      r0,[r0,#0x48]         ;619
0003ca  6038              STR      r0,[r7,#0]            ;619
                  |L3.972|
0003cc  bf00              NOP                            ;621
0003ce  bf00              NOP                            ;621
0003d0  9801              LDR      r0,[sp,#4]            ;621
0003d2  f7fffffe          BL       CPU_SR_Restore
0003d6  bf00              NOP                            ;621
0003d8  bf00              NOP                            ;621
0003da  f24610a9          MOV      r0,#0x61a9            ;625
0003de  8028              STRH     r0,[r5,#0]            ;625
0003e0  e028              B        |L3.1076|
                  |L3.994|
0003e2  b10f              CBZ      r7,|L3.1000|
0003e4  2000              MOVS     r0,#0                 ;630
0003e6  6038              STR      r0,[r7,#0]            ;630
                  |L3.1000|
0003e8  bf00              NOP                            ;632
0003ea  bf00              NOP                            ;632
0003ec  9801              LDR      r0,[sp,#4]            ;632
0003ee  f7fffffe          BL       CPU_SR_Restore
0003f2  bf00              NOP                            ;632
0003f4  bf00              NOP                            ;632
0003f6  f24720d9          MOV      r0,#0x72d9            ;636
0003fa  8028              STRH     r0,[r5,#0]            ;636
0003fc  e01a              B        |L3.1076|
                  |L3.1022|
0003fe  b11f              CBZ      r7,|L3.1032|
000400  4829              LDR      r0,|L3.1192|
000402  6800              LDR      r0,[r0,#0]            ;641  ; OSTCBCurPtr
000404  6c80              LDR      r0,[r0,#0x48]         ;641
000406  6038              STR      r0,[r7,#0]            ;641
                  |L3.1032|
000408  bf00              NOP                            ;643
00040a  bf00              NOP                            ;643
00040c  9801              LDR      r0,[sp,#4]            ;643
00040e  f7fffffe          BL       CPU_SR_Restore
000412  bf00              NOP                            ;643
000414  bf00              NOP                            ;643
000416  f64550c2          MOV      r0,#0x5dc2            ;647
00041a  8028              STRH     r0,[r5,#0]            ;647
00041c  e00a              B        |L3.1076|
                  |L3.1054|
00041e  bf00              NOP                            ;651
000420  bf00              NOP                            ;651
000422  9801              LDR      r0,[sp,#4]            ;651
000424  f7fffffe          BL       CPU_SR_Restore
000428  bf00              NOP                            ;651
00042a  bf00              NOP                            ;651
00042c  f646602e          MOV      r0,#0x6e2e            ;655
000430  8028              STRH     r0,[r5,#0]            ;655
000432  bf00              NOP                            ;656
                  |L3.1076|
000434  bf00              NOP                            ;615
000436  8828              LDRH     r0,[r5,#0]            ;658
000438  b108              CBZ      r0,|L3.1086|
00043a  2000              MOVS     r0,#0                 ;659
00043c  e5f0              B        |L3.32|
                  |L3.1086|
00043e  481a              LDR      r0,|L3.1192|
000440  6800              LDR      r0,[r0,#0]            ;662  ; OSTCBCurPtr
000442  f8d06080          LDR      r6,[r0,#0x80]         ;662
000446  f1ba0f01          CMP      r10,#1                ;663
00044a  d120              BNE      |L3.1166|
00044c  980a              LDR      r0,[sp,#0x28]         ;664
00044e  2801              CMP      r0,#1                 ;664
000450  d00b              BEQ      |L3.1130|
000452  2802              CMP      r0,#2                 ;664
000454  d00a              BEQ      |L3.1132|
000456  2804              CMP      r0,#4                 ;664
000458  d002              BEQ      |L3.1120|
00045a  2808              CMP      r0,#8                 ;664
00045c  d10a              BNE      |L3.1140|
00045e  e000              B        |L3.1122|
                  |L3.1120|
000460  bf00              NOP                            ;666
                  |L3.1122|
000462  6a20              LDR      r0,[r4,#0x20]         ;667
000464  43b0              BICS     r0,r0,r6              ;667
000466  6220              STR      r0,[r4,#0x20]         ;667
000468  e010              B        |L3.1164|
                  |L3.1130|
00046a  bf00              NOP                            ;672
                  |L3.1132|
00046c  6a20              LDR      r0,[r4,#0x20]         ;673
00046e  4330              ORRS     r0,r0,r6              ;673
000470  6220              STR      r0,[r4,#0x20]         ;673
000472  e00b              B        |L3.1164|
                  |L3.1140|
000474  bf00              NOP                            ;677
000476  bf00              NOP                            ;677
000478  9801              LDR      r0,[sp,#4]            ;677
00047a  f7fffffe          BL       CPU_SR_Restore
00047e  bf00              NOP                            ;677
000480  bf00              NOP                            ;677
000482  f6456025          MOV      r0,#0x5e25            ;678
000486  8028              STRH     r0,[r5,#0]            ;678
000488  2000              MOVS     r0,#0                 ;679
00048a  e5c9              B        |L3.32|
                  |L3.1164|
00048c  bf00              NOP                            ;668
                  |L3.1166|
00048e  bf00              NOP                            ;682
000490  bf00              NOP                            ;682
000492  9801              LDR      r0,[sp,#4]            ;682
000494  f7fffffe          BL       CPU_SR_Restore
000498  bf00              NOP                            ;682
00049a  bf00              NOP                            ;682
00049c  2000              MOVS     r0,#0                 ;683
00049e  8028              STRH     r0,[r5,#0]            ;683
0004a0  4630              MOV      r0,r6                 ;684
0004a2  e5bd              B        |L3.32|
                  |L3.1188|
                          DCD      0x47414c46
                  |L3.1192|
                          DCD      OSTCBCurPtr
                  |L3.1196|
                          DCD      OSSchedLockNestingCtr
                          ENDP


                          AREA ||i.OSFlagPendAbort||, CODE, READONLY, ALIGN=2

                  OSFlagPendAbort PROC
;;;721    #if OS_CFG_FLAG_PEND_ABORT_EN > 0u
;;;722    OS_OBJ_QTY  OSFlagPendAbort (OS_FLAG_GRP  *p_grp,
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;723                                 OS_OPT        opt,
;;;724                                 OS_ERR       *p_err)
;;;725    {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4614              MOV      r4,r2
;;;726        OS_PEND_LIST  *p_pend_list;
;;;727        OS_TCB        *p_tcb;
;;;728        CPU_TS         ts;
;;;729        OS_OBJ_QTY     nbr_tasks;
;;;730        CPU_SR_ALLOC();
00000a  f04f0a00          MOV      r10,#0
;;;731    
;;;732    
;;;733    
;;;734    #ifdef OS_SAFETY_CRITICAL
;;;735        if (p_err == (OS_ERR *)0) {
;;;736            OS_SAFETY_CRITICAL_EXCEPTION();
;;;737            return ((OS_OBJ_QTY)0u);
;;;738        }
;;;739    #endif
;;;740    
;;;741    #if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
;;;742        if (OSIntNestingCtr > (OS_NESTING_CTR)0u) {             /* Not allowed to Pend Abort from an ISR                  */
;;;743           *p_err = OS_ERR_PEND_ABORT_ISR;
;;;744            return ((OS_OBJ_QTY)0u);
;;;745        }
;;;746    #endif
;;;747    
;;;748    #if OS_CFG_ARG_CHK_EN > 0u
;;;749        if (p_grp == (OS_FLAG_GRP *)0) {                        /* Validate 'p_grp'                                       */
00000e  b92d              CBNZ     r5,|L4.28|
;;;750           *p_err  =  OS_ERR_OBJ_PTR_NULL;
000010  f64550c3          MOV      r0,#0x5dc3
000014  8020              STRH     r0,[r4,#0]
;;;751            return ((OS_OBJ_QTY)0u);
000016  2000              MOVS     r0,#0
                  |L4.24|
;;;752        }
;;;753        switch (opt) {                                          /* Validate 'opt'                                         */
;;;754            case OS_OPT_PEND_ABORT_1:
;;;755            case OS_OPT_PEND_ABORT_ALL:
;;;756            case OS_OPT_PEND_ABORT_1   | OS_OPT_POST_NO_SCHED:
;;;757            case OS_OPT_PEND_ABORT_ALL | OS_OPT_POST_NO_SCHED:
;;;758                 break;
;;;759    
;;;760            default:
;;;761                *p_err = OS_ERR_OPT_INVALID;
;;;762                 return ((OS_OBJ_QTY)0u);
;;;763        }
;;;764    #endif
;;;765    
;;;766    #if OS_CFG_OBJ_TYPE_CHK_EN > 0u
;;;767        if (p_grp->Type != OS_OBJ_TYPE_FLAG) {                  /* Make sure event flag group was created                 */
;;;768           *p_err = OS_ERR_OBJ_TYPE;
;;;769            return ((OS_OBJ_QTY)0u);
;;;770        }
;;;771    #endif
;;;772    
;;;773        CPU_CRITICAL_ENTER();
;;;774        p_pend_list = &p_grp->PendList;
;;;775        if (p_pend_list->NbrEntries == (OS_OBJ_QTY)0u) {        /* Any task waiting on flag group?                        */
;;;776            CPU_CRITICAL_EXIT();                                /* No                                                     */
;;;777           *p_err = OS_ERR_PEND_ABORT_NONE;
;;;778            return ((OS_OBJ_QTY)0u);
;;;779        }
;;;780    
;;;781        OS_CRITICAL_ENTER_CPU_EXIT();
;;;782        nbr_tasks = 0u;
;;;783        ts        = OS_TS_GET();                                /* Get local time stamp so all tasks get the same time    */
;;;784        while (p_pend_list->NbrEntries > (OS_OBJ_QTY)0u) {
;;;785            p_tcb = p_pend_list->HeadPtr->TCBPtr;
;;;786            OS_PendAbort((OS_PEND_OBJ *)((void *)p_grp),
;;;787                         p_tcb,
;;;788                         ts);
;;;789            nbr_tasks++;
;;;790            if (opt != OS_OPT_PEND_ABORT_ALL) {                 /* Pend abort all tasks waiting?                          */
;;;791                break;                                          /* No                                                     */
;;;792            }
;;;793        }
;;;794        OS_CRITICAL_EXIT_NO_SCHED();
;;;795    
;;;796        if ((opt & OS_OPT_POST_NO_SCHED) == (OS_OPT)0u) {
;;;797            OSSched();                                          /* Run the scheduler                                      */
;;;798        }
;;;799    
;;;800       *p_err = OS_ERR_NONE;
;;;801        return (nbr_tasks);
;;;802    }
000018  e8bd9ff0          POP      {r4-r12,pc}
                  |L4.28|
00001c  b14e              CBZ      r6,|L4.50|
00001e  f5b67f80          CMP      r6,#0x100             ;753
000022  d007              BEQ      |L4.52|
000024  f5b64f00          CMP      r6,#0x8000            ;753
000028  d005              BEQ      |L4.54|
00002a  f5b64f01          CMP      r6,#0x8100            ;753
00002e  d104              BNE      |L4.58|
000030  e002              B        |L4.56|
                  |L4.50|
000032  bf00              NOP                            ;755
                  |L4.52|
000034  bf00              NOP                            ;756
                  |L4.54|
000036  bf00              NOP                            ;757
                  |L4.56|
000038  e004              B        |L4.68|
                  |L4.58|
00003a  f6456025          MOV      r0,#0x5e25            ;761
00003e  8020              STRH     r0,[r4,#0]            ;761
000040  2000              MOVS     r0,#0                 ;762
000042  e7e9              B        |L4.24|
                  |L4.68|
000044  bf00              NOP                            ;758
000046  4925              LDR      r1,|L4.220|
000048  6828              LDR      r0,[r5,#0]            ;767
00004a  4288              CMP      r0,r1                 ;767
00004c  d004              BEQ      |L4.88|
00004e  f64550c4          MOV      r0,#0x5dc4            ;768
000052  8020              STRH     r0,[r4,#0]            ;768
000054  2000              MOVS     r0,#0                 ;769
000056  e7df              B        |L4.24|
                  |L4.88|
000058  bf00              NOP                            ;773
00005a  bf00              NOP                            ;773
00005c  f7fffffe          BL       CPU_SR_Save
000060  4682              MOV      r10,r0                ;773
000062  bf00              NOP                            ;773
000064  bf00              NOP                            ;773
000066  f1050708          ADD      r7,r5,#8              ;774
00006a  8938              LDRH     r0,[r7,#8]            ;775
00006c  b958              CBNZ     r0,|L4.134|
00006e  bf00              NOP                            ;776
000070  bf00              NOP                            ;776
000072  4650              MOV      r0,r10                ;776
000074  f7fffffe          BL       CPU_SR_Restore
000078  bf00              NOP                            ;776
00007a  bf00              NOP                            ;776
00007c  f24610ab          MOV      r0,#0x61ab            ;777
000080  8020              STRH     r0,[r4,#0]            ;777
000082  2000              MOVS     r0,#0                 ;778
000084  e7c8              B        |L4.24|
                  |L4.134|
000086  f04f0800          MOV      r8,#0                 ;782
00008a  f7fffffe          BL       CPU_TS_TmrRd
00008e  4683              MOV      r11,r0                ;783
000090  e00f              B        |L4.178|
                  |L4.146|
000092  6838              LDR      r0,[r7,#0]            ;785
000094  f8d09008          LDR      r9,[r0,#8]            ;785
000098  465a              MOV      r2,r11                ;786
00009a  4649              MOV      r1,r9                 ;786
00009c  4628              MOV      r0,r5                 ;786
00009e  f7fffffe          BL       OS_PendAbort
0000a2  f1080001          ADD      r0,r8,#1              ;789
0000a6  fa1ff880          UXTH     r8,r0                 ;789
0000aa  f5b67f80          CMP      r6,#0x100             ;790
0000ae  d000              BEQ      |L4.178|
0000b0  e002              B        |L4.184|
                  |L4.178|
0000b2  8938              LDRH     r0,[r7,#8]            ;784
0000b4  2800              CMP      r0,#0                 ;784
0000b6  dcec              BGT      |L4.146|
                  |L4.184|
0000b8  bf00              NOP                            ;791
0000ba  bf00              NOP                            ;794
0000bc  bf00              NOP                            ;794
0000be  4650              MOV      r0,r10                ;794
0000c0  f7fffffe          BL       CPU_SR_Restore
0000c4  bf00              NOP                            ;794
0000c6  bf00              NOP                            ;794
0000c8  f4064000          AND      r0,r6,#0x8000         ;796
0000cc  b908              CBNZ     r0,|L4.210|
0000ce  f7fffffe          BL       OSSched
                  |L4.210|
0000d2  2000              MOVS     r0,#0                 ;800
0000d4  8020              STRH     r0,[r4,#0]            ;800
0000d6  4640              MOV      r0,r8                 ;801
0000d8  e79e              B        |L4.24|
;;;803    #endif
                          ENDP

0000da  0000              DCW      0x0000
                  |L4.220|
                          DCD      0x47414c46

                          AREA ||i.OSFlagPendGetFlagsRdy||, CODE, READONLY, ALIGN=2

                  OSFlagPendGetFlagsRdy PROC
;;;821    
;;;822    OS_FLAGS  OSFlagPendGetFlagsRdy (OS_ERR  *p_err)
000000  b570              PUSH     {r4-r6,lr}
;;;823    {
000002  4604              MOV      r4,r0
;;;824        OS_FLAGS   flags;
;;;825        CPU_SR_ALLOC();
000004  2600              MOVS     r6,#0
;;;826    
;;;827    
;;;828    
;;;829    #ifdef OS_SAFETY_CRITICAL
;;;830        if (p_err == (OS_ERR *)0) {
;;;831            OS_SAFETY_CRITICAL_EXCEPTION();
;;;832            return ((OS_FLAGS)0);
;;;833        }
;;;834    #endif
;;;835    
;;;836    #if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
;;;837        if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* See if called from ISR ...                             */
;;;838           *p_err = OS_ERR_PEND_ISR;                            /* ... can't get from an ISR                              */
;;;839            return ((OS_FLAGS)0);
;;;840        }
;;;841    #endif
;;;842    
;;;843        CPU_CRITICAL_ENTER();
000006  bf00              NOP      
000008  bf00              NOP      
00000a  f7fffffe          BL       CPU_SR_Save
00000e  4606              MOV      r6,r0
000010  bf00              NOP      
000012  bf00              NOP      
;;;844        flags = OSTCBCurPtr->FlagsRdy;
000014  4807              LDR      r0,|L5.52|
000016  6800              LDR      r0,[r0,#0]  ; OSTCBCurPtr
000018  f8d05080          LDR      r5,[r0,#0x80]
;;;845        CPU_CRITICAL_EXIT();
00001c  bf00              NOP      
00001e  bf00              NOP      
000020  4630              MOV      r0,r6
000022  f7fffffe          BL       CPU_SR_Restore
000026  bf00              NOP      
000028  bf00              NOP      
;;;846       *p_err = OS_ERR_NONE;
00002a  2000              MOVS     r0,#0
00002c  8020              STRH     r0,[r4,#0]
;;;847        return (flags);
00002e  4628              MOV      r0,r5
;;;848    }
000030  bd70              POP      {r4-r6,pc}
;;;849    
                          ENDP

000032  0000              DCW      0x0000
                  |L5.52|
                          DCD      OSTCBCurPtr

                          AREA ||i.OSFlagPost||, CODE, READONLY, ALIGN=2

                  OSFlagPost PROC
;;;891    
;;;892    OS_FLAGS  OSFlagPost (OS_FLAG_GRP  *p_grp,
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;893                          OS_FLAGS      flags,
;;;894                          OS_OPT        opt,
;;;895                          OS_ERR       *p_err)
;;;896    {
000004  4605              MOV      r5,r0
000006  4688              MOV      r8,r1
000008  4616              MOV      r6,r2
00000a  461c              MOV      r4,r3
;;;897        OS_FLAGS  flags_cur;
;;;898        CPU_TS    ts;
;;;899    
;;;900    
;;;901    
;;;902    #ifdef OS_SAFETY_CRITICAL
;;;903        if (p_err == (OS_ERR *)0) {
;;;904    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN > 0u))
;;;905            TRACE_OS_FLAG_POST_FAILED(p_grp);                   /* Record the event.                                      */
;;;906    #endif
;;;907            OS_SAFETY_CRITICAL_EXCEPTION();
;;;908            return ((OS_FLAGS)0);
;;;909        }
;;;910    #endif
;;;911    
;;;912    #if OS_CFG_ARG_CHK_EN > 0u
;;;913        if (p_grp == (OS_FLAG_GRP *)0) {                        /* Validate 'p_grp'                                       */
00000c  b92d              CBNZ     r5,|L6.26|
;;;914    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN > 0u))
;;;915            TRACE_OS_FLAG_POST_FAILED(p_grp);                   /* Record the event.                                      */
;;;916    #endif
;;;917           *p_err  = OS_ERR_OBJ_PTR_NULL;
00000e  f64550c3          MOV      r0,#0x5dc3
000012  8020              STRH     r0,[r4,#0]
;;;918            return ((OS_FLAGS)0);
000014  2000              MOVS     r0,#0
                  |L6.22|
;;;919        }
;;;920        switch (opt) {                                          /* Validate 'opt'                                         */
;;;921            case OS_OPT_POST_FLAG_SET:
;;;922            case OS_OPT_POST_FLAG_CLR:
;;;923            case OS_OPT_POST_FLAG_SET | OS_OPT_POST_NO_SCHED:
;;;924            case OS_OPT_POST_FLAG_CLR | OS_OPT_POST_NO_SCHED:
;;;925                 break;
;;;926    
;;;927            default:
;;;928    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN > 0u))
;;;929                 TRACE_OS_FLAG_POST_FAILED(p_grp);              /* Record the event.                                      */
;;;930    #endif
;;;931                *p_err = OS_ERR_OPT_INVALID;
;;;932                 return ((OS_FLAGS)0);
;;;933        }
;;;934    #endif
;;;935    
;;;936    #if OS_CFG_OBJ_TYPE_CHK_EN > 0u
;;;937        if (p_grp->Type != OS_OBJ_TYPE_FLAG) {                  /* Make sure we are pointing to an event flag grp         */
;;;938    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN > 0u))
;;;939            TRACE_OS_FLAG_POST_FAILED(p_grp);                   /* Record the event.                                      */
;;;940    #endif
;;;941           *p_err = OS_ERR_OBJ_TYPE;
;;;942            return ((OS_FLAGS)0);
;;;943        }
;;;944    #endif
;;;945    
;;;946        ts = OS_TS_GET();                                       /* Get timestamp                                          */
;;;947    #if OS_CFG_ISR_POST_DEFERRED_EN > 0u
;;;948        if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* See if called from an ISR                              */
;;;949            OS_IntQPost((OS_OBJ_TYPE)OS_OBJ_TYPE_FLAG,          /* Post to ISR queue                                      */
;;;950                        (void      *)p_grp,
;;;951                        (void      *)0,
;;;952                        (OS_MSG_SIZE)0,
;;;953                        (OS_FLAGS   )flags,
;;;954                        (OS_OPT     )opt,
;;;955                        (CPU_TS     )ts,
;;;956                        (OS_ERR    *)p_err);
;;;957    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN > 0u))
;;;958            TRACE_OS_FLAG_POST(p_grp);                          /* Record the event.                                      */
;;;959    #endif
;;;960            return ((OS_FLAGS)0);
;;;961        }
;;;962    #endif
;;;963    
;;;964        flags_cur = OS_FlagPost(p_grp,
;;;965                                flags,
;;;966                                opt,
;;;967                                ts,
;;;968                                p_err);
;;;969    
;;;970    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN > 0u))
;;;971        TRACE_OS_FLAG_POST(p_grp);                              /* Record the event.                                      */
;;;972    #endif    
;;;973    
;;;974        return (flags_cur);
;;;975    }
000016  e8bd83f8          POP      {r3-r9,pc}
                  |L6.26|
00001a  b14e              CBZ      r6,|L6.48|
00001c  2e01              CMP      r6,#1                 ;920
00001e  d008              BEQ      |L6.50|
000020  f5b64f00          CMP      r6,#0x8000            ;920
000024  d006              BEQ      |L6.52|
000026  f46f4000          MVN      r0,#0x8000            ;920
00002a  4430              ADD      r0,r0,r6              ;920
00002c  b920              CBNZ     r0,|L6.56|
00002e  e002              B        |L6.54|
                  |L6.48|
000030  bf00              NOP                            ;922
                  |L6.50|
000032  bf00              NOP                            ;923
                  |L6.52|
000034  bf00              NOP                            ;924
                  |L6.54|
000036  e004              B        |L6.66|
                  |L6.56|
000038  f6456025          MOV      r0,#0x5e25            ;931
00003c  8020              STRH     r0,[r4,#0]            ;931
00003e  2000              MOVS     r0,#0                 ;932
000040  e7e9              B        |L6.22|
                  |L6.66|
000042  bf00              NOP                            ;925
000044  490a              LDR      r1,|L6.112|
000046  6828              LDR      r0,[r5,#0]            ;937
000048  4288              CMP      r0,r1                 ;937
00004a  d004              BEQ      |L6.86|
00004c  f64550c4          MOV      r0,#0x5dc4            ;941
000050  8020              STRH     r0,[r4,#0]            ;941
000052  2000              MOVS     r0,#0                 ;942
000054  e7df              B        |L6.22|
                  |L6.86|
000056  f7fffffe          BL       CPU_TS_TmrRd
00005a  4681              MOV      r9,r0                 ;946
00005c  464b              MOV      r3,r9                 ;964
00005e  4632              MOV      r2,r6                 ;964
000060  4641              MOV      r1,r8                 ;964
000062  4628              MOV      r0,r5                 ;964
000064  9400              STR      r4,[sp,#0]            ;964
000066  f7fffffe          BL       OS_FlagPost
00006a  4607              MOV      r7,r0                 ;964
00006c  4638              MOV      r0,r7                 ;974
00006e  e7d2              B        |L6.22|
;;;976    
                          ENDP

                  |L6.112|
                          DCD      0x47414c46

                          AREA ||i.OS_FlagBlock||, CODE, READONLY, ALIGN=2

                  OS_FlagBlock PROC
;;;1013   
;;;1014   void  OS_FlagBlock (OS_PEND_DATA  *p_pend_data,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1015                       OS_FLAG_GRP   *p_grp,
;;;1016                       OS_FLAGS       flags,
;;;1017                       OS_OPT         opt,
;;;1018                       OS_TICK        timeout)
;;;1019   {
000004  4606              MOV      r6,r0
000006  460f              MOV      r7,r1
000008  4614              MOV      r4,r2
00000a  461d              MOV      r5,r3
00000c  f8dd8018          LDR      r8,[sp,#0x18]
;;;1020       OSTCBCurPtr->FlagsPend = flags;                         /* Save the flags that we need to wait for                */
000010  4809              LDR      r0,|L7.56|
000012  6800              LDR      r0,[r0,#0]  ; OSTCBCurPtr
000014  67c4              STR      r4,[r0,#0x7c]
;;;1021       OSTCBCurPtr->FlagsOpt  = opt;                           /* Save the type of wait we are doing                     */
000016  4808              LDR      r0,|L7.56|
000018  6800              LDR      r0,[r0,#0]  ; OSTCBCurPtr
00001a  f8a05084          STRH     r5,[r0,#0x84]
;;;1022       OSTCBCurPtr->FlagsRdy  = (OS_FLAGS)0;
00001e  2000              MOVS     r0,#0
000020  4905              LDR      r1,|L7.56|
000022  6809              LDR      r1,[r1,#0]  ; OSTCBCurPtr
000024  f8c10080          STR      r0,[r1,#0x80]
;;;1023   
;;;1024       OS_Pend(p_pend_data,
000028  4643              MOV      r3,r8
00002a  2201              MOVS     r2,#1
00002c  4639              MOV      r1,r7
00002e  4630              MOV      r0,r6
000030  f7fffffe          BL       OS_Pend
;;;1025               (OS_PEND_OBJ *)((void *)p_grp),
;;;1026                OS_TASK_PEND_ON_FLAG,
;;;1027                timeout);
;;;1028   }
000034  e8bd81f0          POP      {r4-r8,pc}
;;;1029   
                          ENDP

                  |L7.56|
                          DCD      OSTCBCurPtr

                          AREA ||i.OS_FlagClr||, CODE, READONLY, ALIGN=2

                  OS_FlagClr PROC
;;;1046   
;;;1047   void  OS_FlagClr (OS_FLAG_GRP  *p_grp)
000000  b570              PUSH     {r4-r6,lr}
;;;1048   {
000002  4604              MOV      r4,r0
;;;1049       OS_PEND_LIST  *p_pend_list;
;;;1050   
;;;1051   
;;;1052   #if OS_OBJ_TYPE_REQ > 0u
;;;1053       p_grp->Type             = OS_OBJ_TYPE_NONE;
000004  4805              LDR      r0,|L8.28|
000006  6020              STR      r0,[r4,#0]
;;;1054   #endif
;;;1055   #if OS_CFG_DBG_EN > 0u
;;;1056       p_grp->NamePtr          = (CPU_CHAR *)((void *)"?FLAG");    /* Unknown name                                       */
000008  a005              ADR      r0,|L8.32|
00000a  6060              STR      r0,[r4,#4]
;;;1057   #endif
;;;1058       p_grp->Flags            = (OS_FLAGS )0;
00000c  2000              MOVS     r0,#0
00000e  6220              STR      r0,[r4,#0x20]
;;;1059       p_pend_list             = &p_grp->PendList;
000010  f1040508          ADD      r5,r4,#8
;;;1060       OS_PendListInit(p_pend_list);
000014  4628              MOV      r0,r5
000016  f7fffffe          BL       OS_PendListInit
;;;1061   }
00001a  bd70              POP      {r4-r6,pc}
;;;1062   
                          ENDP

                  |L8.28|
                          DCD      0x454e4f4e
                  |L8.32|
000020  3f464c41          DCB      "?FLAG",0
000024  4700    
000026  00                DCB      0
000027  00                DCB      0

                          AREA ||i.OS_FlagDbgListAdd||, CODE, READONLY, ALIGN=2

                  OS_FlagDbgListAdd PROC
;;;1114   #if OS_CFG_DBG_EN > 0u
;;;1115   void  OS_FlagDbgListAdd (OS_FLAG_GRP  *p_grp)
000000  a109              ADR      r1,|L9.40|
;;;1116   {
;;;1117       p_grp->DbgNamePtr                = (CPU_CHAR    *)((void *)" ");
000002  61c1              STR      r1,[r0,#0x1c]
;;;1118       p_grp->DbgPrevPtr                = (OS_FLAG_GRP *)0;
000004  2100              MOVS     r1,#0
000006  6141              STR      r1,[r0,#0x14]
;;;1119       if (OSFlagDbgListPtr == (OS_FLAG_GRP *)0) {
000008  4908              LDR      r1,|L9.44|
00000a  6809              LDR      r1,[r1,#0]  ; OSFlagDbgListPtr
00000c  b911              CBNZ     r1,|L9.20|
;;;1120           p_grp->DbgNextPtr            = (OS_FLAG_GRP *)0;
00000e  2100              MOVS     r1,#0
000010  6181              STR      r1,[r0,#0x18]
000012  e005              B        |L9.32|
                  |L9.20|
;;;1121       } else {
;;;1122           p_grp->DbgNextPtr            =  OSFlagDbgListPtr;
000014  4905              LDR      r1,|L9.44|
000016  6809              LDR      r1,[r1,#0]  ; OSFlagDbgListPtr
000018  6181              STR      r1,[r0,#0x18]
;;;1123           OSFlagDbgListPtr->DbgPrevPtr =  p_grp;
00001a  4904              LDR      r1,|L9.44|
00001c  6809              LDR      r1,[r1,#0]  ; OSFlagDbgListPtr
00001e  6148              STR      r0,[r1,#0x14]
                  |L9.32|
;;;1124       }
;;;1125       OSFlagDbgListPtr                 =  p_grp;
000020  4902              LDR      r1,|L9.44|
000022  6008              STR      r0,[r1,#0]  ; OSFlagDbgListPtr
;;;1126   }
000024  4770              BX       lr
;;;1127   
                          ENDP

000026  0000              DCW      0x0000
                  |L9.40|
000028  2000              DCB      " ",0
00002a  00                DCB      0
00002b  00                DCB      0
                  |L9.44|
                          DCD      OSFlagDbgListPtr

                          AREA ||i.OS_FlagDbgListRemove||, CODE, READONLY, ALIGN=2

                  OS_FlagDbgListRemove PROC
;;;1129   
;;;1130   void  OS_FlagDbgListRemove (OS_FLAG_GRP  *p_grp)
000000  6942              LDR      r2,[r0,#0x14]
;;;1131   {
;;;1132       OS_FLAG_GRP  *p_grp_next;
;;;1133       OS_FLAG_GRP  *p_grp_prev;
;;;1134   
;;;1135   
;;;1136       p_grp_prev = p_grp->DbgPrevPtr;
;;;1137       p_grp_next = p_grp->DbgNextPtr;
000002  6981              LDR      r1,[r0,#0x18]
;;;1138   
;;;1139       if (p_grp_prev == (OS_FLAG_GRP *)0) {
000004  b93a              CBNZ     r2,|L10.22|
;;;1140           OSFlagDbgListPtr = p_grp_next;
000006  4b09              LDR      r3,|L10.44|
000008  6019              STR      r1,[r3,#0]  ; OSFlagDbgListPtr
;;;1141           if (p_grp_next != (OS_FLAG_GRP *)0) {
00000a  b109              CBZ      r1,|L10.16|
;;;1142               p_grp_next->DbgPrevPtr = (OS_FLAG_GRP *)0;
00000c  2300              MOVS     r3,#0
00000e  614b              STR      r3,[r1,#0x14]
                  |L10.16|
;;;1143           }
;;;1144           p_grp->DbgNextPtr = (OS_FLAG_GRP *)0;
000010  2300              MOVS     r3,#0
000012  6183              STR      r3,[r0,#0x18]
000014  e009              B        |L10.42|
                  |L10.22|
;;;1145   
;;;1146       } else if (p_grp_next == (OS_FLAG_GRP *)0) {
000016  b919              CBNZ     r1,|L10.32|
;;;1147           p_grp_prev->DbgNextPtr = (OS_FLAG_GRP *)0;
000018  2300              MOVS     r3,#0
00001a  6193              STR      r3,[r2,#0x18]
;;;1148           p_grp->DbgPrevPtr      = (OS_FLAG_GRP *)0;
00001c  6143              STR      r3,[r0,#0x14]
00001e  e004              B        |L10.42|
                  |L10.32|
;;;1149   
;;;1150       } else {
;;;1151           p_grp_prev->DbgNextPtr =  p_grp_next;
000020  6191              STR      r1,[r2,#0x18]
;;;1152           p_grp_next->DbgPrevPtr =  p_grp_prev;
000022  614a              STR      r2,[r1,#0x14]
;;;1153           p_grp->DbgNextPtr      = (OS_FLAG_GRP *)0;
000024  2300              MOVS     r3,#0
000026  6183              STR      r3,[r0,#0x18]
;;;1154           p_grp->DbgPrevPtr      = (OS_FLAG_GRP *)0;
000028  6143              STR      r3,[r0,#0x14]
                  |L10.42|
;;;1155       }
;;;1156   }
00002a  4770              BX       lr
;;;1157   #endif
                          ENDP

                  |L10.44|
                          DCD      OSFlagDbgListPtr

                          AREA ||i.OS_FlagInit||, CODE, READONLY, ALIGN=2

                  OS_FlagInit PROC
;;;1080   
;;;1081   void  OS_FlagInit (OS_ERR  *p_err)
000000  2100              MOVS     r1,#0
;;;1082   {
;;;1083   #ifdef OS_SAFETY_CRITICAL
;;;1084       if (p_err == (OS_ERR *)0) {
;;;1085           OS_SAFETY_CRITICAL_EXCEPTION();
;;;1086           return;
;;;1087       }
;;;1088   #endif
;;;1089   
;;;1090   #if OS_CFG_DBG_EN > 0u
;;;1091       OSFlagDbgListPtr = (OS_FLAG_GRP *)0;
000002  4a03              LDR      r2,|L11.16|
000004  6011              STR      r1,[r2,#0]  ; OSFlagDbgListPtr
;;;1092   #endif
;;;1093   
;;;1094       OSFlagQty        = (OS_OBJ_QTY   )0;
000006  4a03              LDR      r2,|L11.20|
000008  8011              STRH     r1,[r2,#0]
;;;1095      *p_err            = OS_ERR_NONE;
00000a  8001              STRH     r1,[r0,#0]
;;;1096   }
00000c  4770              BX       lr
;;;1097   
                          ENDP

00000e  0000              DCW      0x0000
                  |L11.16|
                          DCD      OSFlagDbgListPtr
                  |L11.20|
                          DCD      OSFlagQty

                          AREA ||i.OS_FlagPost||, CODE, READONLY, ALIGN=1

                  OS_FlagPost PROC
;;;1202   
;;;1203   OS_FLAGS  OS_FlagPost (OS_FLAG_GRP  *p_grp,
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;1204                          OS_FLAGS      flags,
;;;1205                          OS_OPT        opt,
;;;1206                          CPU_TS        ts,
;;;1207                          OS_ERR       *p_err)
;;;1208   {
000004  b085              SUB      sp,sp,#0x14
000006  4604              MOV      r4,r0
000008  4689              MOV      r9,r1
00000a  4692              MOV      r10,r2
00000c  469b              MOV      r11,r3
00000e  f8dd8038          LDR      r8,[sp,#0x38]
;;;1209       OS_FLAGS        flags_cur;
;;;1210       OS_FLAGS        flags_rdy;
;;;1211       OS_OPT          mode;
;;;1212       OS_PEND_DATA   *p_pend_data;
;;;1213       OS_PEND_DATA   *p_pend_data_next;
;;;1214       OS_PEND_LIST   *p_pend_list;
;;;1215       OS_TCB         *p_tcb;
;;;1216       CPU_SR_ALLOC();
000012  2000              MOVS     r0,#0
000014  9000              STR      r0,[sp,#0]
;;;1217   
;;;1218   
;;;1219   
;;;1220       CPU_CRITICAL_ENTER();
000016  bf00              NOP      
000018  bf00              NOP      
00001a  f7fffffe          BL       CPU_SR_Save
00001e  9000              STR      r0,[sp,#0]
000020  bf00              NOP      
000022  bf00              NOP      
;;;1221       switch (opt) {
000024  f1ba0f00          CMP      r10,#0
000028  d00a              BEQ      |L12.64|
00002a  f1ba0f01          CMP      r10,#1
00002e  d00d              BEQ      |L12.76|
000030  f5ba4f00          CMP      r10,#0x8000
000034  d005              BEQ      |L12.66|
000036  f46f4000          MVN      r0,#0x8000
00003a  4450              ADD      r0,r0,r10
00003c  b960              CBNZ     r0,|L12.88|
00003e  e006              B        |L12.78|
                  |L12.64|
;;;1222           case OS_OPT_POST_FLAG_SET:
;;;1223           case OS_OPT_POST_FLAG_SET | OS_OPT_POST_NO_SCHED:
000040  bf00              NOP      
                  |L12.66|
;;;1224                p_grp->Flags |=  flags;                            /* Set   the flags specified in the group             */
000042  6a20              LDR      r0,[r4,#0x20]
000044  ea400009          ORR      r0,r0,r9
000048  6220              STR      r0,[r4,#0x20]
;;;1225                break;
00004a  e014              B        |L12.118|
                  |L12.76|
;;;1226   
;;;1227           case OS_OPT_POST_FLAG_CLR:
;;;1228           case OS_OPT_POST_FLAG_CLR | OS_OPT_POST_NO_SCHED:
00004c  bf00              NOP      
                  |L12.78|
;;;1229                p_grp->Flags &= ~flags;                            /* Clear the flags specified in the group             */
00004e  6a20              LDR      r0,[r4,#0x20]
000050  ea200009          BIC      r0,r0,r9
000054  6220              STR      r0,[r4,#0x20]
;;;1230                break;
000056  e00e              B        |L12.118|
                  |L12.88|
;;;1231   
;;;1232           default:
;;;1233                CPU_CRITICAL_EXIT();                               /* INVALID option                                     */
000058  bf00              NOP      
00005a  bf00              NOP      
00005c  9800              LDR      r0,[sp,#0]
00005e  f7fffffe          BL       CPU_SR_Restore
000062  bf00              NOP      
000064  bf00              NOP      
;;;1234               *p_err = OS_ERR_OPT_INVALID;
000066  f6456025          MOV      r0,#0x5e25
00006a  f8a80000          STRH     r0,[r8,#0]
;;;1235                return ((OS_FLAGS)0);
00006e  2000              MOVS     r0,#0
                  |L12.112|
;;;1236       }
;;;1237       p_grp->TS   = ts;
;;;1238       p_pend_list = &p_grp->PendList;
;;;1239       if (p_pend_list->NbrEntries == 0u) {                        /* Any task waiting on event flag group?              */
;;;1240           CPU_CRITICAL_EXIT();                                    /* No                                                 */
;;;1241          *p_err = OS_ERR_NONE;
;;;1242           return (p_grp->Flags);
;;;1243       }
;;;1244   
;;;1245       OS_CRITICAL_ENTER_CPU_EXIT();
;;;1246       p_pend_data = p_pend_list->HeadPtr;
;;;1247       p_tcb       = p_pend_data->TCBPtr;
;;;1248       while (p_tcb != (OS_TCB *)0) {                              /* Go through all tasks waiting on event flag(s)      */
;;;1249           p_pend_data_next = p_pend_data->NextPtr;
;;;1250           mode             = p_tcb->FlagsOpt & OS_OPT_PEND_FLAG_MASK;
;;;1251           switch (mode) {
;;;1252               case OS_OPT_PEND_FLAG_SET_ALL:                      /* See if all req. flags are set for current node     */
;;;1253                    flags_rdy = (OS_FLAGS)(p_grp->Flags & p_tcb->FlagsPend);
;;;1254                    if (flags_rdy == p_tcb->FlagsPend) {
;;;1255                        OS_FlagTaskRdy(p_tcb,                      /* Make task RTR, event(s) Rx'd                       */
;;;1256                                       flags_rdy,
;;;1257                                       ts);
;;;1258                    }
;;;1259                    break;
;;;1260   
;;;1261               case OS_OPT_PEND_FLAG_SET_ANY:                      /* See if any flag set                                */
;;;1262                    flags_rdy = (OS_FLAGS)(p_grp->Flags & p_tcb->FlagsPend);
;;;1263                    if (flags_rdy != (OS_FLAGS)0) {
;;;1264                        OS_FlagTaskRdy(p_tcb,                      /* Make task RTR, event(s) Rx'd                       */
;;;1265                                       flags_rdy,
;;;1266                                       ts);
;;;1267                    }
;;;1268                    break;
;;;1269   
;;;1270   #if OS_CFG_FLAG_MODE_CLR_EN > 0u
;;;1271               case OS_OPT_PEND_FLAG_CLR_ALL:                      /* See if all req. flags are set for current node     */
;;;1272                    flags_rdy = (OS_FLAGS)(~p_grp->Flags & p_tcb->FlagsPend);
;;;1273                    if (flags_rdy == p_tcb->FlagsPend) {
;;;1274                        OS_FlagTaskRdy(p_tcb,                      /* Make task RTR, event(s) Rx'd                       */
;;;1275                                       flags_rdy,
;;;1276                                       ts);
;;;1277                    }
;;;1278                    break;
;;;1279   
;;;1280               case OS_OPT_PEND_FLAG_CLR_ANY:                      /* See if any flag set                                */
;;;1281                    flags_rdy = (OS_FLAGS)(~p_grp->Flags & p_tcb->FlagsPend);
;;;1282                    if (flags_rdy != (OS_FLAGS)0) {
;;;1283                        OS_FlagTaskRdy(p_tcb,                      /* Make task RTR, event(s) Rx'd                       */
;;;1284                                       flags_rdy,
;;;1285                                       ts);
;;;1286                    }
;;;1287                    break;
;;;1288   #endif
;;;1289               default:
;;;1290                    OS_CRITICAL_EXIT();
;;;1291                   *p_err = OS_ERR_FLAG_PEND_OPT;
;;;1292                    return ((OS_FLAGS)0);
;;;1293           }
;;;1294           p_pend_data = p_pend_data_next;                         /* Point to next task waiting for event flag(s)       */
;;;1295           if (p_pend_data != (OS_PEND_DATA *)0) {
;;;1296               p_tcb = p_pend_data->TCBPtr;
;;;1297           } else {
;;;1298               p_tcb = (OS_TCB *)0;
;;;1299           }
;;;1300       }
;;;1301       OS_CRITICAL_EXIT_NO_SCHED();
;;;1302   
;;;1303       if ((opt & OS_OPT_POST_NO_SCHED) == (OS_OPT)0) {
;;;1304           OSSched();
;;;1305       }
;;;1306   
;;;1307       CPU_CRITICAL_ENTER();
;;;1308       flags_cur = p_grp->Flags;
;;;1309       CPU_CRITICAL_EXIT();
;;;1310      *p_err     = OS_ERR_NONE;
;;;1311       return (flags_cur);
;;;1312   }
000070  b005              ADD      sp,sp,#0x14
000072  e8bd8ff0          POP      {r4-r11,pc}
                  |L12.118|
000076  bf00              NOP                            ;1225
000078  f8c4b024          STR      r11,[r4,#0x24]        ;1237
00007c  f1040008          ADD      r0,r4,#8              ;1238
000080  9001              STR      r0,[sp,#4]            ;1238
000082  9801              LDR      r0,[sp,#4]            ;1239
000084  8900              LDRH     r0,[r0,#8]            ;1239
000086  b958              CBNZ     r0,|L12.160|
000088  bf00              NOP                            ;1240
00008a  bf00              NOP                            ;1240
00008c  9800              LDR      r0,[sp,#0]            ;1240
00008e  f7fffffe          BL       CPU_SR_Restore
000092  bf00              NOP                            ;1240
000094  bf00              NOP                            ;1240
000096  2000              MOVS     r0,#0                 ;1241
000098  f8a80000          STRH     r0,[r8,#0]            ;1241
00009c  6a20              LDR      r0,[r4,#0x20]         ;1242
00009e  e7e7              B        |L12.112|
                  |L12.160|
0000a0  9801              LDR      r0,[sp,#4]            ;1246
0000a2  6807              LDR      r7,[r0,#0]            ;1246
0000a4  68bd              LDR      r5,[r7,#8]            ;1247
0000a6  e053              B        |L12.336|
                  |L12.168|
0000a8  6878              LDR      r0,[r7,#4]            ;1249
0000aa  9002              STR      r0,[sp,#8]            ;1249
0000ac  f8950084          LDRB     r0,[r5,#0x84]         ;1250
0000b0  f000000f          AND      r0,r0,#0xf            ;1250
0000b4  9003              STR      r0,[sp,#0xc]          ;1250
0000b6  9803              LDR      r0,[sp,#0xc]          ;1251
0000b8  2801              CMP      r0,#1                 ;1251
0000ba  d01e              BEQ      |L12.250|
0000bc  2802              CMP      r0,#2                 ;1251
0000be  d029              BEQ      |L12.276|
0000c0  2804              CMP      r0,#4                 ;1251
0000c2  d002              BEQ      |L12.202|
0000c4  2808              CMP      r0,#8                 ;1251
0000c6  d130              BNE      |L12.298|
0000c8  e00c              B        |L12.228|
                  |L12.202|
0000ca  6a20              LDR      r0,[r4,#0x20]         ;1253
0000cc  6fe9              LDR      r1,[r5,#0x7c]         ;1253
0000ce  ea000601          AND      r6,r0,r1              ;1253
0000d2  6fe8              LDR      r0,[r5,#0x7c]         ;1254
0000d4  42b0              CMP      r0,r6                 ;1254
0000d6  d104              BNE      |L12.226|
0000d8  465a              MOV      r2,r11                ;1255
0000da  4631              MOV      r1,r6                 ;1255
0000dc  4628              MOV      r0,r5                 ;1255
0000de  f7fffffe          BL       OS_FlagTaskRdy
                  |L12.226|
0000e2  e02f              B        |L12.324|
                  |L12.228|
0000e4  6a20              LDR      r0,[r4,#0x20]         ;1262
0000e6  6fe9              LDR      r1,[r5,#0x7c]         ;1262
0000e8  ea000601          AND      r6,r0,r1              ;1262
0000ec  b126              CBZ      r6,|L12.248|
0000ee  465a              MOV      r2,r11                ;1264
0000f0  4631              MOV      r1,r6                 ;1264
0000f2  4628              MOV      r0,r5                 ;1264
0000f4  f7fffffe          BL       OS_FlagTaskRdy
                  |L12.248|
0000f8  e024              B        |L12.324|
                  |L12.250|
0000fa  6fe8              LDR      r0,[r5,#0x7c]         ;1272
0000fc  6a21              LDR      r1,[r4,#0x20]         ;1272
0000fe  ea200601          BIC      r6,r0,r1              ;1272
000102  6fe8              LDR      r0,[r5,#0x7c]         ;1273
000104  42b0              CMP      r0,r6                 ;1273
000106  d104              BNE      |L12.274|
000108  465a              MOV      r2,r11                ;1274
00010a  4631              MOV      r1,r6                 ;1274
00010c  4628              MOV      r0,r5                 ;1274
00010e  f7fffffe          BL       OS_FlagTaskRdy
                  |L12.274|
000112  e017              B        |L12.324|
                  |L12.276|
000114  6fe8              LDR      r0,[r5,#0x7c]         ;1281
000116  6a21              LDR      r1,[r4,#0x20]         ;1281
000118  ea200601          BIC      r6,r0,r1              ;1281
00011c  b126              CBZ      r6,|L12.296|
00011e  465a              MOV      r2,r11                ;1283
000120  4631              MOV      r1,r6                 ;1283
000122  4628              MOV      r0,r5                 ;1283
000124  f7fffffe          BL       OS_FlagTaskRdy
                  |L12.296|
000128  e00c              B        |L12.324|
                  |L12.298|
00012a  bf00              NOP                            ;1290
00012c  bf00              NOP                            ;1290
00012e  9800              LDR      r0,[sp,#0]            ;1290
000130  f7fffffe          BL       CPU_SR_Restore
000134  bf00              NOP                            ;1290
000136  bf00              NOP                            ;1290
000138  f64320ff          MOV      r0,#0x3aff            ;1291
00013c  f8a80000          STRH     r0,[r8,#0]            ;1291
000140  2000              MOVS     r0,#0                 ;1292
000142  e795              B        |L12.112|
                  |L12.324|
000144  bf00              NOP                            ;1259
000146  9f02              LDR      r7,[sp,#8]            ;1294
000148  b10f              CBZ      r7,|L12.334|
00014a  68bd              LDR      r5,[r7,#8]            ;1296
00014c  e000              B        |L12.336|
                  |L12.334|
00014e  2500              MOVS     r5,#0                 ;1298
                  |L12.336|
000150  2d00              CMP      r5,#0                 ;1248
000152  d1a9              BNE      |L12.168|
000154  bf00              NOP                            ;1301
000156  bf00              NOP                            ;1301
000158  9800              LDR      r0,[sp,#0]            ;1301
00015a  f7fffffe          BL       CPU_SR_Restore
00015e  bf00              NOP                            ;1301
000160  bf00              NOP                            ;1301
000162  f40a4000          AND      r0,r10,#0x8000        ;1303
000166  b908              CBNZ     r0,|L12.364|
000168  f7fffffe          BL       OSSched
                  |L12.364|
00016c  bf00              NOP                            ;1307
00016e  bf00              NOP                            ;1307
000170  f7fffffe          BL       CPU_SR_Save
000174  9000              STR      r0,[sp,#0]            ;1307
000176  bf00              NOP                            ;1307
000178  bf00              NOP                            ;1307
00017a  6a20              LDR      r0,[r4,#0x20]         ;1308
00017c  9004              STR      r0,[sp,#0x10]         ;1308
00017e  bf00              NOP                            ;1309
000180  bf00              NOP                            ;1309
000182  9800              LDR      r0,[sp,#0]            ;1309
000184  f7fffffe          BL       CPU_SR_Restore
000188  bf00              NOP                            ;1309
00018a  bf00              NOP                            ;1309
00018c  2000              MOVS     r0,#0                 ;1310
00018e  f8a80000          STRH     r0,[r8,#0]            ;1310
000192  9804              LDR      r0,[sp,#0x10]         ;1311
000194  e76c              B        |L12.112|
;;;1313   
                          ENDP


                          AREA ||i.OS_FlagTaskRdy||, CODE, READONLY, ALIGN=1

                  OS_FlagTaskRdy PROC
;;;1334   
;;;1335   void   OS_FlagTaskRdy (OS_TCB    *p_tcb,
000000  b570              PUSH     {r4-r6,lr}
;;;1336                          OS_FLAGS   flags_rdy,
;;;1337                          CPU_TS     ts)
;;;1338   {
000002  4604              MOV      r4,r0
000004  460e              MOV      r6,r1
000006  4615              MOV      r5,r2
;;;1339       p_tcb->FlagsRdy   = flags_rdy;
000008  3434              ADDS     r4,r4,#0x34
00000a  64e6              STR      r6,[r4,#0x4c]
;;;1340       p_tcb->PendStatus = OS_STATUS_PEND_OK;                  /* Clear pend status                                      */
00000c  2000              MOVS     r0,#0
00000e  7060              STRB     r0,[r4,#1]
;;;1341       p_tcb->PendOn     = OS_TASK_PEND_ON_NOTHING;            /* Indicate no longer pending                             */
000010  7020              STRB     r0,[r4,#0]
;;;1342       p_tcb->TS         = ts;
000012  6165              STR      r5,[r4,#0x14]
;;;1343       switch (p_tcb->TaskState) {
000014  78a0              LDRB     r0,[r4,#2]
000016  3c34              SUBS     r4,r4,#0x34
000018  2808              CMP      r0,#8
00001a  d21d              BCS      |L13.88|
00001c  e8dff000          TBB      [pc,r0]
000020  04050809          DCB      0x04,0x05,0x08,0x09
000024  07061718          DCB      0x07,0x06,0x17,0x18
;;;1344           case OS_TASK_STATE_RDY:
;;;1345           case OS_TASK_STATE_DLY:
000028  bf00              NOP      
;;;1346           case OS_TASK_STATE_DLY_SUSPENDED:
00002a  bf00              NOP      
;;;1347           case OS_TASK_STATE_SUSPENDED:
00002c  bf00              NOP      
;;;1348                break;
00002e  e014              B        |L13.90|
;;;1349   
;;;1350           case OS_TASK_STATE_PEND:
;;;1351           case OS_TASK_STATE_PEND_TIMEOUT:
000030  bf00              NOP      
;;;1352                if (p_tcb->TaskState == OS_TASK_STATE_PEND_TIMEOUT) {
000032  f8940036          LDRB     r0,[r4,#0x36]
000036  2803              CMP      r0,#3
000038  d102              BNE      |L13.64|
;;;1353                    OS_TickListRemove(p_tcb);                  /* Remove from tick list                                  */
00003a  4620              MOV      r0,r4
00003c  f7fffffe          BL       OS_TickListRemove
                  |L13.64|
;;;1354                }
;;;1355                OS_RdyListInsert(p_tcb);                       /* Insert the task in the ready list                      */
000040  4620              MOV      r0,r4
000042  f7fffffe          BL       OS_RdyListInsert
;;;1356                p_tcb->TaskState = OS_TASK_STATE_RDY;
000046  2000              MOVS     r0,#0
000048  f8840036          STRB     r0,[r4,#0x36]
;;;1357                break;
00004c  e005              B        |L13.90|
;;;1358   
;;;1359           case OS_TASK_STATE_PEND_SUSPENDED:
;;;1360           case OS_TASK_STATE_PEND_TIMEOUT_SUSPENDED:
00004e  bf00              NOP      
;;;1361                p_tcb->TaskState = OS_TASK_STATE_SUSPENDED;
000050  2004              MOVS     r0,#4
000052  f8840036          STRB     r0,[r4,#0x36]
;;;1362                break;
000056  e000              B        |L13.90|
                  |L13.88|
;;;1363   
;;;1364           default:
;;;1365                break;
000058  bf00              NOP      
                  |L13.90|
00005a  bf00              NOP                            ;1348
;;;1366       }
;;;1367       OS_PendListRemove(p_tcb);
00005c  4620              MOV      r0,r4
00005e  f7fffffe          BL       OS_PendListRemove
;;;1368   }
000062  bd70              POP      {r4-r6,pc}
;;;1369   #endif
                          ENDP

